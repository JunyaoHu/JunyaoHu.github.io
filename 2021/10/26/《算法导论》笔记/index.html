

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="胡椒">
  <meta name="keywords" content="计算机视觉,深度学习">
  
    <meta name="description" content="概论重要特性  输入、输出、确定性、有限性 算法描述  自然语言、流程图、伪代码、程序代码 算法的复杂性  时间复杂性、空间复杂性 算法的渐进性态 $O(g(n))$ 上界 $Ω(g(n))$ 下界 $Θ(g(n))$ 确界 $logn &lt; n &lt; nlogn &lt; n^2 &lt; n^3 &lt;2^n$ NP完全理论  能在多项式时间内求解的判定性问题称为P问题，在多项式时间">
<meta property="og:type" content="article">
<meta property="og:title" content="《算法导论》笔记">
<meta property="og:url" content="https://junyaohu.github.io/2021/10/26/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="胡椒的 Coding Room">
<meta property="og:description" content="概论重要特性  输入、输出、确定性、有限性 算法描述  自然语言、流程图、伪代码、程序代码 算法的复杂性  时间复杂性、空间复杂性 算法的渐进性态 $O(g(n))$ 上界 $Ω(g(n))$ 下界 $Θ(g(n))$ 确界 $logn &lt; n &lt; nlogn &lt; n^2 &lt; n^3 &lt;2^n$ NP完全理论  能在多项式时间内求解的判定性问题称为P问题，在多项式时间">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/10/26/Gm4dM5kU1rN2K9Y.jpg">
<meta property="og:image" content="https://s2.loli.net/2021/12/07/y2EaPBCRoXkjQWO.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/06/U93fnXqQmOthd68.png">
<meta property="og:image" content="https://i.loli.net/2021/11/03/AiVcQH3dqO6XTpa.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/07/isJWTNkCPd4ORfS.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/07/sTxqwMUX5JoyA3g.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/07/ViKmFwAuHB3PQ27.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/07/8d7TXheayMsRpr1.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/07/PUfmEldrnXp9W8B.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/07/k9Gt8KfjJzgrnBc.png">
<meta property="og:image" content="https://i.loli.net/2021/11/13/Gn7oYtlkrdaIzhC.png">
<meta property="og:image" content="https://i.loli.net/2021/11/14/5kI9jcio2xabpgC.png">
<meta property="og:image" content="https://i.loli.net/2021/11/14/VuRe1vE9fZ6tKcS.png">
<meta property="og:image" content="https://i.loli.net/2021/11/16/81LgIlVw5zusOx9.png">
<meta property="og:image" content="https://i.loli.net/2021/11/14/RuqJGtPOHmzlV6n.png">
<meta property="og:image" content="https://i.loli.net/2021/11/14/zurCOpm69MXy3Hk.png">
<meta property="og:image" content="https://i.loli.net/2021/11/14/7TLS4elkFUYRHOu.png">
<meta property="og:image" content="https://i.loli.net/2021/11/14/8KqMfCEVO9LyBxs.png">
<meta property="og:image" content="https://i.loli.net/2021/11/14/uSJZqLQAlK3TedO.png">
<meta property="og:image" content="https://i.loli.net/2021/11/14/usNAxhWT4jkSvbQ.png">
<meta property="og:image" content="https://i.loli.net/2021/11/14/ioq9NwWbhaYLnpT.png">
<meta property="og:image" content="https://i.loli.net/2021/11/16/wrZ41YiqExp6QSc.png">
<meta property="og:image" content="https://i.loli.net/2021/11/16/bjfoQFy5YwlKaDS.png">
<meta property="og:image" content="https://i.loli.net/2021/11/16/X4e2TVIv6z8GZsO.png">
<meta property="og:image" content="https://i.loli.net/2021/11/14/o8DeUcu1SzGlpP6.png">
<meta property="og:image" content="https://i.loli.net/2021/11/16/okxtwCMfvdA1SsO.png">
<meta property="og:image" content="https://i.loli.net/2021/11/16/PK1ROEXvV3mJlcY.png">
<meta property="og:image" content="https://i.loli.net/2021/11/16/ZKs1IP4xDRMmgbO.png">
<meta property="og:image" content="https://i.loli.net/2021/11/16/PMr6sCnxNp7hkGo.png">
<meta property="og:image" content="https://i.loli.net/2021/11/16/QEZtAoMVafKiuY4.png">
<meta property="article:published_time" content="2021-10-26T05:30:03.000Z">
<meta property="article:modified_time" content="2022-08-02T11:38:26.598Z">
<meta property="article:author" content="胡椒">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="分治">
<meta property="article:tag" content="动态规划">
<meta property="article:tag" content="贪心">
<meta property="article:tag" content="回溯">
<meta property="article:tag" content="分支限界">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://i.loli.net/2021/10/26/Gm4dM5kU1rN2K9Y.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>《算法导论》笔记 - 胡椒的 Coding Room</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"junyaohu.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":"home"},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3","collapseDepth":2},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":19383194,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?19383194";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  



  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>胡椒的 Coding Room</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-user-fill"></i>
                <span>主页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                <span>博客</span>
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/articles/">
                    <i class="iconfont icon-notebook"></i>
                    <span>总览</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/archives/">
                    <i class="iconfont icon-archive-fill"></i>
                    <span>归档</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/">
                    <i class="iconfont icon-category-fill"></i>
                    <span>分类</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/tags/">
                    <i class="iconfont icon-tags-fill"></i>
                    <span>标签</span>
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/publication/">
                <i class="iconfont icon-pen"></i>
                <span>论文</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/CV.pdf">
                <i class="iconfont icon-note"></i>
                <span>简历</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/gallery/">
                <i class="iconfont icon-image"></i>
                <span>图集</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.1)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">《算法导论》笔记</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-10-26 13:30" pubdate>
          2021年10月26日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          8.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          42 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">《算法导论》笔记</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2022年8月2日 19:38
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><p><strong>重要特性</strong>  输入、输出、确定性、有限性</p>
<p><strong>算法描述</strong>  自然语言、流程图、伪代码、程序代码</p>
<p><strong>算法的复杂性</strong>  时间复杂性、空间复杂性</p>
<p><strong>算法的渐进性态</strong></p>
<p>$O(g(n))$ 上界</p>
<p>$Ω(g(n))$ 下界</p>
<p>$Θ(g(n))$ 确界</p>
<p>$logn &lt; n &lt; nlogn &lt; n^2 &lt; n^3 &lt;2^n$</p>
<p><strong>NP完全理论</strong>  能在多项式时间内求解的判定性问题称为P问题，在多项式时间能验证猜测解的正确性为NP问题</p>
<h1 id="递归与分治"><a href="#递归与分治" class="headerlink" title="递归与分治"></a>递归与分治</h1><h2 id="递归概念"><a href="#递归概念" class="headerlink" title="递归概念"></a>递归概念</h2><p><strong>递归定义</strong>  用函数自身定义的函数 GNU is Not Unix</p>
<p><strong>递归函数两个要素</strong>  边界条件与递归方程</p>
<p><strong>满足条件</strong>  可转化（可以转化为一个或者多个子问题，子问题的求解方法与原问题完全相同，只在规模上不同）、调用次数有限、有结束递归的条件来终止递归，并不是所有递归都可以转换</p>
<p><strong>何时使用递归</strong>  定义是递归的（斐波那契），数据结构是递归的（链表），问题的求解方法是递归的（汉诺塔，数的排列）</p>
<p><strong>递归算法转化为非递归算法</strong></p>
<ol>
<li><p>直接转化法：直接用循环结构的算法替代递归算法，不需要使用栈</p>
</li>
<li><p>用栈模拟系统的运行过程，通过分析只保存必须保存的信息，从而用非递归算法替代递归算法，需要使用栈</p>
</li>
</ol>
<h2 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Template&lt;class type&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Perm</span><span class="hljs-params">(Type list[], <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//递归地产生所有前缀是list[0:k-1],且后缀是list[k:m]的全排列的所有</span><br>	<span class="hljs-keyword">if</span> (k==m) &#123; <span class="hljs-comment">//只剩下一个元素</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++) cout&lt;&lt;list[i];<br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">//还有多个元素，递归产生后缀是list[k:m] 的全排列</span><br>	<span class="hljs-keyword">for</span>(i=k;i&lt;=m;i++) &#123;<br>		<span class="hljs-built_in">Swap</span>(list[k],list[i]);<br>    	<span class="hljs-built_in">Perm</span>(list,k+<span class="hljs-number">1</span>,m);<br>    	<span class="hljs-built_in">Swap</span>(list[k],list[i]); <span class="hljs-comment">//记得还原</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h2><p>对于数据n，最大加数不大于m的划分个数记作q(n,m)</p>
<script type="math/tex; mode=display">
q(n,m) = \left\{\begin{matrix}
1  & n = 1,m = 1\\
 q(n,n) &n<m \\
 1+q(n,n-1) &n = m \\
 q(n,m-1)+q(n-m,m) &n>m>1
\end{matrix}\right.</script><h2 id="分治概念"><a href="#分治概念" class="headerlink" title="分治概念"></a>分治概念</h2><p><strong>设计思想</strong>  将一个难以直接解决的大问题，分割成一些规模较小的子问题，这些子问题互相独立且与原问题相同，从而递归地解子问题，将各个子问题的解合并得到原问题的解</p>
<p><strong>适用问题</strong>  该问题可以分解为若干个规模较小的相同问题；该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题；该问题的规模缩小到一定的程度就可以容易地解决；利用该问题分解出的子问题的解可以合并为该问题的解</p>
<p><strong>求解过程</strong> 分解、求解、合并</p>
<p><strong>时间复杂性计算</strong>  扩展递归技术、递归树、主定理方法</p>
<p><strong><em>▲主定理方法</em></strong>  T(n)=aT(n/b)+f(n)，其中a≥1，b&gt;1为常数，该方程描述了算法的执行时间，算法将规模为n的问题分解成a个子问题，每个子问题的大小为n/b。比较两个式子大小即可</p>
<script type="math/tex; mode=display">
T(n) = aT(\frac{n}{b} ) + f(n) =\left\{\begin{matrix}
O(n^{log_{b}a } )  & n^{log_{b}a} > f(n)\\
O(n^{log_{b} a }log_2 n) & n^{log_{b}a} = f(n) \\
O(f(n)) & n^{log_{b}a} < f(n)
\end{matrix}\right.</script><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p><strong>问题描述</strong>  给定已按升序排好序的n个元素a[1:n]，现要在这n个元素中找出一特定元素x</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BinarySearch</span><span class="hljs-params">(Type a[ ], <span class="hljs-keyword">const</span> Type &amp;x,<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>;	<span class="hljs-keyword">int</span> right=n<span class="hljs-number">-1</span>;<br>	<span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>		<span class="hljs-keyword">int</span> middle=(left+right)/<span class="hljs-number">2</span>;<br>		<span class="hljs-keyword">if</span>(x==a[middle])<br>			<span class="hljs-keyword">return</span> middle;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&gt;a[middle])<br>			left=middle+<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">else</span><br>			right=middle<span class="hljs-number">-1</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<p>指针left在什么情况下会超过right?</p>
<p>Left指针向左移动, right指针向右移动，如果一直没有找到结果，那么这两个指针最终会重叠，指向同一个位置。 此时队列中只剩下一个元素。</p>
<p>此时，left=right； 因此middle=left=right；</p>
<p>如果这个元素满足x==a[middle]，程序结束 return middle；</p>
<p>否则如果x&gt;a[middle], left=middle+1后，left将位于right的右边；</p>
<p>否则如果x&lt;a[middle], right=middle-1后，right将位于left的左边</p>
<h2 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h2><p><strong>问题描述</strong>  XY是n位二进制整数，计算他们的乘积XY</p>
<script type="math/tex; mode=display">
\begin{array}
  {X}X=A2^{\frac{n}{2}}+B, Y=C2^{\frac{n}{2}}+D \\ 
  XY = AC2^n+(AD+BC)2^{\frac{n}{2} }+BD  \\
  =AC2^n+((A-B)(D-C)+AC+BD)2^{\frac{n}{2}}+BD \\
  T(n) = O(n^{log3}) =\left\{\begin{matrix}
O(1)  & n=1\\
3T(\frac{n}{2} ) + O(n) & n>1 \\
\end{matrix}\right.
\end{array}</script><h2 id="Strassen乘法"><a href="#Strassen乘法" class="headerlink" title="Strassen乘法"></a>Strassen乘法</h2><p><strong>问题描述</strong>  计算两个矩阵相乘的结果，分块矩阵计算</p>
<script type="math/tex; mode=display">
\begin{array}
  {X}
  T(n) = O(n^{3}) =\left\{\begin{matrix}
O(1)  & n=1\\
8T(\frac{n}{2} ) + O(n^2) & n>1 \\
\end{matrix}\right.
\end{array}</script><p><strong>解释</strong>  两个 n/2×n/2 的矩阵相加： 一行需要n/2次加法，共有n/2行，因此，两个矩阵相加的复杂度为 n/2×n/2=n^2/4，四次矩阵相加的复杂度为 O(n^2)</p>
<p><strong>改进算法</strong>  只需要七次乘法</p>
<h2 id="棋盘覆盖"><a href="#棋盘覆盖" class="headerlink" title="棋盘覆盖"></a>棋盘覆盖</h2><p><strong>问题描述</strong>  2^k阶的棋盘中只有一个方格残缺，要求用L型骨牌覆盖残缺棋盘上的所有方格且任何2个L型骨牌不得重叠覆盖，用递推求解时间复杂度</p>
<script type="math/tex; mode=display">
\begin{array}
  {X}
  T(k) = O(4^{k}) =\left\{\begin{matrix}
O(1)  & k=0\\
4T(k-1 ) + O(1) & k>0 \\
\end{matrix}\right.
\end{array}</script><p><strong>解释</strong>  测试哪个子棋盘残缺以及形成3个残缺子棋盘需要O(1) ，覆盖4个残缺子棋盘（ 2^(k-1)阶）需四次递归调用，共需时间4T(k-1)</p>
<h2 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h2><p><strong>问题描述</strong> 数组排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">temlplate  &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">type</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(Type a[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function">  </span>&#123;   <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>eft &lt; right) <span class="hljs-comment">//至少有2个元素</span><br>       &#123;  <br>       <span class="hljs-keyword">int</span> i = (left + right ) /<span class="hljs-number">2</span>; <span class="hljs-comment">//取中点</span><br>       <span class="hljs-built_in">MergeSort</span>(a, <span class="hljs-number">1</span>eft, i)；<br>       <span class="hljs-built_in">MergeSort</span>(a, i+<span class="hljs-number">1</span>, right)；<br>       <span class="hljs-built_in">Merge</span>(a, b, <span class="hljs-number">1</span>eft, i, right)；<span class="hljs-comment">//从a合并到数组b</span><br>       <span class="hljs-built_in">copy</span>(a, b, left, right);<span class="hljs-comment">//复制回数组a</span><br>     &#125;<br> &#125;    <br></code></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{array}
  {X}
  T(n) = O(nlogn) =\left\{\begin{matrix}
O(1)  & n=1\\
2T(\frac{n}{2} ) + O(n) & n>1 \\
\end{matrix}\right.
\end{array}</script><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>问题描述</strong> 数组排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSoft</span><span class="hljs-params">(Type a[], <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(p&lt;r) &#123;<br>        <span class="hljs-keyword">int</span> q=<span class="hljs-built_in">Partition</span>(a, p, r)<br>        <span class="hljs-comment">//找到q的位置</span><br>        <span class="hljs-comment">//同时确保该位置右边的比基准元素大，左边的比基准元素小</span><br>        <span class="hljs-built_in">QuickSort</span>(a, p, q<span class="hljs-number">-1</span>); <span class="hljs-comment">//对左半段排序</span><br>        <span class="hljs-built_in">QuickSoft</span>(a, q+<span class="hljs-number">1</span>, r); <span class="hljs-comment">//对右半段排序</span><br>        &#125;<br>     &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(Type a[],<span class="hljs-keyword">int</span> p , <span class="hljs-keyword">int</span> r )</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = p; j = r+<span class="hljs-number">1</span>;<br>    type x = a[p];<br>	<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123; <br>         <span class="hljs-keyword">while</span>(a[++i] &lt; x &amp;&amp; i &lt; r);<br>         <span class="hljs-keyword">while</span>(a[--j] &gt; x);<br>         <span class="hljs-keyword">if</span> (i &gt;= j) <span class="hljs-keyword">break</span>;<br>         <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>    &#125;<br>    <span class="hljs-built_in">swap</span>(a[p], a[j]);<br>    <span class="hljs-keyword">return</span> j;<br>&#125;<br><br><span class="hljs-comment">//随机选择基准点的快速排序</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">randomizedQuickSoft</span><span class="hljs-params">(Type a[], <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p&lt;r) &#123;<br>        <span class="hljs-keyword">int</span> q=<span class="hljs-built_in">randomizedPartition</span>(a, p, r);<br>        <span class="hljs-built_in">randomizedQuickSort</span>(a, p, q<span class="hljs-number">-1</span>); <span class="hljs-comment">//对左半段排序</span><br>        <span class="hljs-built_in">randomizedQuickSoft</span>(a, q+<span class="hljs-number">1</span>, r); <span class="hljs-comment">//对右半段排序</span><br>        &#125;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">randomizedPartition</span><span class="hljs-params">(Type a[], <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-built_in">random</span>(p, r);<br>    <span class="hljs-built_in">swap</span>(a[i], a[p]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Partition</span> (a,p,r);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<ol>
<li>步骤<ul>
<li>分解：以a[p]为基准元素将a[p:r]划分成3段a[p:q-1],a[q]和a[q+1:r]，使a[p:q-1]中任意一个元素小于等于a[q]，而a[q+1:r]中任何一个元素大于等于a[q]，下标q在划分过程中确定</li>
<li>递归求解：通过递归调用快速排序算法分别对a[p:q-1]和a[q+1:r]进行排序</li>
<li>合并</li>
</ul>
</li>
<li>最坏情况，已经排好，O(n^2)</li>
<li>最好情况，每次划分大小都是n/2，O(nlogn)</li>
</ol>
<p><img src="https://i.loli.net/2021/10/26/Gm4dM5kU1rN2K9Y.jpg" srcset="/img/loading.gif" lazyload style="zoom:67%;" /></p>
<h2 id="线性时间选择"><a href="#线性时间选择" class="headerlink" title="线性时间选择"></a>线性时间选择</h2><p><strong>问题描述</strong> </p>
<p>无序排列中求n个元素中第k小的元素（主要求中位数）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span><br><span class="hljs-function">Type <span class="hljs-title">RandomizedSelect</span> <span class="hljs-params">(a[], <span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p==r) <span class="hljs-keyword">return</span> a[p];<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-built_in">RandomizedPartition</span>(a, p, r), <span class="hljs-comment">//前面有</span><br>    j = i-p+l  <span class="hljs-comment">//统计前半部分元素个数j,  i为基准点</span><br>    <span class="hljs-keyword">if</span> ( k &lt;= j )<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">RandomizedSelect</span>(a, p, i, k);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">RandomizedSelect</span>(a, i+<span class="hljs-number">1</span>, r, k-j);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>解释</strong></p>
<p>根据随机产生的基准点，将元素分为2组，基准点包含在第1组中；如果k&lt;=j，则第k小元素落在a段，为a段的第k小元素；如果k&gt;j，则a段的所有元素都比第k小元素还要小，第k小元素落在b段，为b段中的第k-j小元素（-j的含义是去掉a段的元素总个数）</p>
<p>最坏情况，分成两个1和n-1的子问题，O(n^2)</p>
<p>最好情况，每次都产生n/2大小的子问题，O(n)</p>
<p><strong>基准点选择优化</strong></p>
<p>例如可以分成五个组，取每组中位数的中位数。设所有元素互不相同。在每一组中有2个元素小于本组的中位数，而n/5个中位数中又有(n-5)/10个小于基准x,因此，找出的基准x至少比3(n-5)/10个元素大。同理，基准x也至少比3(n-5)/10个元素小。当n≥75时，3(n-5)/10≥n/4所以按此基准划分所得的2个子数组的长度都至少缩短1/4。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Type <span class="hljs-title">Select</span><span class="hljs-params">(Type a[], <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (r-p&lt;<span class="hljs-number">75</span>) &#123;<br>        TO DO<span class="hljs-comment">//用某个简单排序算法对数组a[p:r]排序;</span><br>        <span class="hljs-keyword">return</span> a[p+k<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;=(r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">5</span>; i++ ) &#123;<br>        <span class="hljs-comment">//将a[p+5*i]至a[p+5*i+4]的第3小元素与a[p+i]交换位置;</span><br>        Type x = <span class="hljs-built_in">Select</span>(a, p, p+(r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">5</span>, (r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-built_in">Partition</span>(a,p,r, x),<br>        j=i-p+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (k&lt;=j) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Select</span>(a,p,i,k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">Select</span>(a,i+<span class="hljs-number">1</span>,r,k-j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>例题</strong></p>
<p>a=[2,6,9,1,4,10,20,6,22,11,10,9,4,3,7,16,11,8,2,5,4,1]</p>
<p>寻找第5小元素</p>
<p>(要求两个中位数选择较小的一个，支点放在第一个列表中)</p>
<p><strong>解答</strong></p>
<p>$n=22$，分组如下</p>
<p>[2,6,9,1,4] [10,20,6,22,11] [10,9,4,3,7] [16,11,8,2,5] [4,1]</p>
<p>中位数集合[4, 11, 7, 8, 4]，选择中位数的中位数为7作为支点</p>
<p>把支点放在第一个列表中</p>
<p>划分a[0:11]=[2, 6, 1, 4, 6, 4, 3, 2, 5, 4, 1, 7]<br>       a[12:21]=[9, 10, 20, 22, 11, 10, 9, 16, 11, 8] </p>
<p>对a[0:11]继续分组 [2,6,1,4,6],[4,3,2,5,4],[1]</p>
<p>中间元集合:[4,4,1]，中间元的中间元为4作为支点</p>
<p>把支点放在第一个列表中，划分：[2,1,4,4,3,2,4,1] [6,6,5]</p>
<p>对a[0:7]继续分组 [2,1,4,4,3],[2,4,1]</p>
<p>中间元集合:[3,2]，中间元的中间元为2作为支点</p>
<p>划分：[2,1,2,1] [4,4,3,4]</p>
<p>第一组小于5了</p>
<p>取第二组第5-4=1小的，也就是3</p>
</blockquote>
<h2 id="最接近点对"><a href="#最接近点对" class="headerlink" title="最接近点对"></a>最接近点对</h2><p><strong>一维情况</strong></p>
<p>1) 将S上的n个点分成大致相等的2个子集S1和S2<br>2) 分别求S1和S2中的最接近点对<br>3) 求一点在S1、另一点在S2中的最接近点对<br>4) 从上述三对点中找距离最近的一对</p>
<p><strong>二维情况</strong></p>
<ol>
<li>m为S中各点x间坐标的中位数，构造S1和S2    O(n)</li>
<li>递归求S1和S2的最小距离    2T(n/2)</li>
<li>求上述两个距离的最小值dm</li>
<li>设P1是S1中距垂直分割线l的距离在dm之内的所有点组成的集合；P2是S2中距分割线l的距离在d之内所有点组成的集合；将P1和P2中的点依其y坐标值排序；并设X和Y是相应的已排好序的点列    O(nlogn)</li>
<li>通过扫描X以及对于X中每个点检查Y中与其距离在dm之内的所有点(最多6个)可以完成合并；当X中的扫描指针逐次向上移动时，Y中的扫描指针可在宽为2dm的区间内移动；设dl是按这种扫描方式找到的点对间的最小距离；    O(n)</li>
<li>选择dm dl的最小值</li>
</ol>
<h2 id="循环赛日程表"><a href="#循环赛日程表" class="headerlink" title="循环赛日程表"></a>循环赛日程表</h2><p><strong>问题描述</strong>  设有n(n = 2^k)位选手参加网球循环赛，循环赛共进行n-1天，每位选手要与其他n-1位选手比赛一场，且每位选手每天必须比赛一场，不能轮空。</p>
<p><strong>发现规律</strong></p>
<p><img src="https://s2.loli.net/2021/12/07/y2EaPBCRoXkjQWO.png" srcset="/img/loading.gif" lazyload alt="" style="zoom: 67%;" /></p>
<p><img src="https://s2.loli.net/2021/12/06/U93fnXqQmOthd68.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>基本思想</strong>  基本思想是在对一个多阶段决策的问题，按照某一顺序，根据每一步所选决策的不同，会引起状态的转移，最后会在变化的状态中获取到一个决策序列。</p>
<p><strong>基本要素</strong></p>
<ol>
<li>最优子结构性质（分析问题是否满足最优性原理（用反证法）：①先假设由问题的最优解导出的子问题的解不是最优的；②再证明在这个假设下可构造出比原问题最优解更好的解，从而导致矛盾）</li>
<li>子问题重叠性质（子问题不相互独立，重复出现，只在第一次遇到时加以求解，并把答案保存起来，以后再遇到时不必重新求解）</li>
</ol>
<p><strong>算法步骤</strong></p>
<ol>
<li>分析最优解的性质，并刻画其结构特征；</li>
<li>递归地定义最优值；</li>
<li>以自底向上或自顶向下的方式计算出最优值；</li>
<li>根据递归计算最优值时得到的信息，从子问题的最优解逐步构造出整个问题的最优解。</li>
</ol>
<h2 id="矩阵连乘"><a href="#矩阵连乘" class="headerlink" title="矩阵连乘"></a>矩阵连乘</h2><p><strong>问题描述</strong>  每计算出一个元素，需要q次乘法，最终得到的矩阵是p×r矩阵，有p×r个元素，因此，计算C需要的乘法次数为q×p×r。每次要选择较小的q×p×r。给定n个矩阵｛A1,A2,…,An｝，其中Ai与Ai+1是可乘的，且i=1,2⋯,n-1,如何确定计算矩阵连乘积的计算次序，使得计算矩阵连乘的数乘次数最少。</p>
<script type="math/tex; mode=display">
m[i][j]=\left\{\begin{array}{cc}
0 & i=j \\
\min_{i\leq{k}<j} \{m[i][k]+m[k+1][j]+p_{i-1}p_kp_j\} & i<j
\end{array}\right.</script><p><strong>解释</strong>  矩阵连乘积从Ai到Aj定义为A[i:j]，A[i:j]最少的乘法次数定义为m[i,j]，最优断开位置k记为𝑠[i,j]=k，T(n)=O(n^3)</p>
<blockquote>
<p><strong>例题</strong></p>
<p>计算矩阵连乘积A[1:6]的最少数乘次数，其中各矩阵的维数分别为p=[30,35,15,5,10,20,25]</p>
<p><strong>解答</strong></p>
<script type="math/tex; mode=display">
\begin{matrix}
𝑚[1][2]=𝑚[1][1]+𝑚[2][2]+p_0p_1p_2=15750
\\𝑚[2][3]=𝑚[2][2]+𝑚[3][3]+p_1p_2p_3=2650
\\...
\\m[1][3]= \min \left\{\begin{matrix}
m[1][1]+m[2][3]+p_0p_1p_3=7875▲
\\m[1][2]+m[3][3]+p_0p_2p_3=18000
\end{matrix}\right.
\\s[1][3]=1
\\...
\\m[2][6]= \min \left\{\begin{matrix}
  m[2][2]+m[3][6]+p_1p_2p_6=0+5375+35*15*25=18500
\\m[2][3]+m[4][6]+p_1p_3p_6=2625+3500+35*5*25=10500▲
\\m[2][4]+m[5][6]+p_1p_4p_6=4375+5000+35*10*25=18125
\\m[2][5]+m[6][6]+p_1p_5p_6=7125+0+35*20*25=24625
\end{matrix}\right.
\\s[2][6]=3
\\...
\end{matrix}</script><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">m</th>
<th style="text-align:center">A1</th>
<th style="text-align:center">A2</th>
<th style="text-align:center">A3</th>
<th style="text-align:center">A4</th>
<th style="text-align:center">A5</th>
<th style="text-align:center">A6</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">15750</td>
<td style="text-align:center">7875</td>
<td style="text-align:center">9375</td>
<td style="text-align:center">11875</td>
<td style="text-align:center"><strong>15125</strong></td>
</tr>
<tr>
<td style="text-align:center">A2</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">2625</td>
<td style="text-align:center">4375</td>
<td style="text-align:center">7125</td>
<td style="text-align:center">10500</td>
</tr>
<tr>
<td style="text-align:center">A3</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">750</td>
<td style="text-align:center">2500</td>
<td style="text-align:center">5375</td>
</tr>
<tr>
<td style="text-align:center">A4</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1000</td>
<td style="text-align:center">3500</td>
</tr>
<tr>
<td style="text-align:center">A5</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">5000</td>
</tr>
<tr>
<td style="text-align:center">A6</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">s</th>
<th style="text-align:center">A1</th>
<th style="text-align:center">A2</th>
<th style="text-align:center">A3</th>
<th style="text-align:center">A4</th>
<th style="text-align:center">A5</th>
<th style="text-align:center">A6</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center"><strong>1</strong></td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center"><strong>3</strong></td>
</tr>
<tr>
<td style="text-align:center">A2</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">A3</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">A4</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">4</td>
<td style="text-align:center"><strong>5</strong></td>
</tr>
<tr>
<td style="text-align:center">A5</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">A6</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<p>从右上角的元素开始分割，从A3后面分为A[1,3]与A[4,6]，s[1,3]=1，从A1后面拆分，s[4,6]=5，从A5后面拆分，<strong>得到((A1(A2A3)((A4A5)A6)，次数最少是15125</strong></p>
</blockquote>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LCSLength</span></span><br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> *x, <span class="hljs-keyword">char</span> *y,<span class="hljs-keyword">int</span> c[][], <span class="hljs-keyword">int</span> b[][])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;m;i++) c[i][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;n;i++) c[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-comment">//m,n是X和Y的长度</span><br>            <span class="hljs-keyword">if</span> (x[i]==y[j]) &#123;<br>                c[i][j]=c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>                b[i][j]=<span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c[i<span class="hljs-number">-1</span>][j]&gt;=c[i][j<span class="hljs-number">-1</span>]) &#123;<br>                c[i][j]=c[i<span class="hljs-number">-1</span>][j];<br>                b[i][j]=<span class="hljs-number">2</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                c[i][j]=c[i][j<span class="hljs-number">-1</span>];<br>                b[i][j]=<span class="hljs-number">3</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LCS</span><span class="hljs-params">(i, j, X, b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span> || j==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (b[i,j]==<span class="hljs-string">&quot;1&quot;</span> ) &#123;<br>        <span class="hljs-built_in">LCS</span>(i<span class="hljs-number">-1</span>, j<span class="hljs-number">-1</span>, x, b);<br>        cout &lt;&lt;x[i];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b[i,j]==<span class="hljs-string">&quot;2&quot;</span> ) <br>       <span class="hljs-built_in">LCS</span>(i<span class="hljs-number">-1</span>, j, x, b);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">LCS</span>(i, j<span class="hljs-number">-1</span>, x, b);<br>&#125;   <span class="hljs-comment">//计算复杂性：O(m+n)</span><br><span class="hljs-comment">//LCS(i, j, X, b)实现根据b的内容打印出Xi与Yj的最长公共子序列。</span><br><span class="hljs-comment">//调用LCS(m,n,x,b) 可打印出序列X和Y的最长公共子序列。</span><br></code></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
c[i][j]=\left\{\begin{array}{cc}
0 & i=0, j=0 \\
c[i-1][j-1]+1 & i, j>0 ; x_{i}=y_{j} \\
\max \{c[i-1][j], c[i][j-1]\} & i, j>0 ; x_{i} \neq y_{j}
\end{array}\right.</script><p><strong>解释</strong>  c[i,j]记录序列Xi和Yj的最长公共子序列长度，b[i,j]可以记录是哪种类型。在c表中从最右下角的那个元素开始，看b表中对应位置的值，如果为1，则在c表中从当前位置往左上角走；如果为2，则在c表中从当前位置往正上方走；如果为3，则在c表中从当前位置沿水平方向往后退一位；依次类推，直到c表中箭头退到c[0，0]为止。</p>
<p><strong>补充</strong>  两个序列的最长公共子序列不唯一，不影响最长公共子序列的长度；但是可能会产生不一样的公共子序列，见例题</p>
<blockquote>
<p><strong>例题</strong></p>
<p>给定两个序列为X=ABCBDAB和Y=BDCABA，求最长公共子序列。</p>
<p><strong>解答</strong></p>
<script type="math/tex; mode=display">
\begin{matrix}i=1,X_1=\{A\}
\\j=1,Y_1=\{B\},𝑐[1][1]=\max⁡\{ 𝑐[0][1],𝑐[1][0]\}=0, b[1][1]=2 or 3
\\j=2,Y_2=\{BD\},𝑐[1][2]=\max⁡\{ 𝑐[0][2],𝑐[1][1]\}=0, b[1][2]=2
\\...
\\j=4,Y_4=\{BDCA\},𝑐[1][4]=c[0][3]+1=1, b[1][4]=1
\\...
\\i=7,X_7=\{ABCBDAB\}
\\j=6,Y_6=\{BDCABA\},\max⁡\{ 𝑐[6][6],𝑐[7][5]\}=4, b[7][6]=2 or 3
\end{matrix}</script><p><img src="https://i.loli.net/2021/11/03/AiVcQH3dqO6XTpa.png" srcset="/img/loading.gif" lazyload alt="c表与b表" style="zoom:50%;" /></p>
<p>斜线箭头尾部位置对应的元素为公共子序列元素（下标从1开始），也就是有BCBA（x[2346]与y[1356]）\BCAB（x[2367]与y[1345]）\BDAB（x[4567]与y[1245]）</p>
<p>PS: 对于C[1,1]=max{c[0,1],c[1,0]}={0,0}=0等情况，此时，b[1,1]=2或3都可以，不影响最终的结果。可能有多个答案。</p>
</blockquote>
<h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><p><strong>问题描述</strong> n个整数组成的序列，求该序列连续子段和的最大值（规定当所有<br>整数均为负整数时定义其最大子段和为0）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MaxSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> *a)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>, b=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (b&gt;<span class="hljs-number">0</span>) b+=a[i];<br>        <span class="hljs-keyword">else</span> b=a[i];<br>        <span class="hljs-keyword">if</span> (b&gt;sum) sum=b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
b[j]= \max\{b[j-1]+a[j],a[j]\}(1\leq j \leq n)</script><p><strong>解释</strong> b[j]为以a[1,j]之间的任一位置开始，以a[j]为结束的最大子段和（必须要到j才行）。从i开始，到j-1结束的子段和的最大值&lt;=0，从i开始到j结束的子段和的最大值应该为a[j]自身。从i开始，到j-1结束的子段和的最大值大于0，此时，将a[j]加上（不是因为如果a[j]小于零就不加了，b[j]的定义就是要加到j），所得到的值应该是从i开始，到j结束的子段和的最大值。 O(n)</p>
<blockquote>
<p><strong>例题</strong></p>
<p>a[1:6]=[-2,11,-4,13,-5,-2]</p>
<p><strong>解答</strong></p>
<script type="math/tex; mode=display">
\begin{matrix}
j=1,𝑏[1]=\max\{𝑏[0]+𝑎[1],𝑎[1]\}=-2,i=1
\\j=2,𝑏[2]=\max\{𝑏[1]+𝑎[2],𝑎[2]\}=11,i=2
\\j=3,𝑏[3]=\max\{𝑏[2]+𝑎[3],𝑎[3]\}=11-4=7,i=2
\\j=4,𝑏[4]=\max\{𝑏[3]+𝑎[4],𝑎[5]\}=7+13=20,i=2
\\j=5,𝑏[5]=\max\{𝑏[4]+𝑎[5],𝑎[5]\}=20-5=15,i=2
\\j=6,𝑏[6]=\max\{𝑏[5]+𝑎[6],𝑎[6]\}=15-2=13,i=2
\end{matrix}</script><p>比较各个$b[i]$，其中最大的就是最大子段和，也就是$b[4]=20$,$i=2$开始，$j=4$结束，也就是$[11,-4,13]$</p>
</blockquote>
<h2 id="凸多边形最优三角剖分"><a href="#凸多边形最优三角剖分" class="headerlink" title="凸多边形最优三角剖分"></a>凸多边形最优三角剖分</h2><p><strong>问题描述</strong>  给定一个凸多边形以及定义在由多边形的边和弦组成的三角形上的权函数$w$。求一个三角剖分，使得剖分中诸三角形上的权之和为最小。 </p>
<script type="math/tex; mode=display">
t[i][j]=\left\{\begin{array}{cc}
0 & i=j \\
\min_{i\leq{k}<j} \{t[i][k]+t[k+1][j]+w(v_{i-1}v_kv_j)\} & i<j
\end{array}\right.</script><p><strong>解释</strong></p>
<p>定义$t[i][j]$为凸子多边形的最优剖分对应权函数值， $s[i][j]$记录了$v_{i-1}$和$ v_j$一起构成三角形的第3个顶点$k$的位置，据此，用$O(n)$时间就可以构造出<br>最优三角剖分中的所有三角形。</p>
<p>计算最优值与矩阵连乘积相似。计算凸$n+1$多边形的最优值为$ t[1][n]$</p>
<blockquote>
<p><strong>例题</strong></p>
<p>（好难算啊不会考吧）</p>
<p><img src="https://s2.loli.net/2021/12/07/isJWTNkCPd4ORfS.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p>
<p><img src="https://s2.loli.net/2021/12/07/sTxqwMUX5JoyA3g.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p>
<p><img src="https://s2.loli.net/2021/12/07/ViKmFwAuHB3PQ27.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p>
<p><img src="https://s2.loli.net/2021/12/07/8d7TXheayMsRpr1.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p>
<p><img src="https://s2.loli.net/2021/12/07/PUfmEldrnXp9W8B.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p>
</blockquote>
<h2 id="图像压缩"><a href="#图像压缩" class="headerlink" title="图像压缩"></a>图像压缩</h2><p><strong>问题描述</strong>  数字化图像是的像素阵列。假定每个像素有一个0~255的灰度值，存储一个像素需8位。为了减少存储空间，采用变长模式，即不同像素用不同位数来存储。</p>
<ol>
<li>线性化：图片拉直，转换为$1×n^2$向量</li>
<li>分段：分成连续的$m$段，每段像素存储位数相同，每段最多含256个像素点</li>
<li>存放信息：第$i$段长度（8bit），第$i$段中像素存储位数（3bit）</li>
</ol>
<script type="math/tex; mode=display">
\begin{matrix}
s[i]=\min\limits_{1 \leq k \leq \min \{i,256\}}\{s[i-k]+k*bmax(i-k+1,i)  \}+11
\\bmax(i,j)=\max\limits_{i\leq k \leq j}\{a[k]\}
\end{matrix}</script><p><strong>解释</strong></p>
<p>假设$s[i]$是序列${p_1,p_2,…,p_i}$的最优解，$a[i]$是第i个像素点的位数。</p>
<ol>
<li>假设$p_i$自成一段，则$s[i]=s[i-1]$+保存$p_i$的代价</li>
<li>取$s[i]$为min时对应的元素个数为$k$，$s[i]=s[i-k]$+保存最后$k$个像素的代价</li>
<li>保存最后$k$个像素的代价=$k*max${$k$个灰度值二进制位数}+11</li>
</ol>
<blockquote>
<p><strong>例题</strong></p>
<p>求像素序列4，6，5，7，129，138，1的最优分段。</p>
<p><strong>解答</strong></p>
<script type="math/tex; mode=display">
\begin{matrix}
a=[3,3,3,3,8,8,1]
\\s[0]=0
\\s[1]=s[0]+1*\max \{3\} +11=14
\\s[2]= \min \left\{\begin{matrix}
s[0]+2* \max \{3,3\} + 11 = 17▲
\\s[1] + 1*\max \{3\} +11 =28
\end{matrix}\right.
\\...
\\s[7]= \min \left\{\begin{matrix}
s[0]+7* \max \{3,3,3,3,8,8,1\} + 11 = 67
\\s[1]+6* \max \{3,3,3,8,8,1\} + 11 = 73
\\...
\\s[4]+3* \max \{8,8,1\} + 11 = 58▲
\\...
\\s[6]+1* \max \{1\} + 11 = 62
\end{matrix}\right.
\end{matrix}</script><p>看s[7]=58，看58那一行是s[4]+3*max，前四个一起，后三个一起</p>
<p>看s[4]=23，看23那一行是s[0]+4*max，前四个就在一起，不再分</p>
<p>最后得到（4，6，5，7）（129，138，1）</p>
<p>ps每次计算比大小可以不加上11但是最后求$s$的时候别忘了加11</p>
</blockquote>
<h2 id="电路布线"><a href="#电路布线" class="headerlink" title="电路布线"></a>电路布线</h2><p><strong>问题描述</strong> 确定将哪些连线安排在第一层上，使得该层上有尽可能多的连线且不相交</p>
<script type="math/tex; mode=display">
\begin{matrix} 
i=1, \qquad Size(i,j) = \left\{\begin{matrix}
0 && j<\pi(1)
\\1 && j \geq \pi (1)
\end{matrix}\right.
\\
\\i>1,\qquad Size(i,j) = \left\{\begin{matrix}
Size(i-1,j) && j<\pi(i)
\\\max \{ Size(i-1,j),Size(i-1,\pi(i)-1)+1\} && j \geq \pi (i)
\end{matrix}\right.
\end{matrix}</script><p><strong>解释</strong>  MNS(i,j)表示上面序号小于i，连接到下面的序号都小于j的不相交的集合，最后要求MNS(n,n)。如果j<pi(i)，(i,pi(i)）不在MNS中，将i点删除没有影响。如果j>=pi(i)，如果（i,pi(i)）不在MNS中，将i点删除没有影响，就是size(i,j)=size(i-1,j)，如果（i,pi(i)）在MNS中，就是size(i,j)=size(i-1,pi(i)-1)+1</p>
<blockquote>
<p><strong>例题</strong></p>
<p>已知[(1 8)(2 7)(3 4)(4 2)(5 5)(6 1)(7 9)(8 3)(9 10)(10 6)]，求最大不相交情况</p>
<p><strong>解答</strong></p>
<p>i=1，pi(1)=8，j&gt;=<strong>8</strong>的size都为1</p>
<p>i=2，pi(2)=7，j&lt;<strong>7</strong>的size为size(<strong>1</strong>,j)，j&gt;=<strong>7</strong>的size为size(<strong>1</strong>,j)与size(<strong>1</strong>,<strong>6</strong>)+1=1的最大值</p>
<p>i=3，pi(3)=4，j&lt;<strong>4</strong>的size为size(<strong>2</strong>,j)，j&gt;=<strong>4</strong>的size为size(<strong>2</strong>,j)与size(<strong>2</strong>,<strong>3</strong>)+1=1的最大值</p>
<p>…</p>
<p><img src="https://s2.loli.net/2021/12/07/k9Gt8KfjJzgrnBc.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p>
<p>最后size(10,10)=4，最多可以有四条不相交。</p>
<p>蓝色是算法选择的路径（向上优先，也可以用向左优先，答案都是四个，但值会有一点不同）。在斜角值改变时可以取得所求的子集。答案也就是[(3 4)(5 5)(7 9)(9 10)]，[(4  2)(5 5)(7 9)(9 10)]</p>
</blockquote>
<h2 id="流水作业调度"><a href="#流水作业调度" class="headerlink" title="流水作业调度"></a>流水作业调度</h2><p><strong>问题描述</strong>   n个作业要在两台机器M1和M2上进行加工。每个作业加工的顺序都是先在M1上加工，然后在M2加工。M1和M2加工作业i所需的时间分别为ai 和bi。确定n个作业的最优加工顺序，使得加工完成所需的时间最少。</p>
<p><strong>算法</strong></p>
<ol>
<li>N1集合存放ai&lt;bi的作业，N2存放ai≥bi的作业</li>
<li>N1中作业按照ai升序排序，N2中作业按照bi降序排序</li>
<li>N1连接N2，计算时间</li>
</ol>
<blockquote>
<p><strong>例题</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">任务</th>
<th style="text-align:center">J1</th>
<th style="text-align:center">J2</th>
<th style="text-align:center">J3</th>
<th style="text-align:center">J4</th>
<th style="text-align:center">J5</th>
<th style="text-align:center">J6</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">工序1</td>
<td style="text-align:center">30</td>
<td style="text-align:center">120</td>
<td style="text-align:center">50</td>
<td style="text-align:center">20</td>
<td style="text-align:center">90</td>
<td style="text-align:center">110</td>
</tr>
<tr>
<td style="text-align:center">工序2</td>
<td style="text-align:center">80</td>
<td style="text-align:center">100</td>
<td style="text-align:center">90</td>
<td style="text-align:center">60</td>
<td style="text-align:center">30</td>
<td style="text-align:center">10</td>
</tr>
</tbody>
</table>
</div>
<p><strong>解答</strong></p>
<ol>
<li><p>分集合  {1,3,4}{2,5,6}</p>
</li>
<li><p>排序  {4,1,3}{2,5,6}</p>
</li>
<li><p>合并与计算时间</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">任务</th>
<th style="text-align:center">J4</th>
<th style="text-align:center">J1</th>
<th style="text-align:center">J3</th>
<th style="text-align:center">J2</th>
<th style="text-align:center">J5</th>
<th style="text-align:center">J6</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M1结束</td>
<td style="text-align:center">20</td>
<td style="text-align:center">50×</td>
<td style="text-align:center">100×</td>
<td style="text-align:center">220×</td>
<td style="text-align:center">310×</td>
<td style="text-align:center"><strong>420↓</strong></td>
</tr>
<tr>
<td style="text-align:center">M2开始</td>
<td style="text-align:center">20</td>
<td style="text-align:center">60</td>
<td style="text-align:center">140</td>
<td style="text-align:center">230</td>
<td style="text-align:center">330</td>
<td style="text-align:center">420</td>
</tr>
<tr>
<td style="text-align:center">M2结束</td>
<td style="text-align:center"><strong>80↗</strong></td>
<td style="text-align:center"><strong>160↗</strong></td>
<td style="text-align:center"><strong>250↗</strong></td>
<td style="text-align:center"><strong>350↗</strong></td>
<td style="text-align:center">380×</td>
<td style="text-align:center"><strong>430</strong></td>
</tr>
</tbody>
</table>
</div>
<p>ps：第k个任务M2开始的时间要取第k个任务M1结束的时间和第k-1个任务M2结束的时间的较大值。</p>
</blockquote>
<h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><p><strong>问题描述</strong>  给定n种物品和一个背包。物品i的重量是wi，其价值为vi，背包的容量为c。问如何选择装入背包中的物品使得装入物品的总价值最大？</p>
<script type="math/tex; mode=display">
\begin{matrix} 
m(i,j) = \left\{\begin{matrix}
m(i+1,j) && 0 \leq j<w_i
\\ \max \{ m(i+1,j),m(i+1,j-w_i)+v_i\} && j \geq w_i
\end{matrix}\right.
\\
\\m(n,j) = \left\{\begin{matrix}
0 && 0 \leq j<w_n
\\ v_n && j \geq w_n
\end{matrix}\right.
\end{matrix}</script><p><strong>解释</strong>  m[i,j]表示可选择物品i, i+1, …, n时，背包容量为j装入的最大价值</p>
<blockquote>
<p><strong>例题</strong></p>
<p>n=5,c=10,W={2,2,6,5,4},V={6,3,5,4,6}</p>
<p><strong>解答</strong></p>
<p>i=5时，j<4时，装不进去，为0，j>=4时，能把w5=4装进去，为v5=6</p>
<p>i=4时，若j<5，则w4=5无法放入，m(4,j)=m(5,j)，j>=5时，比较m(5,j)与m(5,j-5)+4的最大值（可以看作先直接把m(5,j)往上复制一行，j&gt;=5时再比较更新即可，后面同理）</p>
<p>i=3时，若j<6，则w4=6无法放入，m(3,j)=m(4,j)，j>=6时，比较m(4,j)与m(4,j-6)+5的最大值</p>
<p>… 最后结果如下图</p>
<p><img src="https://i.loli.net/2021/11/13/Gn7oYtlkrdaIzhC.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />当</p>
<p>从m(1,10)开始看起，m(1,10)!=m(2,10),说明1肯定被放入了背包中。1的重量为2，剩下的容量为10-2=8；</p>
<p>从m(2,8)开始看起，m(2,8)!=m(3,8),说明2肯定被放入了背包中。2的重量为2，剩下的容量为8-2=6；</p>
<p>从m(3,6)开始看起，m(3,6)=m(4,6),说明3肯定没有放入背包中。继续m(4,6)=m(5,6),说明4肯定没有放入背包中。</p>
<p>当i=5时，看剩余的容量，如果满足5号物品的重量，则5肯定放入。否则，5无法放入。此例，容量为6，5号物品重量为4，5号物品放入。</p>
<p>最后得到放入的五件物品状态为<strong>(1,1,0,0,1)</strong></p>
</blockquote>
<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><strong>思想</strong>  在贪婪算法中采用逐步构造最优解的方法。在每个阶段，都作出一个看上去最优的决策。它并不一定对所有问题都成功，因为不从整体最优加以考虑，贪心解法可能不是全局最优解，但是对某些问题特别简单、有效。</p>
<p><strong>基本要素</strong></p>
<ol>
<li><strong>最优子结构性质</strong>  问题的最优解包含其子问题的最优解</li>
<li><strong>贪心选择性质</strong>  问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到，当前的选择和子问题的解无关，只和以往做出的选择有关</li>
</ol>
<h2 id="活动安排"><a href="#活动安排" class="headerlink" title="活动安排"></a>活动安排</h2><p><strong>问题描述</strong>  在活动集合中选择最大的相容活动子集合</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Type&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GreedySelector</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,Type s[],Type f[],<span class="hljs-keyword">bool</span> A[] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">//s存开始时间，f存结束时间，且按结束时间非减续排列；</span></span></span><br><span class="hljs-params"><span class="hljs-function">    A[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>; <span class="hljs-comment">//排在第1个的活动最先结束，直接放入A；</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-comment">//从第2个活动开始检测</span></span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-keyword">if</span> (s[i]&gt;=f[j]) &#123; A[i]=<span class="hljs-literal">true</span>; j=i; &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-comment">//如果相容，放入A</span></span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-keyword">else</span> A[i]=<span class="hljs-literal">false</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure>
<p><strong>证明贪心选择性质</strong></p>
<ol>
<li>假设问题有一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始，做了贪心选择后，原问题简化为规模更小的类似子问题。</li>
<li>运用数学归纳法证明，每一步贪心选择→问题的整体最优解</li>
</ol>
<blockquote>
<p><strong>例题</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody>
<tr>
<td>start</td>
<td style="text-align:center">5</td>
<td>0</td>
<td>3</td>
<td>5</td>
<td>3</td>
<td>1</td>
<td style="text-align:center">8</td>
<td style="text-align:center">6</td>
<td style="text-align:center">8</td>
<td>12</td>
<td>2</td>
</tr>
<tr>
<td>stop</td>
<td style="text-align:center">9</td>
<td>6</td>
<td>5</td>
<td>7</td>
<td>8</td>
<td>4</td>
<td style="text-align:center">11</td>
<td style="text-align:center">10</td>
<td style="text-align:center">12</td>
<td>14</td>
<td>13</td>
</tr>
</tbody>
</table>
</div>
<p><strong>解答</strong></p>
<p>待安排的11个活动按结束时间的非减序排列</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">6</th>
<th>3</th>
<th>2</th>
<th>4</th>
<th>5</th>
<th>1</th>
<th style="text-align:center">8</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th>11</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>start</td>
<td style="text-align:center"><strong>1</strong></td>
<td>3</td>
<td>0</td>
<td><strong>5</strong></td>
<td>3</td>
<td>5</td>
<td style="text-align:center">6</td>
<td style="text-align:center"><strong>8</strong></td>
<td style="text-align:center">8</td>
<td>2</td>
<td><strong>12</strong></td>
</tr>
<tr>
<td>stop</td>
<td style="text-align:center"><strong>4</strong></td>
<td>5</td>
<td>6</td>
<td><strong>7</strong></td>
<td>8</td>
<td>9</td>
<td style="text-align:center">10</td>
<td style="text-align:center"><strong>11</strong></td>
<td style="text-align:center">12</td>
<td>13</td>
<td><strong>14</strong></td>
</tr>
</tbody>
</table>
</div>
<p>最后为(6,4,7,10)</p>
</blockquote>
<h2 id="0-1背包-1"><a href="#0-1背包-1" class="headerlink" title="0-1背包"></a>0-1背包</h2><p><strong>几种贪心策略</strong>（但是都不能保证得到最优解）</p>
<ol>
<li>选择可以装入背包的价值最大的物品</li>
<li>选择可装入背包的重量最小的物品</li>
<li>选择可装入背包的vi/wi最大的物品（一般用来做回溯法或者分支限界的限界函数）</li>
</ol>
<h2 id="最优装载"><a href="#最优装载" class="headerlink" title="最优装载"></a>最优装载</h2><p><strong>策略</strong>  重量最轻的先装  T(n)=O(nlogn)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Loading</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x[], Type w[], Type c, <span class="hljs-keyword">int</span> n )</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> *t = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [n+<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">Sort</span>(w, t, n) ; <span class="hljs-comment">//按货箱重量排序/</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; = n; i ++)<br>    x[i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;= n &amp;&amp; w[t[i]] &lt;= c; i++) &#123;<br>        [t[i]] = <span class="hljs-number">1</span>;<br>        c-= w[t[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>例题</strong></p>
<p>(100,200,50,90,150,50,20,80), c=400</p>
<p><strong>解答</strong></p>
<p>所考察货箱的次序为73684152，考察到5时装不下了</p>
<p>(<strong>100</strong>,200,<strong>50</strong>,<strong>90</strong>,150,<strong>50</strong>,<strong>20</strong>,<strong>80</strong>) 装了390</p>
<p>(1,0,1,1,0,1,1,1)</p>
</blockquote>
<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p><strong>前缀码</strong>  对每一个字符规定一个0,1串作为其代码，并要求任一字符的代码都不是其它字符代码的前缀，这种编码称为前缀码。</p>
<p><strong>问题描述</strong>  找到使平均码长达到最小的前缀码编码方案</p>
<p><strong>策略</strong>  频率小的字符，深度大。队列Q以f(c)为键值存放二叉树各结点，通过贪心选择，将最小频率的两个二叉树合并，然后将新树（频率为上述两个二叉树频率之和）插入Q中。   T(n)=O(nlogn)</p>
<p><strong>证明贪心选择性质</strong></p>
<p>设x和y是字符集C中具有最小频率的两个字符，证明存在C的最优前缀码，使x和y具有最长、相同的码长且仅最后一位编码不同。设二叉树T表示C的任意一个最优前缀码方案。只要证明可以对T做适当修改后，得到一棵新的二叉树T’， 新树中，x和y是最深叶子且为兄弟。同时，新树也是C的最优前缀码方案。</p>
<p><strong>证明最优子结构性质</strong></p>
<p>设T表示C的一个最优前缀码方案。x和y是树T中的叶子节点且为兄弟。z是它们的父亲。若将z看做是具有频率f(z)=f(x)+f(y)的字符，则证明树T’=T-{x,y}表示字符集C’=C-{x,y} U {z}的一个最优前缀码即可。</p>
<blockquote>
<p><strong>例题</strong></p>
<p>设在1000个字母的文章中各字母出现的频率为a:83, b:14,  c:28,  d:38,  e:131,  f:29,  g:20,  h:53……，求最优编码。</p>
<p><strong>解答</strong></p>
<p><img src="https://i.loli.net/2021/11/14/5kI9jcio2xabpgC.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" /></p>
<p>ps:注意兄弟节点左小右大（按题目规定）</p>
</blockquote>
<h2 id="单源最短路径-dijksta"><a href="#单源最短路径-dijksta" class="headerlink" title="单源最短路径(dijksta)"></a>单源最短路径(dijksta)</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1q4411M7r9">dijksta视频演示</a></p>
<blockquote>
<p><strong>例题</strong></p>
<p><img src="https://i.loli.net/2021/11/14/VuRe1vE9fZ6tKcS.png" srcset="/img/loading.gif" lazyload  style="zoom: 33%;" /></p>
<p><strong>解答</strong></p>
<p><img src="https://i.loli.net/2021/11/16/81LgIlVw5zusOx9.png" srcset="/img/loading.gif" lazyload style="zoom:25%;" /></p>
<p><img src="https://i.loli.net/2021/11/14/RuqJGtPOHmzlV6n.png" srcset="/img/loading.gif" lazyload style="zoom: 25%;" /></p>
</blockquote>
<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>特点</strong>  深度优先搜索策略、算法框架是解空间（子集树与排列树）、在搜索的时候要避免遗漏，同时要高效。（具有限界函数的深度优先生成法称为回溯法）</p>
<p><strong>解空间</strong>  子集树（0-1，装载，子集和）与排列树（旅行商，m着色，n后）</p>
<p><strong>基本元素</strong>  活结点（自身已生成但其儿子还没有全部生成），拓展结点（正在产生儿子的结点），死结点（不满足约束或者所有儿子已经产生的结点）</p>
<p><strong>剪枝</strong>  用约束函数在扩展结点处剪去不满足约束的子树（左剪枝），用限界函数剪去得不到最优解的子树（右剪枝）</p>
<p><strong>终止条件</strong>  找到所有的解，解空间中没有活结点为止</p>
<h2 id="装载问题"><a href="#装载问题" class="headerlink" title="装载问题"></a>装载问题</h2><p><strong>问题描述</strong>   n个集装箱要装到2艘载重量分别为c1,c2的货轮，其中集装箱 i的重量为wi。要求找到装载方案将这n个货箱装上这2艘轮船</p>
<p><strong>解释</strong>  若装载问题有解, 采用如下策略可得一个最优装载方案：将第一艘轮船尽可能装满，将剩余的货箱装到第二艘轮船上。将第一艘船尽可能装满类似0-1背包问题</p>
<blockquote>
<p><strong>例题</strong></p>
<p>n=4,c1=12,W={8,6,2,3}</p>
<p><strong>解答</strong></p>
<p><img src="https://i.loli.net/2021/11/14/zurCOpm69MXy3Hk.png" srcset="/img/loading.gif" lazyload  style="zoom: 67%;" /></p>
</blockquote>
<h2 id="0-1背包-2"><a href="#0-1背包-2" class="headerlink" title="0-1背包"></a>0-1背包</h2><p><strong>解释</strong>  子集树。只要左儿子节点是一个可行结点，搜索就进入左子树（不超过背包重量）（约束剪枝）。在右子树中有可能包含最优解是才进入右子树搜索，否则将右子树剪去（利用单价贪心求解价值上限）（限界剪枝）。$cw$是背包当前重量，$M-cw$是背包剩余的空间，$cp$是当前总收益，$rp$是贪心算法剩余的物品收益，$bestw$记录当前最优价值，也就是判断$bp=cp+rp&gt;bestw$是右节点的限界函数。（此外，回溯法解0-1背包的前置条件是物品已按$p_i/w_i$非增次序排序）</p>
<blockquote>
<p><strong>例题</strong></p>
<p>M=110</p>
<p>w=(1,11,21,23,33,43,45,55)，v=(11,21,31,33,43,53,55,65)</p>
<p><strong>解答</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:center">1</td>
<td style="text-align:center">11</td>
<td style="text-align:center">21</td>
<td style="text-align:center">23</td>
<td style="text-align:center">33</td>
<td style="text-align:center">43</td>
<td style="text-align:center">45</td>
<td style="text-align:center">55</td>
</tr>
<tr>
<td style="text-align:center">v</td>
<td style="text-align:center">11</td>
<td style="text-align:center">21</td>
<td style="text-align:center">31</td>
<td style="text-align:center">33</td>
<td style="text-align:center">43</td>
<td style="text-align:center">53</td>
<td style="text-align:center">55</td>
<td style="text-align:center">65</td>
</tr>
<tr>
<td style="text-align:center">v/w</td>
<td style="text-align:center">11</td>
<td style="text-align:center">1.9</td>
<td style="text-align:center">1.48</td>
<td style="text-align:center">1.43</td>
<td style="text-align:center">1.3</td>
<td style="text-align:center">1.23</td>
<td style="text-align:center">1.22</td>
<td style="text-align:center">1.18</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://i.loli.net/2021/11/14/7TLS4elkFUYRHOu.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p>
<p>最优解为<strong>(1,1,1,0,1,1,0,0)</strong></p>
</blockquote>
<h2 id="n后问题"><a href="#n后问题" class="headerlink" title="n后问题"></a>n后问题</h2><p><strong>问题描述</strong>   皇后问题要求在一个n×n的棋盘上放置n个皇后，使得它们彼此不受”攻击”。n皇后问题要求寻找在棋盘上放置这n个皇后的方案，使得它们中任何两个都不在同一行、同一列或同一斜线上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nQueen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    Queen X；<br>    <span class="hljs-comment">//初始化X    </span><br>    X.n=n；<span class="hljs-comment">//皇后个数</span><br>    X.sum=<span class="hljs-number">0</span>；<br>    <span class="hljs-keyword">int</span>*p=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [n+<span class="hljs-number">1</span>]；<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>；i&lt;=n；i++) p[i]= <span class="hljs-number">0</span>；<br>    X.x=p；<br>    X.<span class="hljs-built_in">Backtrack</span>(<span class="hljs-number">1</span>)；<br>    <span class="hljs-keyword">delete</span> [] p；<br>    returnX. sum;<br>&#125;<br><br><span class="hljs-keyword">bool</span> Queen:: <span class="hljs-built_in">Place</span>(<span class="hljs-keyword">int</span> k) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; k; j++)<br>      <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">abs</span>(k-j) == <span class="hljs-built_in">abs</span>(x[j] - x[k])) <br>        ||(x[j] == x[k] ))<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br> <br><span class="hljs-keyword">void</span> Queen:: <span class="hljs-built_in">Backtrack</span>(<span class="hljs-keyword">int</span> t) &#123;<br>    <span class="hljs-keyword">if</span> (t &gt; n) <br>        sum++;<br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>         x[t] = i;<br>         <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Place</span>(t)) <br>             <span class="hljs-built_in">Backtrack</span>(t+<span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>解释</strong>  (x1, …, xn) , x[i]表示皇后i放在棋盘的第i行的第x[i]列，解空间是排列树。abs(i-j)≠abs(x[i] – x[j]))是约束函数（不在同一列已经实现）。如下图是4皇后的一个解。</p>
<p><img src="https://i.loli.net/2021/11/14/8KqMfCEVO9LyBxs.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" /></p>
<h2 id="m着色"><a href="#m着色" class="headerlink" title="m着色"></a>m着色</h2><p><strong>解释</strong>  n元组(x0,x1,…,xn-1)表示图G的m-着色判定问题的解。对所有i和j，若邻接矩阵a[i，j]=1，则xi≠xj（约束条件）</p>
<blockquote>
<p><strong>例题</strong></p>
<p>使用回溯算法来求解图的m(m=3)着色问题的如下图实例。<br>(1) 给出解向量的形式，指出解空间树的类型。<br>(2) 描述搜索过程。<br>(3) 画出找到一个解所生成的部分搜索树，并给出这个解。</p>
<p><img src="https://i.loli.net/2021/11/14/uSJZqLQAlK3TedO.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" /></p>
<p><strong>解答</strong></p>
<p>X=(x0,x1,x2,x3,x4)</p>
<p><img src="https://i.loli.net/2021/11/14/usNAxhWT4jkSvbQ.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" /></p>
<p><strong>X=(1,2,3,2,1)</strong></p>
</blockquote>
<h2 id="旅行售货员"><a href="#旅行售货员" class="headerlink" title="旅行售货员"></a>旅行售货员</h2><h2 id="子集和"><a href="#子集和" class="headerlink" title="子集和"></a>子集和</h2><p><strong>问题描述</strong>  给出n个正实数集合与正整数M，找到元素之和为M的子集</p>
<blockquote>
<p><strong>例题</strong></p>
<p>设有n=6个正数的集合{5,10,12,13,15,18}和整数M=30，求W的所有元素之和为M的子集</p>
<p><strong>解答</strong></p>
<p><img src="https://i.loli.net/2021/11/14/ioq9NwWbhaYLnpT.png" srcset="/img/loading.gif" lazyload style="zoom: 50%;" /></p>
<p>最后一步，5，6两个物品全要为31，所以不要前四个物品的右子树肯定不需要考虑了。</p>
</blockquote>
<h1 id="分支限界"><a href="#分支限界" class="headerlink" title="分支限界"></a>分支限界</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p><strong>解空间</strong>  子集树（单源最短路径问题）与排列树（售货商）</p>
<p><strong>搜索方式</strong>  广度优先或最小耗费优先</p>
<p><strong>适用问题</strong>  存在性问题（找出满足约束条件的一个解）与最优化问题（在满足约束条件的解中找出在某种意义下的最优解） </p>
<p><strong>活结点表（其实叫队列更好一点）</strong></p>
<ul>
<li>每一个活结点只有一次机会成为扩展结点</li>
<li>活结点一旦成为扩展结点，一次性产生其所有儿子结点（导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中）</li>
<li>从活结点表中取出下一结点成为当前扩展结点，并重复结点扩展过程</li>
<li>直到找到所需的解或活结点表为空时为止</li>
</ul>
<p><strong>选择扩展结点的两种常用方法</strong>  队列式（先进先出）、优先队列式（按照耗费/收益优先级选取下一个结点作为当前拓展结点）</p>
<h2 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h2><p>子集树</p>
<p>剪枝的原则：在扩展顶点i时，如果从当前扩展结点i到j有边可达，且从源出发途经i再到j的所对应路径长度小于当前最优路径长度，则将该顶点作为活结点插入到活结点优先队列中</p>
<blockquote>
<p><strong>例题</strong></p>
<p><img src="https://i.loli.net/2021/11/16/wrZ41YiqExp6QSc.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" /></p>
<p><strong>解答</strong></p>
<ol>
<li><p>队列法</p>
<p><img src="https://i.loli.net/2021/11/16/bjfoQFy5YwlKaDS.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p>
</li>
<li><p>优先队列法（dist短的优先）</p>
</li>
</ol>
<p>结果</p>
<p><strong>dist=(10,30,60,16,50)</strong></p>
<p><strong>prev=(0,0,5,1,2)</strong></p>
</blockquote>
<h2 id="装载问题-1"><a href="#装载问题-1" class="headerlink" title="装载问题"></a>装载问题</h2><p>子集树</p>
<p>约束函数：已装容量与c1容量</p>
<p>限界函数：un=已经装载的重量ew+剩余重量r</p>
<blockquote>
<p><strong>例题</strong></p>
<p>n=4,c_1=12,W={8,6,3,2}</p>
<p><strong>解答</strong></p>
<p>优先队列法（un大的先拓展）</p>
<p>叶子结点成为扩展结点，得到一个最优解</p>
<p><img src="https://i.loli.net/2021/11/16/X4e2TVIv6z8GZsO.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />1q</p>
<p>解为(1,0,1,0)</p>
</blockquote>
<h2 id="0-1背包-3"><a href="#0-1背包-3" class="headerlink" title="0-1背包"></a>0-1背包</h2><blockquote>
<p><strong>例题</strong></p>
<p>n=3, w=[20,15,15], v=[45,25,25], c= 30</p>
<p><strong>解答</strong></p>
<ol>
<li><p>队列法</p>
<p><img src="https://i.loli.net/2021/11/14/o8DeUcu1SzGlpP6.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p>
</li>
<li><p>优先队列法（价值大的先拓展）</p>
<p><img src="https://i.loli.net/2021/11/16/okxtwCMfvdA1SsO.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p>
</li>
</ol>
<p>取(0,1,1)</p>
</blockquote>
<h2 id="最大团"><a href="#最大团" class="headerlink" title="最大团"></a>最大团</h2><p>完全子图（图中所有点任意连线都在原图中）</p>
<p>团（最大完全子图）</p>
<p>空子图（图中所有点任意连线不在原图中）</p>
<p>最大独立集（最大空子图）</p>
<p>补图（原图的完全图-原图，点不变）</p>
<p>有：若U是G的一个最大团，则U是G的补图G‘的一个最大独立集</p>
<p><img src="https://i.loli.net/2021/11/16/PK1ROEXvV3mJlcY.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" /></p>
<p>约束条件：是否是团（该顶点与当前团中其它顶点之间是否有边相连）</p>
<p>限界函数：当前团尺寸cn+剩余顶点数目r≤当前已求出最大尺寸bestn</p>
<p>优先级：un=cn+r</p>
<p>终止条件：遇到子集树中的一个叶结点（即n+1层结点）成为当前扩展结点</p>
<blockquote>
<p><strong>例题</strong></p>
<p><img src="https://i.loli.net/2021/11/16/ZKs1IP4xDRMmgbO.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><strong>解答</strong></p>
<p>优先队列法（un大的先拓展）</p>
<p><img src="https://i.loli.net/2021/11/16/PMr6sCnxNp7hkGo.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" /></p>
<p>一个可行结果为(1，1，1，0)</p>
</blockquote>
<h2 id="回溯与分支限界对比"><a href="#回溯与分支限界对比" class="headerlink" title="回溯与分支限界对比"></a>回溯与分支限界对比</h2><p><img src="https://i.loli.net/2021/11/16/QEZtAoMVafKiuY4.png" srcset="/img/loading.gif" lazyload alt="回溯与分支限界对比" style="zoom:67%;" /></p>
<script type="text/javascript">(function (document) {
    [].forEach.call(document.getElementsByClassName('fold'), function(panel) {
        panel.getElementsByClassName('fold-title')[0].onclick = function() {
            panel.classList.toggle("collapsed");
            panel.classList.toggle("expanded");
        }
    });
})(document);</script>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/CUMT%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="category-chain-item">CUMT课程笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
        <a href="/tags/%E5%88%86%E6%B2%BB/" class="print-no-link">#分治</a>
      
        <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="print-no-link">#动态规划</a>
      
        <a href="/tags/%E8%B4%AA%E5%BF%83/" class="print-no-link">#贪心</a>
      
        <a href="/tags/%E5%9B%9E%E6%BA%AF/" class="print-no-link">#回溯</a>
      
        <a href="/tags/%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C/" class="print-no-link">#分支限界</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>《算法导论》笔记</div>
      <div>https://junyaohu.github.io/2021/10/26/《算法导论》笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>胡椒</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年10月26日 13:30</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2022年8月2日 19:38</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/11/14/%E3%80%8A%E5%AE%9E%E7%94%A8%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95-2021%E7%A7%8B%E3%80%8B%E7%BB%93%E8%AF%BE%E8%80%83%E8%AF%95%E5%B0%8F%E7%BB%93/" title="《实用优化算法-2021秋》课程小结">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">《实用优化算法-2021秋》课程小结</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/12/23/cpp-practice-exam-2020-2021-1/" title="中国矿业大学2020-2021-1高级语言程序设计实验期末考题">
                        <span class="hidden-mobile">中国矿业大学2020-2021-1高级语言程序设计实验期末考题</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="twikoo"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/twikoo/1.6.8/twikoo.all.min.js', function() {
        var options = Object.assign(
          {"envId":"https://blog-comment-h866w5ycd-junyaohu.vercel.app/","region":"ap-shanghai","path":"window.location.pathname"},
          {
            el: '#twikoo',
            path: 'window.location.pathname',
            onCommentLoaded: function() {
              Fluid.utils.listenDOMLoaded(function() {
                var imgSelector = '#twikoo .tk-content img:not(.tk-owo-emotion)';
                Fluid.plugins.imageCaption(imgSelector);
                Fluid.plugins.fancyBox(imgSelector);
              });
            }
          }
        )
        twikoo.init(options)
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
