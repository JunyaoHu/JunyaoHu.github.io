<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>糖尿病遗传风险检测挑战赛 - Coggle 30 Days of ML（22年7月）</title>
    <link href="/2022/06/26/30days-of-ml-202207/"/>
    <url>/2022/06/26/30days-of-ml-202207/</url>
    
    <content type="html"><![CDATA[<h1 id="任务1：报名比赛"><a href="#任务1：报名比赛" class="headerlink" title="任务1：报名比赛"></a>任务1：报名比赛</h1><ul><li><p>步骤1：报名比赛<a href="http://challenge.xfyun.cn/topic/info?type=diabetes&amp;ch=ds22-dw-zmt05">http://challenge.xfyun.cn/topic/info?type=diabetes&amp;ch=ds22-dw-zmt05</a></p><p><img src="https://s2.loli.net/2022/07/09/alE4OAZnuXYQwW5.png" alt="报名后的个人中心页面" style="zoom: 33%;" /></p></li><li><p>步骤2：下载比赛数据（点击比赛页面的赛题数据）</p><p><img src="https://s2.loli.net/2022/07/09/zcvp6fDbYwFn9Ml.png" alt="赛题数据下载" style="zoom:50%;" /></p></li><li><p>步骤3：解压比赛数据，并使用pandas进行读取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>train_df = pd.read_csv(<span class="hljs-string">&#x27;./比赛训练集.csv&#x27;</span>, encoding=<span class="hljs-string">&#x27;gbk&#x27;</span>)<br>test_df = pd.read_csv(<span class="hljs-string">&#x27;./比赛测试集.csv&#x27;</span>, encoding=<span class="hljs-string">&#x27;gbk&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(train_df.shape,test_df.shape)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/09/KsFy8mwbWd3xeVT.png" alt="数据读取结果" style="zoom: 67%;" /></p></li><li><p>步骤4：查看训练集和测试集字段类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">train_df.dtypes<br>test_df.dtypes<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/09/2coTIwjRDF1eS6A.png" alt="查看字段类型" style="zoom:67%;" /></p></li></ul><h1 id="任务2：比赛数据分析"><a href="#任务2：比赛数据分析" class="headerlink" title="任务2：比赛数据分析"></a>任务2：比赛数据分析</h1><ul><li><p>步骤1：统计字段的缺失值，计算缺失比例；</p><ul><li>通过缺失值统计，训练集和测试集的缺失值分布是否一致？</li><li>通过缺失值统计，有没有缺失比例很高的列？</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">train_nan_df = pd.DataFrame(columns=[<span class="hljs-string">&#x27;标签&#x27;</span>,<span class="hljs-string">&#x27;训练集缺失个数&#x27;</span>,<span class="hljs-string">&#x27;训练集缺失比例&#x27;</span>])<br>i = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> tag <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(train_df.columns):<br>    num = train_df[tag].isnull().<span class="hljs-built_in">sum</span>()<br>    num_rate = num/<span class="hljs-built_in">len</span>(train_df)<br>    train_nan_df.loc[i] = [tag, num, num_rate]<br>    i += <span class="hljs-number">1</span><br><span class="hljs-comment"># train_nan_df</span><br><br>test_nan_df = pd.DataFrame(columns=[<span class="hljs-string">&#x27;标签&#x27;</span>,<span class="hljs-string">&#x27;测试集缺失个数&#x27;</span>,<span class="hljs-string">&#x27;测试集缺失比例&#x27;</span>])<br>i = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> tag <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(test_df.columns):<br>    num = test_df[tag].isnull().<span class="hljs-built_in">sum</span>()<br>    num_rate = num/<span class="hljs-built_in">len</span>(test_df)<br>    test_nan_df.loc[i] = [tag, num, num_rate]<br>    i += <span class="hljs-number">1</span><br><span class="hljs-comment"># test_nan_df</span><br><br>train_nan_df.merge(test_nan_df,how=<span class="hljs-string">&#x27;left&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/13/igeGY4789r3mAfu.png" alt="计算缺失值" style="zoom:67%;" /></p><p>根据结果可知，训练集和测试集的缺失值分布一致，都是有且只有舒张压这一个标签含缺失值，且比例都在4.8-4.9%左右，缺失的比例其实也不算是特别高。</p></li><li><p>步骤2：分析字段的类型</p><ul><li>有多少数值类型、类别类型？</li></ul><ul><li>你是判断字段类型的？</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">train_df.head() <span class="hljs-comment"># tail()</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/13/TijuZ3b4SA9FlaM.png" alt="head函数" style="zoom:67%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">train_category_num_df = pd.DataFrame(columns=[<span class="hljs-string">&#x27;标签&#x27;</span>,<span class="hljs-string">&#x27;训练集该标签不同值个数&#x27;</span>])<br>i = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> tag <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(train_df.columns):<br>    num = <span class="hljs-built_in">len</span>(train_df[tag].value_counts())<br>    train_category_num_df.loc[i] = [tag, num]<br>    i += <span class="hljs-number">1</span><br><span class="hljs-comment"># train_category_num_df</span><br><br>test_category_num_df = pd.DataFrame(columns=[<span class="hljs-string">&#x27;标签&#x27;</span>,<span class="hljs-string">&#x27;测试集该标签不同值个数&#x27;</span>])<br>i = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> tag <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(test_df.columns):<br>    num = <span class="hljs-built_in">len</span>(test_df[tag].value_counts())<br>    test_category_num_df.loc[i] = [tag, num]<br>    i += <span class="hljs-number">1</span><br><span class="hljs-comment"># test_category_num_df</span><br><br>train_category_num_df.merge(test_category_num_df,how=<span class="hljs-string">&#x27;left&#x27;</span>)<br><span class="hljs-comment"># 列包含NaN，因此dtype必须升级为浮点dtype以容纳</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/13/LGaBJfy21AN7VSH.png" alt="各标签类型个数" style="zoom:67%;" /></p><p>字段类型的判断主要通过根据常识（如性别）、观察原始数据（如糖尿病家族史）、以及各个标签的类型数量（如数量较多的可能就是连续性数据，是数值类型）来判断</p><ul><li>数值类型：编号（和时序无关，后期没必要研究），出生年份，体重指数，舒张压，口服耐糖量测试，胰岛素释放实验，肱三头肌皮褶厚度</li><li>类别类型：性别（两类），糖尿病家族史（类型），患有糖尿病标识</li><li>当然，后期为了改善模型效果，也可以将一些连续性数据转换成类别，比如体重指数可以根据国家标准划分胖瘦类型，成为类别类型</li><li>其中，糖尿病家族史有四类，但是查看其类型，和“叔叔或者姑姑有一方患有糖尿病”应是同一表述，但是被分到两类，应该合并成一类为“叔叔或姑姑有一方患有糖尿病”</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">train_df.糖尿病家族史.value_counts()<br><br>train_df.loc[train_df.糖尿病家族史 == <span class="hljs-string">&#x27;叔叔或者姑姑有一方患有糖尿病&#x27;</span>,<span class="hljs-string">&#x27;糖尿病家族史&#x27;</span>] = <span class="hljs-string">&#x27;叔叔或姑姑有一方患有糖尿病&#x27;</span><br>train_df.糖尿病家族史.value_counts()<br><br>train_df[<span class="hljs-string">&#x27;糖尿病家族史&#x27;</span>] = train_df[<span class="hljs-string">&#x27;糖尿病家族史&#x27;</span>].astype(<span class="hljs-string">&#x27;int64&#x27;</span>)<br>test_df[<span class="hljs-string">&#x27;糖尿病家族史&#x27;</span>] = test_df[<span class="hljs-string">&#x27;糖尿病家族史&#x27;</span>].astype(<span class="hljs-string">&#x27;int64&#x27;</span>)<br>train_df.dtypes<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/13/Mg4SaDRAZeonXry.png" alt="家族病史类别修改" style="zoom:67%;" /></p><p>步骤3：计算字段相关性</p><ul><li>通过<code>.corr()</code>计算字段之间的相关性</li><li>有哪些字段与标签的相关性最高？</li><li>尝试使用其他可视化方法将字段 与 标签的分布差异进行可视化</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tag_list = train_df<span class="hljs-selector-class">.columns</span><span class="hljs-selector-class">.tolist</span>()<br>tag_list<span class="hljs-selector-class">.pop</span>(tag_list<span class="hljs-selector-class">.index</span>(<span class="hljs-string">&quot;编号&quot;</span>))<br>corr = train_df<span class="hljs-selector-attr">[tag_list]</span><span class="hljs-selector-class">.corr</span>()<br>corr<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/13/Wfze7aSRVLPIvd8.png" alt="相关系数矩阵" style="zoom:67%;" /></p><p>虽然获得了相关系数矩阵，但是不便于分析结果，将其进行可视化，使用seaborn绘制热力图</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> string import ascii_letters<br>import numpy as np<br>import pandas as pd<br>import seaborn as sns<br>import matplotlib.pyplot as plt<br><br>sns.set_theme(<span class="hljs-attribute">style</span>=<span class="hljs-string">&quot;white&quot;</span>)<br>plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;SimHei&#x27;</span>]  # 黑体<br>plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="hljs-literal">False</span> # 负号<br><br><span class="hljs-comment"># Generate a mask for the upper triangle</span><br>mask = np.triu(np.ones_like(corr, <span class="hljs-attribute">dtype</span>=bool))<br><br><span class="hljs-comment"># Set up the matplotlib figure</span><br>f, ax = plt.subplots(figsize=(8, 8))<br><br><span class="hljs-comment"># Generate a custom diverging colormap</span><br>cmap = sns.diverging_palette(230, 20, <span class="hljs-attribute">as_cmap</span>=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># Draw the heatmap with the mask and correct aspect ratio</span><br>sns.heatmap(corr, <span class="hljs-attribute">mask</span>=mask, <span class="hljs-attribute">cmap</span>=cmap, <span class="hljs-attribute">vmax</span>=0.5, <span class="hljs-attribute">center</span>=0, <span class="hljs-attribute">vmin</span>=-0.3,<br>            <span class="hljs-attribute">square</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">linewidths</span>=2, cbar_kws=&#123;<span class="hljs-string">&quot;shrink&quot;</span>: .5&#125;)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/13/AUgrcZNpWf91hbq.png" alt="相关系数热力图" style="zoom: 80%;" /></p><p>颜色越深，表示和标签的相关性最高，也就是可以重点关注一下体重指数和肱三头肌褶厚度。</p><p>同时，还对不同的自变量之间进行相关性分析，按照是否有患有糖尿病标识绘制多变量联合分布pairplot图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">sns.set_theme(style=<span class="hljs-string">&quot;ticks&quot;</span>)<br><br>plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;SimHei&#x27;</span>]  <span class="hljs-comment"># 黑体</span><br>plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="hljs-literal">False</span> <span class="hljs-comment"># 负号</span><br><br>sns.pairplot(train_df.drop(columns=[<span class="hljs-string">&#x27;编号&#x27;</span>,<span class="hljs-string">&#x27;性别&#x27;</span>]), hue=<span class="hljs-string">&#x27;患有糖尿病标识&#x27;</span>,plot_kws=&#123;<span class="hljs-string">&#x27;alpha&#x27;</span>: <span class="hljs-number">0.5</span>&#125;)<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://s2.loli.net/2022/07/13/C2QF5D9dMjTy1GI.png" alt="多变量联合分布图" style="zoom: 67%;" /></p><p>由对角线可知，患有糖尿病和非患者的体重指数和肱三头肌褶厚度的分布有较大差别，患有糖尿病的分布都略向右偏移。由其他子图可知，患者的一些联合分布特征聚集比较紧密，有一些数据还有明显的中断、不连续，可以将其作为类别特征处理，如肱三头肌褶厚度，如果在40以上就极有可能是患者，这样处理可以提高准确率。</p><h1 id="任务3：逻辑回归尝试"><a href="#任务3：逻辑回归尝试" class="headerlink" title="任务3：逻辑回归尝试"></a>任务3：逻辑回归尝试</h1><ul><li>步骤1：导入sklearn中的逻辑回归；</li><li>步骤2：使用训练集和逻辑回归进行训练，并在测试集上进行预测；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 预处理（文字转编码、消除nan）</span><br>train_df.loc[train_df.糖尿病家族史 == <span class="hljs-string">&#x27;无记录&#x27;</span>,<span class="hljs-string">&#x27;糖尿病家族史&#x27;</span>] = <span class="hljs-number">0</span><br>train_df.loc[train_df.糖尿病家族史 == <span class="hljs-string">&#x27;叔叔或姑姑有一方患有糖尿病&#x27;</span>,<span class="hljs-string">&#x27;糖尿病家族史&#x27;</span>] = <span class="hljs-number">1</span><br>train_df.loc[train_df.糖尿病家族史 == <span class="hljs-string">&#x27;父母有一方患有糖尿病&#x27;</span>,<span class="hljs-string">&#x27;糖尿病家族史&#x27;</span>] = <span class="hljs-number">2</span><br><br>test_df.loc[test_df.糖尿病家族史 == <span class="hljs-string">&#x27;无记录&#x27;</span>,<span class="hljs-string">&#x27;糖尿病家族史&#x27;</span>] = <span class="hljs-number">0</span><br>test_df.loc[test_df.糖尿病家族史 == <span class="hljs-string">&#x27;叔叔或者姑姑有一方患有糖尿病&#x27;</span>,<span class="hljs-string">&#x27;糖尿病家族史&#x27;</span>] = <span class="hljs-number">1</span><br>test_df.loc[test_df.糖尿病家族史 == <span class="hljs-string">&#x27;叔叔或姑姑有一方患有糖尿病&#x27;</span>,<span class="hljs-string">&#x27;糖尿病家族史&#x27;</span>] = <span class="hljs-number">1</span><br>test_df.loc[test_df.糖尿病家族史 == <span class="hljs-string">&#x27;父母有一方患有糖尿病&#x27;</span>,<span class="hljs-string">&#x27;糖尿病家族史&#x27;</span>] = <span class="hljs-number">2</span><br><br>pressure_average = <span class="hljs-built_in">sum</span>(train_df.loc[train_df[<span class="hljs-string">&quot;舒张压&quot;</span>].notnull(),<span class="hljs-string">&quot;舒张压&quot;</span>].tolist())/<span class="hljs-built_in">len</span>(train_df.loc[train_df[<span class="hljs-string">&quot;舒张压&quot;</span>].notnull()])<br>train_df.loc[train_df[<span class="hljs-string">&quot;舒张压&quot;</span>].isnull(),<span class="hljs-string">&quot;舒张压&quot;</span>] = pressure_average<br>train_df<br><br>test_df.loc[test_df[<span class="hljs-string">&quot;舒张压&quot;</span>].isnull(),<span class="hljs-string">&quot;舒张压&quot;</span>] = pressure_average<br>test_df<br><br><span class="hljs-comment"># 开始训练</span><br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> linear_model<br><br>train_X, train_y = train_df.iloc[:, <span class="hljs-number">1</span>:-<span class="hljs-number">1</span>].values, train_df.iloc[:, -<span class="hljs-number">1</span>].values<br>test_X  = test_df.iloc[:, <span class="hljs-number">1</span>:].values<br>lr = linear_model.LogisticRegression(random_state=<span class="hljs-number">42</span>, max_iter=<span class="hljs-number">200</span>).fit(train_X, train_y)<br><br><span class="hljs-comment"># lr.predict_proba(train_X) # 可以获得每个预测的分数</span><br>lr.score(train_X, train_y) <span class="hljs-comment"># 0.8122287968441815</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/13/yJ8ETg9nGNVmQ3S.png" alt="第一次提交（逻辑回归）" style="zoom:67%;" /></p><ul><li>步骤3：将步骤2预测的结果文件提交到比赛，截图分数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.DataFrame(<span class="hljs-built_in">enumerate</span>(test_y,<span class="hljs-number">1</span>), columns=[<span class="hljs-string">&#x27;uuid&#x27;</span>,<span class="hljs-string">&#x27;label&#x27;</span>])<br>df.to_csv(<span class="hljs-string">&#x27;0713-hjy.csv&#x27;</span>, index=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/13/7EMaGfbzAut3wce.png" alt="第一次提交评分" style="zoom:67%;" /></p><ul><li>步骤4：将训练集20%划分为验证集，在训练部分进行训练，在测试部分进行预测，调节逻辑回归的超参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.utils <span class="hljs-keyword">import</span> shuffle<br><br>index = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(train_df)*<span class="hljs-number">0.8</span>)<br>train_df = shuffle(train_df)<br>train_X, train_y = train_df.iloc[:index, <span class="hljs-number">1</span>:-<span class="hljs-number">1</span>].values, train_df.iloc[:index, -<span class="hljs-number">1</span>].values<br>val_X, val_y     = train_df.iloc[index:, <span class="hljs-number">1</span>:-<span class="hljs-number">1</span>].values, train_df.iloc[index:, -<span class="hljs-number">1</span>].values<br>lr1 = linear_model.LogisticRegression(random_state=<span class="hljs-number">42</span>, max_iter=<span class="hljs-number">150</span>, C=<span class="hljs-number">100</span>).fit(train_X, train_y)<br>lr1.score(val_X, val_y)<br><span class="hljs-comment"># 直接分割 0.8126232741617357 0.7938856015779092 0.8353057199211046 无明显变化</span><br></code></pre></td></tr></table></figure><ul><li>步骤5：如果精度有提高，则重复步骤2和步骤3；如果没有提高，可以尝试树模型，重复步骤2、3</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier <span class="hljs-comment"># 使用随机森林</span><br><br>index = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(train_df)*<span class="hljs-number">0.8</span>)<br>train_df = shuffle(train_df)<br>train_X, train_y = train_df.iloc[:index, <span class="hljs-number">1</span>:-<span class="hljs-number">1</span>].values, train_df.iloc[:index, -<span class="hljs-number">1</span>].values<br>val_X, val_y     = train_df.iloc[index:, <span class="hljs-number">1</span>:-<span class="hljs-number">1</span>].values, train_df.iloc[index:, -<span class="hljs-number">1</span>].values<br>lr2 = RandomForestClassifier(n_estimators=<span class="hljs-number">50</span>).fit(train_X, train_y) <span class="hljs-comment">#参数50</span><br>lr2.score(val_X, val_y)<br><span class="hljs-comment"># 随机森林 0.9615384615384616 0.9575936883629191 0.9694280078895463 很可以了</span><br></code></pre></td></tr></table></figure><p>提交一波</p><p><img src="https://s2.loli.net/2022/07/13/QAY75s23eIFTGbC.png" alt="随机森林提交结果" style="zoom:67%;" /></p><h1 id="任务4：特征工程"><a href="#任务4：特征工程" class="headerlink" title="任务4：特征工程"></a>任务4：特征工程</h1><ul><li>步骤1：统计每个性别对应的【体重指数】、【舒张压】平均值（后面重做的时候最后发现体重指数有等于0的情况，实际上没有意义，应该设置为中位数或者平均数比较合适）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">index = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(train_df)*<span class="hljs-number">0.8</span>)<br>train_df = shuffle(train_df)<br><br><span class="hljs-comment"># groupby真好用</span><br>woman_BMI_average, man_BMI_average = train_df.groupby(<span class="hljs-string">&#x27;性别&#x27;</span>).mean()[<span class="hljs-string">&#x27;体重指数&#x27;</span>]<br>woman_pressure_average, man_pressure_average = train_df.groupby(<span class="hljs-string">&#x27;性别&#x27;</span>).mean()[<span class="hljs-string">&#x27;舒张压&#x27;</span>]<br>woman_BMI_average, man_BMI_average, woman_pressure_average, man_pressure_average<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/15/ZnVdvLCgHz92ro6.png" alt="groupby获得分组均值" style="zoom:67%;" /></p><ul><li>步骤2：计算每个患者与每个性别平均值的差异</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python">train_df[<span class="hljs-string">&#x27;BMI_delta&#x27;</span>] = <span class="hljs-number">0</span><br>train_df[<span class="hljs-string">&#x27;pressure_delta&#x27;</span>] = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(train_df)):<br>    <span class="hljs-keyword">if</span> train_df.iloc[i, <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">if</span> train_df[<span class="hljs-string">&#x27;体重指数&#x27;</span>][i] == <span class="hljs-number">0</span>:<br>            train_df[<span class="hljs-string">&#x27;体重指数&#x27;</span>][i] = woman_BMI_average<br>        train_df[<span class="hljs-string">&#x27;BMI_delta&#x27;</span>][i] = train_df[<span class="hljs-string">&#x27;体重指数&#x27;</span>][i] - woman_BMI_average<br>        train_df[<span class="hljs-string">&#x27;pressure_delta&#x27;</span>][i] = train_df[<span class="hljs-string">&#x27;舒张压&#x27;</span>][i] - woman_pressure_average<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> train_df[<span class="hljs-string">&#x27;体重指数&#x27;</span>][i] == <span class="hljs-number">0</span>:<br>            train_df[<span class="hljs-string">&#x27;体重指数&#x27;</span>][i] = man_BMI_average<br>        train_df[<span class="hljs-string">&#x27;BMI_delta&#x27;</span>][i] = train_df[<span class="hljs-string">&#x27;体重指数&#x27;</span>][i] - man_BMI_average<br>        train_df[<span class="hljs-string">&#x27;pressure_delta&#x27;</span>][i] = train_df[<span class="hljs-string">&#x27;舒张压&#x27;</span>][i] - man_pressure_average<br><br>train_df<br><br>test_df[<span class="hljs-string">&#x27;BMI_delta&#x27;</span>] = <span class="hljs-number">0</span><br>test_df[<span class="hljs-string">&#x27;pressure_delta&#x27;</span>] = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(test_df)):<br>    <span class="hljs-keyword">if</span> test_df.iloc[i, <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">if</span> test_df[<span class="hljs-string">&#x27;体重指数&#x27;</span>][i] == <span class="hljs-number">0</span>:<br>            test_df[<span class="hljs-string">&#x27;体重指数&#x27;</span>][i] = woman_BMI_average<br>        test_df[<span class="hljs-string">&#x27;BMI_delta&#x27;</span>][i] = test_df[<span class="hljs-string">&#x27;体重指数&#x27;</span>][i] - woman_BMI_average<br>        test_df[<span class="hljs-string">&#x27;pressure_delta&#x27;</span>][i] = test_df[<span class="hljs-string">&#x27;舒张压&#x27;</span>][i] - woman_pressure_average<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> test_df[<span class="hljs-string">&#x27;体重指数&#x27;</span>][i] == <span class="hljs-number">0</span>:<br>            test_df[<span class="hljs-string">&#x27;体重指数&#x27;</span>][i] = man_BMI_average<br>        test_df[<span class="hljs-string">&#x27;BMI_delta&#x27;</span>][i] = test_df[<span class="hljs-string">&#x27;体重指数&#x27;</span>][i] - man_BMI_average<br>        test_df[<span class="hljs-string">&#x27;pressure_delta&#x27;</span>][i] = test_df[<span class="hljs-string">&#x27;舒张压&#x27;</span>][i] - man_pressure_average<br><br>test_df<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/14/hQP2Y69DwZsk8pX.png" alt="计算每个患者与每个性别平均值的差异" style="zoom:67%;" /></p><ul><li>步骤3：在上述基础上将训练集20%划分为验证集，使用逻辑回归完成训练，精度是否有提高？</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> f1_score<br>train_y = train_df.iloc[:index, -<span class="hljs-number">3</span>].values<br>val_y   = train_df.iloc[index:, -<span class="hljs-number">3</span>].values<br>train_edit_df = train_df.drop(columns=<span class="hljs-string">&#x27;患有糖尿病标识&#x27;</span>)<br>train_X = train_edit_df.iloc[:index, <span class="hljs-number">1</span>:].values<br>val_X   = train_edit_df.iloc[index:, <span class="hljs-number">1</span>:].values<br><br>test_X  = test_df.iloc[:, <span class="hljs-number">1</span>:].values<br><br><span class="hljs-comment"># lr3 = linear_model.LogisticRegression(random_state=42, max_iter=1000, C=100).fit(train_X, train_y)</span><br><span class="hljs-comment"># lr3.score(val_X, val_y) #0.8274161735700197 对于逻辑回归变化不大</span><br><br>clf2 = RandomForestClassifier(n_estimators=<span class="hljs-number">30</span>).fit(train_X, train_y) <span class="hljs-comment">#参数30</span><br>val_y_predict = clf2.predict(val_X)<br><span class="hljs-comment"># clf2.score(val_X, val_y) #0.9635108481262328</span><br>f1_score(val_y, val_y_predict) <span class="hljs-comment"># 0.9488859764089121</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/14/thgHBEsFrGkubyZ.png" alt="加入两个新特征后的成绩" style="zoom:67%;" /></p><ul><li>步骤4：思考字段含义，尝试新的特征</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> f1_score<br><br>train_y = train_df.iloc[:index, -<span class="hljs-number">5</span>].values<br>val_y = train_df.iloc[index:, -<span class="hljs-number">5</span>].values<br>train_edit_df = train_df.drop(columns=<span class="hljs-string">&#x27;患有糖尿病标识&#x27;</span>)<br>train_X = train_edit_df.iloc[:index, <span class="hljs-number">1</span>:].values<br>val_X = train_edit_df.iloc[index:, <span class="hljs-number">1</span>:].values<br><br>test_X = test_df.iloc[:, <span class="hljs-number">1</span>:].values<br><br><span class="hljs-comment"># lr4 = linear_model.LogisticRegression(random_state=42, max_iter=5000, C=10).fit(train_X, train_y)</span><br><span class="hljs-comment"># lr4.score(val_X, val_y) #0.8441814595660749 逻辑回归有部分提高</span><br><br>clf3 = RandomForestClassifier(n_estimators=<span class="hljs-number">50</span>).fit(train_X, train_y)  <span class="hljs-comment">#参数50</span><br>val_y_predict = clf3.predict(val_X)<br><span class="hljs-comment"># clf3.score(val_X, val_y)  # 0.965483234714004</span><br>f1_score(val_y, val_y_predict) <span class="hljs-comment"># 0.9502617801047121</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">depth_type</span>(<span class="hljs-params">depth</span>):</span><br>    <span class="hljs-keyword">if</span> depth &lt; <span class="hljs-number">10</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">elif</span> depth &lt; <span class="hljs-number">40</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">BMI_type</span>(<span class="hljs-params">bmi</span>):</span><br>    <span class="hljs-keyword">if</span> bmi &lt;= <span class="hljs-number">18.4</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">elif</span> bmi &lt;= <span class="hljs-number">23.9</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> bmi &lt;= <span class="hljs-number">27.9</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br><span class="hljs-comment"># 偏瘦&lt;= 18.4</span><br><span class="hljs-comment"># 正常18.5 ~ 23.9</span><br><span class="hljs-comment"># 过重24.0 ~ 27.9</span><br><span class="hljs-comment"># 肥胖&gt;= 28.0</span><br><br>train_df[<span class="hljs-string">&#x27;bmi_type&#x27;</span>] = train_df[<span class="hljs-string">&#x27;体重指数&#x27;</span>].<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: BMI_type(x))<br>train_df[<span class="hljs-string">&#x27;depth_type&#x27;</span>] = train_df[<span class="hljs-string">&#x27;肱三头肌皮褶厚度&#x27;</span>].<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: depth_type(x))<br>train_df<br><br>test_df[<span class="hljs-string">&#x27;bmi_type&#x27;</span>] = test_df[<span class="hljs-string">&#x27;体重指数&#x27;</span>].<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: BMI_type(x))<br>test_df[<span class="hljs-string">&#x27;depth_type&#x27;</span>] = test_df[<span class="hljs-string">&#x27;肱三头肌皮褶厚度&#x27;</span>].<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: depth_type(x))<br>test_df<br><br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> f1_score<br><br>train_y = train_df.iloc[:index, -<span class="hljs-number">5</span>].values<br>val_y = train_df.iloc[index:, -<span class="hljs-number">5</span>].values<br>train_edit_df = train_df.drop(columns=<span class="hljs-string">&#x27;患有糖尿病标识&#x27;</span>)<br>train_X = train_edit_df.iloc[:index, <span class="hljs-number">1</span>:].values<br>val_X = train_edit_df.iloc[index:, <span class="hljs-number">1</span>:].values<br><br>test_X = test_df.iloc[:, <span class="hljs-number">1</span>:].values<br><br><span class="hljs-comment"># lr4 = linear_model.LogisticRegression(random_state=42, max_iter=5000, C=10).fit(train_X, train_y)</span><br><span class="hljs-comment"># lr4.score(val_X, val_y) #0.8353057199211046 逻辑回归有部分提高</span><br><br>clf3 = RandomForestClassifier(n_estimators=<span class="hljs-number">50</span>).fit(train_X, train_y)  <span class="hljs-comment">#参数50</span><br>val_y_predict = clf3.predict(val_X)<br><span class="hljs-comment"># clf3.score(val_X, val_y)  # 0.97534516765286</span><br>f1_score(val_y, val_y_predict) <span class="hljs-comment"># 0.9645390070921985</span><br></code></pre></td></tr></table></figure><h1 id="任务5：特征筛选"><a href="#任务5：特征筛选" class="headerlink" title="任务5：特征筛选"></a>任务5：特征筛选</h1><ul><li>步骤1：使用树模型完成模型的训练，通过特征重要性筛选出Top5的特征；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">data=&#123;<span class="hljs-string">&#x27;featureName&#x27;</span>:train_edit_df.columns[<span class="hljs-number">1</span>:],<span class="hljs-string">&#x27;importances&#x27;</span>:clf2.feature_importances_.tolist()&#125;<br>df = pd.DataFrame(data)<br>df=df.sort_values(by=[<span class="hljs-string">&#x27;importances&#x27;</span>],ascending=<span class="hljs-literal">False</span>)<br>df<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/14/GhTgwfWYlKOmQs4.png" alt="权重表格" style="zoom:67%;" /></p><ul><li>步骤2：使用筛选出的特征和逻辑回归进行训练，在验证集精度是否有提高？</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">train_X = train_df[[<span class="hljs-string">&quot;体重指数&quot;</span>,<span class="hljs-string">&quot;肱三头肌皮褶厚度&quot;</span>,<span class="hljs-string">&quot;BMI_delta&quot;</span>,<span class="hljs-string">&quot;口服耐糖量测试&quot;</span>,<span class="hljs-string">&quot;胰岛素释放实验&quot;</span>]].iloc[:index, :].values<br>train_y = train_df[<span class="hljs-string">&quot;患有糖尿病标识&quot;</span>].iloc[:index].values<br>val_X = train_df[[<span class="hljs-string">&quot;体重指数&quot;</span>,<span class="hljs-string">&quot;肱三头肌皮褶厚度&quot;</span>,<span class="hljs-string">&quot;BMI_delta&quot;</span>,<span class="hljs-string">&quot;口服耐糖量测试&quot;</span>,<span class="hljs-string">&quot;胰岛素释放实验&quot;</span>]].iloc[index:, :].values<br>val_y =  train_df[<span class="hljs-string">&quot;患有糖尿病标识&quot;</span>].iloc[index:].values<br><br>test_X = test_df[[<span class="hljs-string">&quot;体重指数&quot;</span>,<span class="hljs-string">&quot;肱三头肌皮褶厚度&quot;</span>,<span class="hljs-string">&quot;BMI_delta&quot;</span>,<span class="hljs-string">&quot;口服耐糖量测试&quot;</span>,<span class="hljs-string">&quot;胰岛素释放实验&quot;</span>]].values<br><br><span class="hljs-comment"># lr5 = linear_model.LogisticRegression(random_state=42, max_iter=500, C=100).fit(train_X, train_y)</span><br><span class="hljs-comment"># lr5.score(val_X, val_y) #0.8274161735700197 逻辑回归下降了</span><br><br>clf4 = RandomForestClassifier(n_estimators=<span class="hljs-number">50</span>).fit(train_X, train_y)  <span class="hljs-comment">#参数50</span><br>val_y_predict = clf4.predict(val_X)<br><span class="hljs-comment"># clf4.score(val_X, val_y)  #0.9368836291913215 也下降了</span><br>f1_score(val_y, val_y_predict) <span class="hljs-comment"># 0.9058823529411766</span><br></code></pre></td></tr></table></figure><ul><li><p>步骤3：如果有提高，为什么？如果没有提高，为什么？</p><p>没有提高，其他特征也比较重要，筛选的特征太少了导致细节丢失，换几个主要特征后，基本回升到原来的状态，应该是到了随机森林模型极限了，修改随机森林的参数也没有太大提升</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> f1_score<br><br>train_X = train_df[[<span class="hljs-string">&quot;体重指数&quot;</span>,<span class="hljs-string">&quot;肱三头肌皮褶厚度&quot;</span>,<span class="hljs-string">&quot;BMI_delta&quot;</span>,<span class="hljs-string">&quot;口服耐糖量测试&quot;</span>,<span class="hljs-string">&quot;胰岛素释放实验&quot;</span>,<span class="hljs-string">&quot;舒张压&quot;</span>,<span class="hljs-string">&quot;depth_type&quot;</span>]].iloc[:index, :].values<br>train_y = train_df[<span class="hljs-string">&quot;患有糖尿病标识&quot;</span>].iloc[:index].values<br>val_X = train_df[[<span class="hljs-string">&quot;体重指数&quot;</span>,<span class="hljs-string">&quot;肱三头肌皮褶厚度&quot;</span>,<span class="hljs-string">&quot;BMI_delta&quot;</span>,<span class="hljs-string">&quot;口服耐糖量测试&quot;</span>,<span class="hljs-string">&quot;胰岛素释放实验&quot;</span>,<span class="hljs-string">&quot;舒张压&quot;</span>,<span class="hljs-string">&quot;depth_type&quot;</span>]].iloc[index:, :].values<br>val_y =  train_df[<span class="hljs-string">&quot;患有糖尿病标识&quot;</span>].iloc[index:].values<br><br>test_X = test_df[[<span class="hljs-string">&quot;体重指数&quot;</span>,<span class="hljs-string">&quot;肱三头肌皮褶厚度&quot;</span>,<span class="hljs-string">&quot;BMI_delta&quot;</span>,<span class="hljs-string">&quot;口服耐糖量测试&quot;</span>,<span class="hljs-string">&quot;胰岛素释放实验&quot;</span>,<span class="hljs-string">&quot;舒张压&quot;</span>,<span class="hljs-string">&quot;depth_type&quot;</span>]].values<br><br><span class="hljs-comment"># lr6 = linear_model.LogisticRegression(random_state=42, max_iter=500, C=100).fit(train_X, train_y)</span><br><span class="hljs-comment"># lr6.score(val_X, val_y) #0.8392504930966469 没有提高</span><br><span class="hljs-comment">#</span><br>clf5 = RandomForestClassifier(n_estimators=<span class="hljs-number">50</span>).fit(train_X, train_y)  <span class="hljs-comment">#参数50</span><br>val_y_predict = clf5.predict(val_X)<br><span class="hljs-comment"># clf5.score(val_X, val_y)   # 0.9644970414201184</span><br>f1_score(val_y, val_y_predict) <span class="hljs-comment"># 0.9501312335958005</span><br></code></pre></td></tr></table></figure><h1 id="任务6：高阶树模型"><a href="#任务6：高阶树模型" class="headerlink" title="任务6：高阶树模型"></a>任务6：高阶树模型</h1><ul><li>步骤1：安装LightGBM，并学习基础的使用方法</li></ul><p><img src="https://s2.loli.net/2022/07/14/srqPIeHxQtUd4fJ.png" alt="下载lightgbm" style="zoom:67%;" /></p><ul><li>步骤2：将训练集20%划分为验证集，使用LightGBM完成训练，精度是否有提高？</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> lightgbm <span class="hljs-keyword">as</span> lgb<br><br>clf6 = lgb.LGBMClassifier()<br>clf6.fit(train_X, train_y, eval_set=[(val_X,val_y)], callbacks=[lgb.early_stopping(<span class="hljs-number">50</span>)])<br>val_y_predict = clf6.predict(val_X)<br><br><span class="hljs-comment"># clf6.score(val_X, val_y)  # 0.9635108481262328</span><br>f1_score(val_y, val_y_predict) <span class="hljs-comment"># 0.9512516469038208</span><br></code></pre></td></tr></table></figure><ul><li>步骤3：将步骤2预测的结果文件提交到比赛，截图分数，没有前面的好</li></ul><p><img src="https://s2.loli.net/2022/07/14/SEBuITsPhUGeYWC.png" alt="无调参LightGBM.png" style="zoom: 67%;" /></p><ul><li>步骤4：尝试调节搜索LightGBM的参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">clf7 = lgb.LGBMClassifier(<br>    max_depth=<span class="hljs-number">2</span>,<br>    n_estimators=<span class="hljs-number">2000</span>,<br>    n_jobs=-<span class="hljs-number">1</span>,<br>    verbose=-<span class="hljs-number">1</span>,<br>    learning_rate=<span class="hljs-number">0.2</span>,<br>)<br>clf7.fit(train_X, train_y, eval_set=[(val_X,val_y)], callbacks=[lgb.early_stopping(<span class="hljs-number">50</span>)])<br>val_y_predict = clf7.predict(val_X)<br><br><span class="hljs-comment"># clf7.score(val_X, val_y)  # 0.960552268244576</span><br>f1_score(val_y, val_y_predict) <span class="hljs-comment"># 0.9468085106382979</span><br></code></pre></td></tr></table></figure><ul><li>步骤5：将步骤4调参之后的模型从新训练，将最新预测的结果文件提交到比赛，寄</li></ul><p><img src="https://s2.loli.net/2022/07/15/td3p4ucq1fEWljG.png" alt="LightGBM调参结果" style="zoom:67%;" /></p><h1 id="任务7：多折训练与集成"><a href="#任务7：多折训练与集成" class="headerlink" title="任务7：多折训练与集成"></a>任务7：多折训练与集成</h1><ul><li>步骤1：使用KFold完成数据划分</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> KFold<br><br>train_X = train_df[[<span class="hljs-string">&quot;体重指数&quot;</span>,<span class="hljs-string">&quot;肱三头肌皮褶厚度&quot;</span>,<span class="hljs-string">&quot;BMI_delta&quot;</span>,<span class="hljs-string">&quot;口服耐糖量测试&quot;</span>,<span class="hljs-string">&quot;胰岛素释放实验&quot;</span>,<span class="hljs-string">&quot;舒张压&quot;</span>,<span class="hljs-string">&quot;depth_type&quot;</span>]].iloc[:index, :]<br>train_y = train_df[<span class="hljs-string">&quot;患有糖尿病标识&quot;</span>].iloc[:index]<br>val_X = train_df[[<span class="hljs-string">&quot;体重指数&quot;</span>,<span class="hljs-string">&quot;肱三头肌皮褶厚度&quot;</span>,<span class="hljs-string">&quot;BMI_delta&quot;</span>,<span class="hljs-string">&quot;口服耐糖量测试&quot;</span>,<span class="hljs-string">&quot;胰岛素释放实验&quot;</span>,<span class="hljs-string">&quot;舒张压&quot;</span>,<span class="hljs-string">&quot;depth_type&quot;</span>]].iloc[index:, :]<br>val_y =  train_df[<span class="hljs-string">&quot;患有糖尿病标识&quot;</span>].iloc[index:]<br><br>test_X = test_df[[<span class="hljs-string">&quot;体重指数&quot;</span>,<span class="hljs-string">&quot;肱三头肌皮褶厚度&quot;</span>,<span class="hljs-string">&quot;BMI_delta&quot;</span>,<span class="hljs-string">&quot;口服耐糖量测试&quot;</span>,<span class="hljs-string">&quot;胰岛素释放实验&quot;</span>,<span class="hljs-string">&quot;舒张压&quot;</span>,<span class="hljs-string">&quot;depth_type&quot;</span>]]<br><br><br><span class="hljs-comment"># 模型交叉验证</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_model_cv</span>(<span class="hljs-params">model, kf, X_tr, y, X_te, cate_col=<span class="hljs-literal">None</span></span>):</span><br>    train_pred = np.zeros( (<span class="hljs-built_in">len</span>(X_tr), <span class="hljs-built_in">len</span>(np.unique(y))) )<br>    test_pred = np.zeros( (<span class="hljs-built_in">len</span>(X_te), <span class="hljs-built_in">len</span>(np.unique(y))) )<br><br>    cv_clf = []<br>    <span class="hljs-keyword">for</span> tr_idx, val_idx <span class="hljs-keyword">in</span> kf.split(X_tr, y):<br>        x_tr = X_tr.iloc[tr_idx]; y_tr = y.iloc[tr_idx]<br>        x_val = X_tr.iloc[val_idx]; y_val = y.iloc[val_idx]<br>        call_back = [lgb.early_stopping(<span class="hljs-number">50</span>),]<br>        eval_set = [(x_val, y_val)]<br>        model.fit(x_tr, y_tr, eval_set=eval_set, callbacks=call_back)<br>        cv_clf.append(model)<br>        train_pred[val_idx] = model.predict_proba(x_val)<br>        test_pred += model.predict_proba(X_te)<br><br>    test_pred /= kf.n_splits<br>    <span class="hljs-keyword">return</span> train_pred, test_pred, cv_clf<br><br>train_pred, test_pred, cv_clf = run_model_cv(<br>    clf7, KFold(n_splits=<span class="hljs-number">7</span>),<br>    train_X,<br>    train_y,<br>    val_X,<br>)<br><span class="hljs-comment"># test_pred</span><br><br>test_pred_arg_max = [ i.argmax() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> test_pred]<br>f1_score(val_y, val_y_predict) <span class="hljs-comment"># 0.9522546419098143 没变</span><br></code></pre></td></tr></table></figure><ul><li>步骤2：使用StratifiedKFold完成数据划分</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> StratifiedKFold<br><br>train_pred, test_pred, cv_clf = run_model_cv(<br>    clf8, StratifiedKFold(n_splits=<span class="hljs-number">10</span>),<br>    train_X,<br>    train_y,<br>    val_X,<br>)<br><span class="hljs-comment"># test_pred</span><br><br>test_pred_arg_max = [ i.argmax() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> test_pred]<br>f1_score(val_y, val_y_predict) <span class="hljs-comment"># 0.9522546419098143</span><br></code></pre></td></tr></table></figure><ul><li>步骤3：使用StratifiedKFold配合LightGBM完成模型的训练和预测（如上）</li><li>步骤4：在步骤3训练得到了多少个模型，对测试集多次预测，将最新预测的结果文件提交到比赛，截图分数，分数没有增长就不截图了</li></ul><p><img src="https://s2.loli.net/2022/07/15/n1soPhZkTrgUGeX.png" alt="添加StratifiedKFold" style="zoom:50%;" /></p><ul><li>步骤5：使用交叉验证训练5个机器学习模型（svm、lr等），使用stacking完成集成，将最新预测的结果文件提交到比赛，截图分数</li></ul><p>蚌埠住了，集成学习了之后还没不集成和不特征工程的分数高，傻了。</p><p><img src="https://s2.loli.net/2022/07/15/pW2S6H5CZIyBbQq.png" alt="集成学习" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>课外学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据分析</tag>
      
      <tag>机器学习</tag>
      
      <tag>Coggle 30 Days of ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《动手学深度学习》笔记</title>
    <link href="/2022/06/20/d2l/"/>
    <url>/2022/06/20/d2l/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考资料</p><p>书籍：<a href="https://zh-v2.d2l.ai/">https://zh-v2.d2l.ai/</a></p><p>视频：<a href="https://www.bilibili.com/video/BV1eZ4y1w7PY">https://www.bilibili.com/video/BV1eZ4y1w7PY</a></p><p>ppt：<a href="https://courses.d2l.ai/zh-v2/">https://courses.d2l.ai/zh-v2/</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><h2 id="线代"><a href="#线代" class="headerlink" title="线代"></a>线代</h2><p>各种乘积</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dot product</span><br>torch.dot(x, y)<br><br><span class="hljs-comment"># matrix-vector product</span><br>torch.mv(A, x) <br><br><span class="hljs-comment"># matrix-vector product</span><br>torch.mm(A, B)<br><br><span class="hljs-comment"># Hadamard product</span><br>A * B<br></code></pre></td></tr></table></figure><ul><li>各种求导</li></ul><p><img src="https://s2.loli.net/2022/06/20/7X1DNQEuSG95JTL.png" alt="image-20220620110808338" style="zoom:50%;" /></p><p><img src="https://s2.loli.net/2022/06/20/h3HgpOxfqavZ6Wo.png" alt="image-20220620110827086" style="zoom:50%;" /></p><p><img src="https://s2.loli.net/2022/06/20/MI8UnOefJQuFjpY.png" alt="image-20220620111224505" style="zoom:50%;" /></p><h2 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h2><p>基础知识，略</p><h2 id="自动微分"><a href="#自动微分" class="headerlink" title="自动微分"></a>自动微分</h2><ul><li><p>在指定值上的导数，不同于符号求导和数值求导</p></li><li><p>automatic differentiation</p></li><li>涉及到 computational graph 和 backpropagate</li><li><p>为什么DL耗资源原因之一：反向传播求梯度需要存储正向所有中间结果，复杂度 O(n)</p></li><li><p>非标量变量的反向传播一般是单独计算批量中每个样本的偏导数之和</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br>x = torch.arange(<span class="hljs-number">4.0</span>)<br>x.requires_grad_(<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 等价于x=torch.arange(4.0,requires_grad=True)</span><br>x.grad  <span class="hljs-comment"># 默认值是None</span><br>y = <span class="hljs-number">2</span> * torch.dot(x, x)<br>y.backward()<br>x.grad<br><span class="hljs-comment"># tensor([ 0., 4., 8., 12.])</span><br><br>x.grad.zero_()<br>y = x * x<br><span class="hljs-comment"># 等价于y.backward(torch.ones(len(x)))</span><br>y.<span class="hljs-built_in">sum</span>().backward()<br>x.grad<br><span class="hljs-comment"># tensor([0., 2., 4., 6.])</span><br></code></pre></td></tr></table></figure><h2 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h2><ul><li>Bayes’ theorem</li><li>joint distribution</li><li>conditional distribution</li><li>marginal distribution</li></ul><h1 id="线性神经网络"><a href="#线性神经网络" class="headerlink" title="线性神经网络"></a>线性神经网络</h1><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><ul><li>linear regression</li><li><p>analytical solution $\mathbf{w}^* = (\mathbf X^\top \mathbf X)^{-1}\mathbf X^\top \mathbf{y}$</p></li><li><p>线性回归是对n维输入的加权，外加偏差</p></li><li>使用平方损失来衡量预测值和真实值的差异</li><li>线性回归有显式解</li><li>线性回归可以看做是单层神经网络</li><li>梯度下降通过不断沿着反梯度方向更新参数求解</li><li>小批量随机梯度下降是深度学习默认的求解算法</li><li>两个重要的超参数是批量大小和学习率</li></ul><h2 id="softmax"><a href="#softmax" class="headerlink" title="softmax"></a>softmax</h2><ul><li><p>$\hat{\mathbf{y}} = \mathrm{softmax}(\mathbf{o})\quad \text{其中}\quad \hat{y}_j = \frac{\exp(o_j)}{\sum_k \exp(o_k)}$</p></li><li><p>$\partial<em>{o_j} l(\mathbf{y}, \hat{\mathbf{y}}) = \frac{\exp(o_j)}{\sum</em>{k=1}^q \exp(o_k)} - y_j = \mathrm{softmax}(\mathbf{o})_j - y_j$</p></li><li><p>尽管softmax是一个非线性函数，但softmax回归的输出仍然由输入特征的仿射变换决定。 因此，softmax回归是一个线性模型（linear model）。</p></li><li><p>熵（entropy）</p></li><li><p>$H[P] = \sum_j - P(j) \log P(j).$</p></li><li><p>可以从两方面来考虑交叉熵（cross-entropy loss）分类目标： （i）最大化观测数据的似然；（ii）最小化传达标签所需的惊异。</p></li><li><p>损失函数：L1，L2，Huber</p></li><li><p>LogSumExp类似技巧</p><p>$\begin{split}\begin{aligned}<br>\log{(\hat y_j)} &amp; = \log\left( \frac{\exp(o_j - \max(o_k))}{\sum_k \exp(o_k - \max(o_k))}\right) \<br>&amp; = \log{(\exp(o_j - \max(o_k)))}-\log{\left( \sum_k \exp(o_k - \max(o_k)) \right)} \<br>&amp; = o_j - \max(o_k) -\log{\left( \sum_k \exp(o_k - \max(o_k)) \right)}.<br>\end{aligned}\end{split}$</p></li></ul><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><ul><li>单层线性无法识别XOR</li><li>multilayer perceptrons 使用 hidden layer 和 activation function 来得到非线性模型</li><li>sigmoid、tanh、ReLu（rectified linear unit）</li><li>softmax处理多分类</li></ul><h2 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h2><ul><li>underfitting &amp; overfitting</li><li>对抗过拟合的技术称为正则化（regularization）</li></ul><h2 id="-3"><a href="#-3" class="headerlink" title=" "></a> </h2><ul><li>weight decay</li><li>L1：lasso regression: 偏向于在大量特征上均匀分布权重的模型</li><li>L2：ridge regression: 会导致模型将权重集中在一小部分特征上， 而将其他权重清除为零</li></ul>]]></content>
    
    
    <categories>
      
      <category>课外学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS学习笔记</title>
    <link href="/2022/06/02/ROS-learning/"/>
    <url>/2022/06/02/ROS-learning/</url>
    
    <content type="html"><![CDATA[<blockquote><p>主要内容：ROS相关重要知识点和遇到的问题</p><p>参考资料：<a href="http://www.autolabor.com.cn/book/ROSTutorials/">http://www.autolabor.com.cn/book/ROSTutorials/</a></p></blockquote><h1 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>win10系统使用vmware workstation 16 pro安装ubuntu 20.04版本，ros系统选择noetic版本。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">sudo rosdep <span class="hljs-keyword">init</span><br>rosdep update<br></code></pre></td></tr></table></figure><p>上述步骤遇到网络问题，主要考虑在“软件与更新”中换中国的源（阿里、科大），然后主机使用手机热点联网。尝试过修改rawgithub的文件内容，把网站改成zhaoxuzuo的gitee（可能是现在gitee需要登录才行？）、给ubuntu装clash vpn尝试结果都不太行。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>ROS全称Robot Operating System(机器人操作系统)。在ROS中每一个功能点都是一个单独的进程，每一个进程都是独立运行的。</p></li><li><p>文件系统<br><img src="https://s2.loli.net/2022/06/02/SE1dsfhrw4kqDM3.jpg" alt="img" style="zoom:80%;" /></p></li><li><p>rqt_graph：可以显示节点关系</p></li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">rosnode ping    测试到节点的连接状态<br>rosnode list    列出活动节点<br>rosnode <span class="hljs-keyword">info</span>    打印节点信息<br>rosnode machine 列出指定设备上节点<br>rosnode kill    杀死某个节点<br>rosnode cleanup 清除不可连接的节点<br>//清除无用节点，启动乌龟节点，然后 ctrl + c 关闭，该节点并没被彻底清除，可以使用 cleanup 清除节点<br><br>rostopic bw     显示主题使用的带宽<br>rostopic delay  显示带有 <span class="hljs-keyword">header</span> 的主题延迟<br>rostopic echo   打印消息到屏幕<br>rostopic find   根据类型查找主题<br>rostopic hz     显示主题的发布频率<br>rostopic <span class="hljs-keyword">info</span>   显示主题相关信息<br>rostopic list   显示所有活动状态下的主题<br>rostopic pub    将数据发布到主题<br>rostopic <span class="hljs-keyword">type</span>   打印主题类型<br><br>rosmsg <span class="hljs-keyword">show</span>     显示消息描述<br>rosmsg <span class="hljs-keyword">info</span>     显示消息信息<br>rosmsg list     列出所有消息<br>rosmsg md5      显示 md5 加密后的消息<br>rosmsg package  显示某个功能包下的所有消息<br>rosmsg packages 列出包含消息的功能包<br><br>rosservice args 打印服务参数<br>rosservice <span class="hljs-keyword">call</span> 使用提供的参数调用服务<br>rosservice find 按照服务类型查找服务<br>rosservice <span class="hljs-keyword">info</span> 打印有关服务的信息<br>rosservice list 列出所有活动的服务<br>rosservice <span class="hljs-keyword">type</span> 打印服务类型<br>rosservice uri  打印服务的 ROSRPC uri<br><br>rossrv <span class="hljs-keyword">show</span>     显示服务消息详情<br>rossrv <span class="hljs-keyword">info</span>     显示服务消息相关信息<br>rossrv list     列出所有服务信息<br>rossrv md5      显示 md5 加密后的服务消息<br>rossrv package  显示某个包下所有服务消息<br>rossrv packages 显示包含服务消息的所有包<br><br>rosparam <span class="hljs-keyword">set</span>    设置参数<br>rosparam <span class="hljs-keyword">get</span>    获取参数<br>rosparam <span class="hljs-keyword">load</span>   从外部文件加载参数<br>rosparam dump   将参数写出到外部文件<br>rosparam <span class="hljs-keyword">delete</span> 删除参数<br>rosparam list   列出所有参数<br><br>//rosservice和rossrv，前者是对ROS服务本身的管理，后者是对ROS服务类型的管理，相当于话题的rostopic和rosmsg。<br></code></pre></td></tr></table></figure><h1 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h1><h2 id="话题通信-发布订阅模式"><a href="#话题通信-发布订阅模式" class="headerlink" title="话题通信(发布订阅模式)"></a>话题通信(发布订阅模式)</h2><ul><li><p>基于<strong>发布订阅</strong>模式的，也即：一个节点发布消息，另一个节点订阅该消息。</p></li><li><p>用于不断更新的、少逻辑处理的数据传输场景。</p></li><li><p>模型</p><p><img src="https://s2.loli.net/2022/06/02/3USuK6L1VfpyWTo.jpg" alt="img"></p></li><li><p>注意1:上述实现流程中，前五步使用的 RPC(Remote Procedure Call Protocol，远程过程调用）协议，最后两步使用的是 TCP 协议</p><p>注意2: Talker 与 Listener 的启动无先后顺序要求</p><p>注意3: Talker 与 Listener 都可以有多个</p><p>注意4: Talker 与 Listener 连接建立后，不再需要 ROS Master。也即，即便关闭ROS Master，Talker 与 Listern 照常通信。</p></li><li><p>消息发布器一直循环发送msg到topic chatter上；消息订阅器一旦发现 chatter上有data，就会把msg放到一个队列回调函数中，但还未执行callback函数。当运行<code>ros::spin()</code>和<code>ros::spinOnce()</code>时，就会执行callback函数。<br>一般<code>ros::spin()</code>后便不在写程序了，后面直接<code>return 0</code>。而<code>ros::spinOnce()</code>的使用比较灵活，但需要注意的是，在使用这个函数时，需要考虑到消息的调用时机、频率、以及消息池的大小,这个函数比较灵活，尤其是我想控制接收速度的时候。配合<code>while (ros::ok())</code>效果极佳。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//10Hz</span><br><span class="hljs-keyword">while</span>(ros::<span class="hljs-built_in">ok</span>())<br>&#123;<br>    ros::<span class="hljs-built_in">spinOnce</span>();<br>    loop_rate.<span class="hljs-built_in">sleep</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>cpp文件在src下，python文件在script下</p></li><li><p>话题通信自定义msg</p><ul><li><p>字段类型：int8, int16, int32, int64 (或者无符号类型: uint*)、float32, float64、string、time, duration、variable-length array[] and fixed-length array[C]、header</p></li><li><p>string类型在c++代码中要使用<code>.c_str()</code>转换</p></li><li><p>步骤主要包括：构建msg/my_msg.msg数据结构，主程序中需要对该对象进行描述、配置package.xml和CMakeLists.txt等</p><blockquote><p>复习：Cpp中<code>.</code>和<code>-&gt;</code>说明</p><ol><li><code>.</code>是成员运算符，用于调取成员变量和成员函数；符号<code>.</code>的左边必须是实例对象（具体对象），举例为绿色字体；</li><li><code>-&gt;</code>是地址运算符，用于引用成员变量和成员函数；符号<code>-&gt;</code>的左边是实例对象的地址或者类名（结构名），举例为黄色字体；</li><li>等价形式：d.msg() 和 (*constpt).msg() 等价</li></ol></blockquote></li></ul></li></ul><h2 id="服务通信-请求响应模式"><a href="#服务通信-请求响应模式" class="headerlink" title="服务通信(请求响应模式)"></a>服务通信(请求响应模式)</h2><ul><li><p>服务通信是基于<strong>请求响应</strong>模式的，是一种应答机制。也即: 一个节点A向另一个节点B发送请求，B接收处理请求并产生响应结果返回给A。</p></li><li><p>服务通信更适用于对实时性有要求、具有一定逻辑处理的应用场景。</p></li><li><p>模型</p><p><img src="https://s2.loli.net/2022/06/02/BOEoabv9pwu4xNI.jpg" alt="img"></p></li><li><p>1.客户端请求被处理时，需要保证服务器已经启动；</p><p>2.服务端和客户端都可以存在多个。</p></li><li><p>服务通信自定义srv</p><ul><li>字段类型、格式，请求和响应用<code>---</code>隔开</li><li>步骤主要包括：构建srv/my_srv.srv数据结构，主程序中需要对该对象进行描述、配置package.xml和CMakeLists.txt等</li></ul></li></ul><h2 id="参数服务器-参数共享模式"><a href="#参数服务器-参数共享模式" class="headerlink" title="参数服务器(参数共享模式)"></a>参数服务器(参数共享模式)</h2><ul><li>参数服务器在ROS中主要用于实现不同节点之间的数据共享。参数服务器相当于是独立于所有节点的一个公共容器，可以将数据存储在该容器中，被不同的节点调用，不同的节点也可以往其中存储数据。</li><li>存储一些多节点共享的数据，类似于全局变量。</li><li>可以对参数进行增删改查。</li><li><p>模型<br><img src="https://s2.loli.net/2022/06/02/McH9TXoJZsgBvWp.jpg" alt="img" style="zoom: 67%;" /></p></li><li><p>数据类型：32-bit integers、booleans、strings、doubles、iso8601 dates、lists、base64-encoded binary data、字典（参数服务器不是为高性能而设计的，因此最好用于存储静态的非二进制的简单数据）</p></li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Topic(话题)</th><th style="text-align:left">Service(服务)</th><th></th></tr></thead><tbody><tr><td style="text-align:left">通信模式</td><td style="text-align:left">发布/订阅</td><td>请求/响应</td></tr><tr><td style="text-align:left">同步性</td><td style="text-align:left">异步</td><td>同步</td></tr><tr><td style="text-align:left">底层协议</td><td style="text-align:left">ROSTCP/ROSUDP</td><td>ROSTCP/ROSUDP</td></tr><tr><td style="text-align:left">缓冲区</td><td style="text-align:left">有</td><td>无</td></tr><tr><td style="text-align:left">实时性</td><td style="text-align:left">弱</td><td>强</td></tr><tr><td style="text-align:left">节点关系</td><td style="text-align:left">多对多</td><td>一对多(一个 Server)</td></tr><tr><td style="text-align:left">通信数据</td><td style="text-align:left">msg</td><td>srv</td></tr><tr><td style="text-align:left">使用场景</td><td style="text-align:left">连续高频的数据发布与接收:雷达、里程计</td><td>偶尔调用或执行某一项特定功能：拍照、语音识别</td></tr></tbody></table></div><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul><li>初始化</li><li>话题服务相关</li><li>回旋函数</li><li>时间</li><li>其他</li></ul><h1 id="运行管理"><a href="#运行管理" class="headerlink" title="运行管理"></a>运行管理</h1><h2 id="launch文件"><a href="#launch文件" class="headerlink" title="launch文件"></a>launch文件</h2><h2 id="工作空间覆盖"><a href="#工作空间覆盖" class="headerlink" title="工作空间覆盖"></a>工作空间覆盖</h2><h2 id="节点名称"><a href="#节点名称" class="headerlink" title="节点名称"></a>节点名称</h2><h2 id="话题名称"><a href="#话题名称" class="headerlink" title="话题名称"></a>话题名称</h2><h2 id="参数名称"><a href="#参数名称" class="headerlink" title="参数名称"></a>参数名称</h2><h2 id="分布式通信"><a href="#分布式通信" class="headerlink" title="分布式通信"></a>分布式通信</h2>]]></content>
    
    
    
    <tags>
      
      <tag>ROS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自然语言处理学习笔记</title>
    <link href="/2022/04/18/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/18/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前预训练时代的自监督学习"><a href="#前预训练时代的自监督学习" class="headerlink" title="前预训练时代的自监督学习"></a>前预训练时代的自监督学习</h1><ul><li><p>语言单元表征</p><ul><li>独热码：特征稀疏(维度：词表大小)、词之间相互独立，没有顺序关系、不能表征词与词之间的关系，one-hot之间正交</li><li>Embedding编码：特征稠密（将one-hot线性映射到低维空间）、能够表征词与词之间的相互关系（相似度计算）、泛化性更好，支持语义运算</li></ul></li><li><p>词向量模型word2vec</p><ul><li><p>skip-gram</p><p><img src="https://s2.loli.net/2022/05/18/o1qmukHQ5bpCDde.png" alt=""></p></li><li><p>CBow（Continuous Bag-of-Words）</p><p><img src="https://s2.loli.net/2022/05/18/3lSEZHQL5I2WsuV.png" alt="image-20220518141830083"></p></li></ul></li><li><p>句子，编码神经网络</p><ul><li><p>自回归语言模型（n-gram语言模型）<br>马尔科夫假设：当前词只和前n-1个词有关</p><p><img src="https://s2.loli.net/2022/05/18/2RiN5sY6Shg1fA3.png" alt="image-20220518142413292"></p></li><li><p>循环神经网络（RNN，Recurrent Neural Network）递归的本质，timestep无法并行、存在梯度消失/爆炸的风险（gate机制，梯度剪切阈值）、长距离依赖容易产生遗忘</p><p><img src="https://s2.loli.net/2022/05/18/rElUau6qKFGMS87.png" alt="image-20220518142429627"></p></li><li><p>Self-Attention，既能做到并行，又能做到常数复时间的长距离依赖</p><p><img src="https://s2.loli.net/2022/05/18/faPRb7xLI4cs3Wi.png" alt="image-20220518142458531"></p></li><li><p>Transformer Encoder（加上多头的Self-Attention）</p><p><img src="https://s2.loli.net/2022/05/18/h8WJaoTfIXLpszE.png" alt="image-20220518142543316"></p><p><img src="https://s2.loli.net/2022/05/18/JbDHUftEqgaAZuY.png" alt="image-20220518142652100"></p></li></ul></li><li><p>代表性模型</p><p><img src="https://s2.loli.net/2022/05/18/NhsOYKRSomVAIMU.png" alt="image-20220518142802061"></p><p><img src="https://s2.loli.net/2022/05/18/TQVaMGchXlwyRgi.png" alt="image-20220518142820614"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>课外学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>人工智能</tag>
      
      <tag>自然语言处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《人工智能控制》笔记</title>
    <link href="/2022/04/18/%E3%80%8A%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%8E%A7%E5%88%B6%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/18/%E3%80%8A%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%8E%A7%E5%88%B6%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>2022年春《人工智能控制》课程笔记</p><p>2022年4月20日</p><p>归纳：hjy，lcy</p><p>校对：swh</p></blockquote><h1 id="知识表示"><a href="#知识表示" class="headerlink" title="知识表示"></a>知识表示</h1><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><ul><li>具有相对正确性、不正确性、可表示性、可利用性</li><li>知识表示：将人类知识形式化或者模型化。知识表示是对知识的一种描述，或者说是一组约定，一种计算机可以接受的用于描述知识的数据结构</li></ul><h2 id="一阶谓词逻辑表示法"><a href="#一阶谓词逻辑表示法" class="headerlink" title="一阶谓词逻辑表示法"></a>一阶谓词逻辑表示法</h2><ul><li>命题：<strong>非真即假的陈述句</strong>（一个命题在不同条件下真值可能改变）</li><li>个体：可以是常量、变量、函数、谓词</li><li>谓词公式连接词：否定 $\neg$ 、析取 $\vee$ 、合取 $\wedge$ 、蕴含 $\rightarrow$ 、等价 $\leftrightarrow$</li><li>量词：全称量词 $\forall$ 、存在量词 $\exists$ ，（出现顺序将影响命题含义）</li><li>谓词公式：原子谓词公式的有限步套娃缝合</li><li>连接词和量词的优先级是如上出现的顺序由高到低</li><li>量词辖域：位于量词后面的单个谓词或者用括孤括起来的谓词公式</li><li>约束变元与自由变元：辖域内，与量词中同名的变元称为约束变元，不同名的变元称为自由变元</li><li>谓词公式在个体域上的解释：个体域中的实体对谓词演算表达式的每个常量、变量谓词和函数符号的指派，对于每一个解释，谓词公式都可以求出一个真值</li><li><p>永真、永假、可满足、不可满足</p><ul><li>如果谓词公式P对个体域D上的任何一个解释都取得真值T,则称P在D上是永真的；如果P在每个非空个体域上均永真，则称P永真</li><li>如果谓词公式P对个体域D上的任何一个解释都取得真值F,则称P在D上是永假的；如果P在每个非空个体域上均永假，则称P永假。</li><li>对于谓词公式P，如果至少存在一个解释使得P在此解释下的真值为T，则称P是可满足的，否则，不存在任何一个解释，则称P是不可满足的。</li></ul></li><li><p>常用推导：</p><ul><li><p>德摩根</p></li><li><p>蕴含转换：$P \rightarrow Q \Rightarrow \neg P \vee Q$</p></li><li>反证法：把结论取反，带入已知条件，推导出F</li></ul></li><li><p>特点</p><ul><li>优点：自然、精确、严密、容易实现</li><li>局限：不能表示不确定的知识、组合爆炸、效率低</li></ul></li></ul><h2 id="产生式表示法"><a href="#产生式表示法" class="headerlink" title="产生式表示法"></a>产生式表示法</h2><ul><li>产生式作用：<strong>通常用于表示事实</strong>、规则以及它们的不确定性度量，适合于表示事实性知识和规则性知识。</li><li>表示<ul><li>确定性规则知识：if P then Q</li><li>不确定性规则知识：if P then Q (alpha)</li><li>确定性事实性知识：(obj, key, value) (relation, obj1, obj2)</li><li>不确定性事实性知识：(obj, key, value, alpha) (relation, obj1, obj2, alpha)</li></ul></li><li>产生式与谓词逻辑中的蕴含式的区别<ul><li>除逻辑蕴含外，产生式还包括各种操作、规则、变换、算子、函数等。例如，<code>如果炉温超过上限，则立即关闭风门</code> 是一个产生式（关联），但不是蕴含式（因果）。</li><li>蕴含式只能表示精确知识，而产生式不仅可以表示精确的知识，还可以表示不精确知识。蕴含式的匹配总要求是精确的。产生式匹配可以是精确的，也可以是不精确的，只要按某种算法求出的相似度落在预先指定范围内就认为是可匹配的。</li></ul></li><li>特点<ul><li>优点：自然、模块、有效、清晰</li><li>局限：效率不高、不能表达结构性知识</li><li>适用：知识不存在结构关系，知识是经验性的、不确定的，没有统一理论的、求解过程可被表示为一系列相对独立的操作，且每个操作可被表示为产生式规则</li></ul></li></ul><h2 id="框架表示法"><a href="#框架表示法" class="headerlink" title="框架表示法"></a>框架表示法</h2><ul><li>框架：一种描述所论对象（一个事物、事件或概念)，属性的数据结构。</li><li>一个框架由若干个槽组成，每一个槽又可分为侧面。</li><li>一个槽用于描述所论对象某一方面的属性。一个侧面用于描述相应属性的一个方面。</li><li>槽和侧面所具有的属性值分别被称为槽值和侧面值。</li><li>特点：结构性、继承性、自然性</li></ul><h1 id="确定性推理方法"><a href="#确定性推理方法" class="headerlink" title="确定性推理方法"></a>确定性推理方法</h1><h2 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h2><ul><li>演绎推理：一般到个别（三段论）</li><li>归纳推理：个别到一般（完全归纳、不完全归纳）</li><li>默认推理</li><li>确定性推理：知识证据确定、推出结论确定</li><li>不确定性推理：知识证据不确定、推出结论不确定（似然推理：概率论、模糊推理：模糊逻辑）</li><li>单调推理、非单调推理</li><li>启发式推理、非启发式推理</li><li>推理方向<ul><li>正向推理：事实驱动推理，已知事实到结论，简单易实现，目的性不强，效率低</li><li>逆向推理：目标驱动推理，以某个假设目标作为出发点，不必使用和目标无关的知识，目的性强，有利于向用户提供解释，但是起始目标的选择具有盲目性，比较复杂</li><li>混合推理：先正后反，先反后正</li><li>双向推理：同时进行到中间的结论</li></ul></li><li>冲突消解策略：排序，按照针对性、事实新鲜性、匹配度、条件个数划分优先级</li></ul><h2 id="自然演绎推理"><a href="#自然演绎推理" class="headerlink" title="自然演绎推理"></a>自然演绎推理</h2><ul><li>自然演绎推理：从一组已知为真的事实出发，运用经典逻辑的推理规则推出结论的过程。（P规则、T规则、<strong>假言推理</strong>、拒取式推理）（其实直接记住P→Q的真值表就行，不过考试只考假言推理）<ul><li>假言：$P \rightarrow Q ,  P\Rightarrow  Q $</li><li>拒取：$P \rightarrow Q ,  \neg Q \Rightarrow  \neg P $</li></ul></li><li>常见错误<ul><li>否定前件：<script type="math/tex">P \rightarrow Q , \neg P\Rightarrow  \neg Q (\cross)</script></li><li>肯定后件：$P \rightarrow Q , Q \Rightarrow  P (\cross)$</li></ul></li><li>特点<ul><li>优点：表达定理证明过程自然，易理解。拥有丰富的推理规则，推理过程灵活。便于嵌入领域启发式知识。</li><li>缺点：易产生组合爆炸，得到的中间结论一般呈指数形式递增。</li></ul></li></ul><h2 id="题目：谓词公式转化子句集"><a href="#题目：谓词公式转化子句集" class="headerlink" title="题目：谓词公式转化子句集"></a>题目：谓词公式转化子句集</h2><ul><li>定义：原子谓词公式（不可分解的命题）、文字（原子及其否定）、子句（<strong>文字的析取式</strong>）（离散中的主析取范式）、空子句NIL、子句集合</li><li><strong><em>▲谓词公式转化子句集解题步骤</em></strong><ol><li>使用公式消去 $\rightarrow $ 和 $\leftrightarrow $ 符号</li><li>否定后移，把 $\neg$ 移动到紧靠谓词的位置</li><li>变量标准化，在不同辖域的时候用了同一个自变量符号需要换一个</li><li>消除 $\exists$ ，用 $x$ 的函数代替（用出现在 $\exists$ 左边的所有的 $\forall$ 中的变量代替，因此可能是多元函数，如果没有，就写为常量）</li><li>化为前束型 <code>(前缀)&#123;母式&#125;</code> ，前缀是全称量词串，母式是不含量词的谓词公式</li><li>化为 Skolem 标准型 $\left(\forall x<em>{1}\right)\left(\forall x</em>{2}\right) \cdots\left(\forall x_{n}\right) M$ ，这里要用的又是<strong>合取范式</strong></li><li>省略 $\forall$</li><li>省略 $\wedge$，也就是写成<strong>合取范式每个项的集合</strong>形式</li><li>子句变量标准化，也就是每个子句使用不同的自变量</li></ol></li></ul><blockquote><p><strong>例题</strong></p><p>将下列谓词公式化为子句集</p><script type="math/tex; mode=display">(\forall x)\{[\neg P(x) \vee \neg Q(x)] \rightarrow(\exists y)[S(x, y) \wedge Q(x)]\} \wedge(\forall x)[P(x) \vee B(x)]</script><p><strong>解答</strong></p><script type="math/tex; mode=display">(\forall x)\{\underline{[\neg P(x) \vee \neg Q(x)] \rightarrow(\exists y)[S(x, y) \wedge Q(x)]}\} \wedge(\forall x)[P(x) \vee B(x)] \\ (\forall x)\{\underline{\neg[\neg P(x) \vee \neg Q(x)]} \vee(\exists y)[S(x, y) \wedge Q(x)]\} \wedge(\forall x)[P(x) \vee B(x)] \\ (\forall x)\{[P(x) \wedge Q(x)] \vee(\exists y)[S(x, y) \wedge Q(x)]\} \wedge\underline{(\forall x)}[P(\underline{x}) \vee B(\underline{x})]\\ (\forall x)\{[P(x) \wedge Q(x)] \vee\underline{(\exists y)}[S(x, \underline{y}) \wedge Q(x)]\} \wedge(\forall w)[P(w) \vee B(w)] \\ \underline{(\forall x)}\{[P(x) \wedge Q(x)] \vee[S(x, f(x)) \wedge Q(x)]\} \wedge \underline{(\forall w)}[P(w) \vee B(w)]\\(\forall x)(\forall w)\{\{[P(x) \wedge \underline{Q(x)}] \vee[S(x, f(x)) \wedge \underline{Q(x)}]\} \wedge[P(w) \vee B(w)]\}\\\underline{(\forall x)(\forall w)}\{Q(x) \wedge[P(x) \vee S(x, f(x))] \wedge[P(w) \vee B(w)]\}\\Q(x) \underline{\wedge}[P(x) \vee S(x, f(x))] \underline{\wedge}[P(w) \vee B(w)]\\\{Q(x), P(x) \vee S(\underline{x}, f(\underline{x})), P(w) \vee B(w)\}\\子句集 = \{Q(x), P(y) \vee S(y, f(y)), P(w) \vee B(w)\}</script><p><strong>例题与解答</strong></p><p><img src="https://s2.loli.net/2022/05/17/HtEvuMAXgojGYUZ.png" alt="image-20220517183939934" style="zoom: 80%;" /></p></blockquote><h2 id="鲁宾逊归结原理"><a href="#鲁宾逊归结原理" class="headerlink" title="鲁宾逊归结原理"></a>鲁宾逊归结原理</h2><ul><li><p>谓词公式不可满足的充要条件：其子句集不可满足</p></li><li><p>子句集中子句之间是<strong>合取</strong>关系，只要有一个子句不可满足，则子句集就不可满足</p></li><li><p>鲁宾逊归结原理的基本思想：检查子句集中是否包含空子句，若包含，则子句集不可满足。若不包含，在子句集中选择合适的子句进行归结，一旦归结出空子句，就说明子句集是不可满足的</p></li><li><p>归结：设 $C<em>{1}$ 与 $C</em>{2}$ 是子句集中的任意两个子句，如果 $C<em>{1}$ 中的文字 $L</em>{1}$ 与 $C<em>{2}$ 中的文字 $L</em>{2}$ 互补, 那么从 $C<em>{1}$ 和 $C</em>{2}$ 中分别消去 $L<em>{1}$ 和 $L</em>{2}$ ，并将二个子句中余下的部分<strong>析取</strong>，构成新子句 $C_{12}$ 。</p></li><li><p>亲本子句为真，则归结的式子也为真</p></li><li><p>新推导的子句代替被推导的子句后加入原子句集，则新子句集的不可满足性可以推出原子句集的不可满足性</p></li><li><p>新推导的子句加入原子句集，则新子句集的不可满足性和原子句集的不可满足性等价</p></li><li><p>含有变量的子句的归结（归结前，两个子句集的同一个参数名仍需改为不一样的）</p><script type="math/tex; mode=display">C_{1}=P(x) \vee Q(a), C_{2}=\neg P(b) \vee R(x)\\令 C_{2}=\neg P(b) \vee R(y), \sigma=\{b / x\}\\ \rightarrowC_{1} \sigma=P(b) \vee Q(a), C_{2} \sigma=\neg P(b) \vee R(y)\\\rightarrow C_{12}=Q(a) \vee R(y)</script></li><li><p>对于谓词逻辑，归结式是其亲本子句的逻辑结论</p></li><li><p>对于一阶谓词逻辑，即若子句集是不可满足的，则必存在一个从该子句集到空子句的归结演绎；若从子句集存在一个到空子句的演绎，则该子句集是不可满足的。</p></li><li><p><strong>如果没有归结出空子句，则既不能子句集说不可满足，也不能说子句集是可满足的</strong></p></li></ul><h2 id="题目：归结反演"><a href="#题目：归结反演" class="headerlink" title="题目：归结反演"></a>题目：归结反演</h2><ul><li>归结反演：应用归结原理证明定理的过程</li><li><strong><em>▲归结反演证明题步骤</em></strong><ol><li>将已知前提表示为谓词公式 $F$。</li><li>将待证明的结论表示为谓词公式 $Q$ ，并否定得到 $\neg Q$ 。</li><li>把谓词公式集 ${F, \neg Q}$ 化为子句集 $S$ 。</li><li>应用归结原理对子句集 $S$ 中的子句进行归结，并把每次归结得到的归结式都并入到 $S$ 中。反复进行，若出现了空子句，则停止归结，此时就证明了 $Q$ 为真。</li></ol></li></ul><blockquote><p><strong>例题</strong></p><p>已知：任何人的兄弟不是女性；任何人的姐妹必是女性。<br>事实：Mary 是 Bill 的姐妹。<br>求证：Mary 不是 Tom 的兄弟。</p><p><strong>解答</strong></p><p>定义谓词</p><p>$brother(x,y)$  $x$ 是 $y$ 的兄弟<br>$sister(x,y)$  $x$ 是 $y$ 的姐妹<br>$woman(x)$  $x$ 是女性</p><p>使用谓词公式表示出已知规则和结论的否定</p><script type="math/tex; mode=display">(\forall x)(\forall y)(  brother  (x, y) \rightarrow \neg  woman  (x)) \\(\forall x)(\forall y)({sister}(x, y) \rightarrow  woman  (x)) \\ sister (Mary, Bill)\\ brother(Mary, Tom)</script><p>公式转换为子句集</p><script type="math/tex; mode=display">\begin{array}{l}(1): \neg  brother (x, y) \vee \neg  woman (x) \\(2): \neg sister(x, y) \vee woman (x) \\(3): sister( Mary, Bill) \\(4): brother(Mary ,  Tom )\end{array}</script><p>选择合适的步骤归结子句集到空子句（先归结1和2不能得到空子句）</p><script type="math/tex; mode=display">\begin{array}{l}(5):Lwoman ( Mary )  && (1)(3)\\(6):\neg brother ( Mary, y) &&(4)(5)\\(7):NIL  && (2)(6)\end{array}</script></blockquote><ul><li><strong><em>▲归结反演应用题步骤</em></strong><ol><li>将已知前提表示为谓词公式 $F$。</li><li>将待求解的结论表示为 $Q$ ，否定得到$\neg Q$ ，与 $ANSWER$ 构成析取式 $\neg Q \vee ANSWER$。</li><li>把谓词公式集 ${ F,  \neg Q \vee ANSWER }$ 化为子句集 $S$ 。</li><li>应用归结原理对 $S$ 中子句进行归结，并把每次归结得到的归结式都并入到 $S$ 中。反复进行，若得到归结式 $ANSWER$ ，则答案就在 $ANSWER$  中。</li></ol></li></ul><blockquote><p><strong>例题</strong></p><p>已知：老王是小李的老师。小李与小张是同班同学。如果 $x$ 与 $y$ 是同班同学，则 $x$ 的老师也是 $y$ 的老师。</p><p>求解：小张的老师是谁。</p><p><strong>解答</strong></p><p>定义谓词</p><p>$T(x,y)$  $x$ 是 $y$ 的老师<br>$C(x,y)$  $x$ 与 $y$ 是同班同学</p><p>使用谓词公式表示出已知规则，以及待求解的结论与答案的析取式</p><script type="math/tex; mode=display">T(Wang,Li ) \\C( Li,Zhang ) \\(\forall x)(\forall y)(\forall z)(C(x, y) \wedge T(z, x) \rightarrow T(z, y)) \\\neg(\exists x) T(x,  Zhang ) \vee ANSWER(x)</script><p>公式转换为子句集</p><script type="math/tex; mode=display">\begin{array}{l}(1): T(Wang, Li)\\ (2):C(  Li,Zhang  ) \\ (3):\neg C(x, y) \vee \neg T(z, x) \vee T(z, y)\\ (4):\neg T(u , Zhang) \vee ANSWER(u)\end{array}</script><p>应用归结原理进行归结</p><script type="math/tex; mode=display">\begin{array}{l}(5): \neg C(  Li,  y) \vee T  (Wang, y) &&(1)(3) \\(6): \neg C(  Li, Zhang  ) \vee ANSWER (Wang) &&(4)(5) \\(7): ANSWER(Wang)&&(2)(6)\end{array}</script></blockquote><h1 id="不确定性推理方法"><a href="#不确定性推理方法" class="headerlink" title="不确定性推理方法"></a>不确定性推理方法</h1><h2 id="不确定推理"><a href="#不确定推理" class="headerlink" title="不确定推理"></a>不确定推理</h2><ul><li>不确定性推理：从不确定性的初始证据出发，通过运用不确定性的知识，最终推出具有一定程度的不确定性但却是合理或者近乎合理的结论的思维过程。</li><li>不确定性<ul><li>知识的不确定性（静态强度）</li><li>证据的不确定性（动态强度，初始证据和推导出的结论作为证据）</li></ul></li></ul><h2 id="可信度方法"><a href="#可信度方法" class="headerlink" title="可信度方法"></a>可信度方法</h2><ul><li><p>可信度：根据经验对一个事物或现象为真的相信程度。可信度带有较大的主观性和经验性，其准确性难以把握。</p></li><li><p>C-F模型：基于可信度表示的不确定性推理的基本方法</p></li><li><p><strong>▲不确定性的表示</strong></p><ul><li><p>知识的不确定性 CF(H,E)</p><ul><li>IF E THEN H(CF(H,E))</li><li>CF：可信度因子，CF(H,E)反映前提条件E和结论H的联系强度，$CF \in [-1,1]$</li><li>若由于相应证据的出现增加结论H为真的可信度，则 $CF(H,E) &gt; 0 $ ,证据的出现越是支持H为真，就使 $CF(H,E) $ 的值越大。</li><li>反之， $CF(H,E) &lt; 0 $ ，证据的出现越是支持H为假， $CF(H,E) $ 的值就越小。</li><li>如果证据E的出现和结论H无关，则 $CF(H,E) = 0$</li></ul></li><li><p>证据的不确定性 CF(E)</p><ul><li>证据E的可信度取值范围 $CF \in [-1,1]$</li><li>对于初始证据，若所有观察S能肯定它为真，则 $CF(E) = 1$</li><li>若肯定它为假，则 $CF(E) = -1$</li><li>若以某种程度为真，则 $0 &lt; CF(E) &lt; 1$，若以某种程度为假，则 $-1 &lt; CF(E) &lt; 0$</li><li>若未获得任何相关的观察，则 $CF(E) = 0$</li></ul></li></ul></li><li><p><strong><em>▲不确定性的计算</em></strong></p><ul><li><p><strong>组合证据的不确定算法</strong>(最大最小法)</p><ul><li>合取$\and$：$CF(E) = \min { CF(E_1),CF(E_1),…,CF(E_n)}$</li><li>析取$\or$：$CF(E) = \max { CF(E_1),CF(E_1),…,CF(E_n)}$</li></ul></li><li><p><strong>不确定性的传递算法</strong></p><ul><li>$CF(H)=CF(H, E) \cdot \max {0, CF(E)}$</li></ul></li><li><p><strong>结论不确定性的合成算法</strong></p><ul><li><p>已知<br>IF $E_1$ THEN H (CF(H,$E_1$))<br>IF $E_2$ THEN H (CF(H,$E_2$))</p></li><li><p>先对每一条知识求出 $CF(H)$<br>$CF_1(H)=CF(H, E_1) \cdot \max {0, CF(E_1)}$<br>$CF_2(H)=CF(H, E_2) \cdot \max {0, CF(E_2)}$</p></li><li><p>再求出 $E<em>1$ 和 $E_2$ 综合影响形成的可信度 $CF</em>{1,2}(H)$</p><script type="math/tex; mode=display">C F_{1,2}(H)=\left\{\begin{array}{ccc}C F_{1}(H)+C F_{2}(H)-C F_{1}(H) C F_{2}(H) & \text { 若 } C F_{1}(H) \geqslant 0,  C F_{2}(H) \geqslant 0 \\C F_{1}(H)+C F_{2}(H)+C F_{1}(H) C F_{2}(H) & \text { 若 } C F_{1}(H)<0,  C F_{2}(H)<0 \\\frac{C F_{1}(H)+C F_{2}(H)}{1-\min \left\{\left|C F_{1}(H)\right|,\left|C F_{2}(H)\right|\right\}} & \text { 若 } C F_{1}(H) \text { 与 }  C F_{2}(H) \text { 异号 }\end{array}\right.</script></li></ul></li></ul></li></ul><blockquote><p><strong>例题</strong></p><p>IF $E_1$ THEN H (0.8)<br>IF $E_2$ THEN H (0.6)<br>IF $E_3$ THEN H (-0.5)<br>IF $E_4$ AND ( $E_5$ OR $E_6$ ) THEN $E_1$ (0.7)<br>IF $E_7$ AND $E_8$ THEN $E_3$ (0.9) </p><p>$CF(E_2)=0.8,CF(E_4)=0.5,CF(E_5)=0.6$<br>$CF(E_6)=0.7,CF(E_7)=0.6,CF(E_8)=0.9$</p><p>求 $CF(H)$</p><p><strong>解答</strong></p><p>求组合证据的不确定性</p><script type="math/tex; mode=display">\begin{array}{l}CF(E_4 \enspace AND  \enspace( E_5 \enspace OR \enspace E_6)) = \min \{0.5, \max \{ 0.6, 0.7\}\} = 0.5 \\CF(E_7 \enspace AND \enspace E_8) = \min \{0.6, 0.9\} = 0.6 \\\end{array}</script><p>求非最终结果（临时结论）的传递不确定性</p><script type="math/tex; mode=display">\begin{array}{l}CF(E_1) = 0.7 \cdot \max \{0, CF(E_4 \enspace AND  \enspace( E_5 \enspace OR \enspace E_6)\} = 0.7 \cdot 0.5 = 0.35 \\CF(E_3) = 0.9 \cdot \max \{0, CF(E_7 \enspace AND \enspace E_8)\} = 0.9 \cdot 0.6 = 0.54 \\\end{array}</script><p>求最终结果的分结论不确定性</p><script type="math/tex; mode=display">\begin{array}{l}CF_1(H) = 0.8 \cdot \max \{0, CF(E_1)\} = 0.28 \\CF_2(H) = 0.6 \cdot \max \{0, CF(E_2)\} = 0.48 \\CF_3(H) = -0.5 \cdot \max \{0, CF(E_3)\} = -0.27\end{array}</script><p>求分结论合成后的不确定性</p><script type="math/tex; mode=display">\begin{aligned}C F_{1,2}(H) &=C F_{1}(H)+C F_{2}(H)-C F_{1}(H) \times C F_{2}(H) \\&=0.28+0.48-0.28 \times 0.48=0.63 \\C F_{1,2,3}(H) &=\frac{C F_{1,2}(H)+C F_{3}(H)}{1-\min \left\{\left|C F_{1,2}(H)\right|,\left|C F_{3}(H)\right|\right\}} \\&=\frac{0.63-0.27}{1-\min \{0.63,0.27\}}=\frac{0.36}{0.73}=0.49\end{aligned}</script></blockquote><h2 id="证据理论"><a href="#证据理论" class="headerlink" title="证据理论"></a>证据理论</h2><ul><li><p>样本空间：设D是变量x所有可能取值的集合，且D中的元素是互斥的，在任一时刻x都取且只能取D中的某一个元素为值，则称D为x的样本空间。</p></li><li><p><strong>概率分配函数</strong>：函数 $ M: 2^{D} \rightarrow[0,1]$ ，且满足如下划分条件</p><script type="math/tex; mode=display">1 = \sum_{A \subseteq D} M(A), M(\Phi)=0</script><p>则  $M: 2^{D}$  上的基本概率分配函数,  $M(A): A$ 的基本概率数</p><ul><li>$M(A)$ 为命题A的精确信任度</li><li>概率分配函数和概率是不同的：对于概率分配函数，D的幂集所有元素的函数之和为1；对于概率，D所有元素的函数之和为1）</li></ul></li><li><p><strong>概率分配函数的正交和计算（证据的组合）</strong> </p><script type="math/tex; mode=display">M=M_1 \oplus   M_2 \\M(\varnothing) = 0 \\其中 M(A)= K^{-1} \cdot \sum_{x \cap y = A} M_1(x)M_2(y)= \frac {\sum_{x \cap y = A} M_1(x)M_2(y)}{1-\sum_{x \cap y = \varnothing} M_1(x)M_2(y)}  \\K = 1 - \sum_{x \cap y = \varnothing}M_1(x)M_2(y) = \sum_{x \cap y \neq \varnothing}M_1(x)M_2(y) \\</script><ul><li>$K$ 称为归一化因子，反映证据的冲突程度，如果 $K \neq 0$，则正交和也是一个概率分配函数；如果 $K = 0$，则不存在正交和，得到 $M_1 $ 和 $  M_2$ 矛盾</li><li>计算 $\sum_{x \cap y = A} M_1(x)M_2(y)$ 时，注意 $x$ 和 $y$ 是可以相等的</li></ul></li><li><p><strong>信任函数</strong>：函数 $Bel: 2^{D} \rightarrow[0,1]$ ，且满足如下划分条件</p><script type="math/tex; mode=display">Bel(A) = \sum_{B \subseteq A} M(B) , \forall A \subseteq D</script><ul><li>$Bel(A)$ 为命题A的<strong>真的</strong>总的信任度，是信任度<strong>下限</strong></li></ul></li><li><p><strong>似然函数</strong>：函数 $Pl: 2^{D} \rightarrow[0,1]$ ，且满足如下转换条件</p><script type="math/tex; mode=display">Pl(A)=1-Bel(\neg A), \forall A \subseteq D</script><ul><li>$Pl(A)$ 为命题A的<strong>非假</strong>的信任度，为信任度<strong>上限</strong></li></ul></li><li><p><strong><em>▲基于证据理论的不确定性推理的步骤</em></strong></p><ol><li>建立问题的样本空间D</li><li>分别计算两个证据的概率分配函数</li><li>计算组合概率分配函数</li><li>计算信任函数（下限）</li><li>计算似然函数（上限）</li><li>得出结论</li></ol></li></ul><blockquote><p><strong>例题</strong></p><p>设有规则</p><p>IF 流鼻涕 THEN 感冒但非过敏性鼻炎(0.9) OR 过敏性鼻炎但非感冒(0.1)<br>IF 眼发炎 THEN 感冒但非过敏性鼻炎(0.8) OR 过敏性鼻炎但非感冒(0.05)</p><p>又有事实</p><p>小王流鼻涕(0.9)<br>小王眼发炎(0.4)</p><p>求解小王患的什么病</p><p><strong>解答</strong></p><ol><li>建立假设结果（患病情况）的<strong>样本空间</strong></li></ol><script type="math/tex; mode=display">D = \{A,B\} \\M = \{\{A\},\{B\},\{A,B\},\varnothing\} \\A: 感冒 \\B：过敏性鼻炎</script><ol><li>分别计算两个证据的<strong>基本概率分配函数</strong></li></ol><ul><li>小王流鼻涕(0.9)时，计算 $M_1$</li></ul><script type="math/tex; mode=display">\begin{array}{l}M_1(\varnothing) = 0 \\M_1(A) = 0.9\times 0.9 = 0.81 \\M_1(B) = 0.9\times 0.1 = 0.09 \\M_1(AB) =   1 - M_1(A) - M_1(B) = 0.1 \\M_1(\{A\},\{B\},\{A,B\},\{\varnothing\}) =   (0.81,0.09,0.1,0)\end{array}</script><ul><li>小王眼发炎(0.4)时，计算 $M_2$</li></ul><script type="math/tex; mode=display">\begin{array}{l}M_2(\varnothing) = 0 \\M_2(A) = 0.4\times 0.8 = 0.32 \\M_2(B) = 0.4\times 0.05 = 0.02 \\M_2(AB) =  1 - M_1(A) - M_1(B) = 0.66 \\M_2(\{A\},\{B\},\{A,B\},\{\varnothing\}) =   (0.32,0.02,0.66,0)\end{array}</script><ol><li>计算<strong>组合概率分配函数</strong></li></ol><ul><li>先计算 $K$</li></ul><script type="math/tex; mode=display">\begin{array}{l}K\\= 1 - \sum_{x \cap y = \varnothing}M_1(x)M_2(y)\\=1 - [M_1(\{A\})M_2(\{B\}) + M_1(\{B\})M_2(\{A\})] \\= 1 - [0.81\times0.02 + 0.09\times0.32] = 0.955\end{array}</script><ul><li>流鼻涕的组合概率分配函数 <strong>0.87</strong></li></ul><script type="math/tex; mode=display">\begin{array}{l}M(A) \\= K^{-1}\sum_{x \cap y = A}M_1(x)M_2(y) \\= K^{-1}[M_1(\{A\})M_2(\{A\}) + M_1(\{A\})M_2(\{A,B\}) + M_1(\{A,B\})M_2(\{A\})] \\= \frac{1}{0.955} \times 0.8258 = 0.87\end{array}</script><ul><li>眼发炎的组合概率分配函数 <strong>0.066</strong></li></ul><script type="math/tex; mode=display">\begin{array}{l}M(B) \\= K^{-1}\sum_{x \cap y = B}M_1(x)M_2(y) \\= K^{-1}[M_1(\{B\})M_2(\{B\}) + M_1(\{B\})M_2(\{A,B\}) + M_1(\{A,B\})M_2(\{B\})] \\= \frac{1}{0.955} \times 0.0632 = 0.066\end{array}</script><ol><li>计算<strong>信任函数（下限）</strong> <strong>0.87</strong> 和 <strong>0.066</strong></li></ol><script type="math/tex; mode=display">Bel(A) = \sum_{B \subseteq A} M(B) , \forall A \subseteq D</script><script type="math/tex; mode=display">\begin{array}{l}Bel(\varnothing) = 0 \\Bel(A) = M(\varnothing) + M(A) = 0.87 \\Bel(B) = M(\varnothing) + M(B) = 0.066 \\Bel(AB) = M(\varnothing) + M(A)  + M(B)  = 0.064\end{array}</script><ol><li>计算<strong>似然函数（上限）</strong> <strong>0.934</strong> 和 <strong>0.13</strong></li></ol><script type="math/tex; mode=display">Pl(A)=1-Bel(\neg A), \forall A \subseteq D</script><script type="math/tex; mode=display">\begin{array}{l}Pl(A) \\= 1 - Bel(\neg A) \\= 1 - [Bel(B) + Bel(\varnothing)] \\= 1- [0.066 + 0] = 0.934 \\\\Pl(B) \\= 1 - Bel(\neg B) \\= 1 - [Bel(A) + Bel(\varnothing)] \\= 1- [0.87 + 0] = 0.13\end{array}</script><ol><li>由信任函数值、似然函数值<strong>得出结论</strong><br>感冒<strong>为真</strong>的信任度0.87 ，<strong>非假</strong>的信任度0.934<br>过敏性鼻炎<strong>为真</strong>的信任度0.066，<strong>非假</strong>的信任度0.13<br>小王大概率为<strong>感冒</strong></li></ol></blockquote><h2 id="模糊推理方法"><a href="#模糊推理方法" class="headerlink" title="模糊推理方法"></a>模糊推理方法</h2><ul><li><p>论域：所讨论的全体对象，用U等表示。</p></li><li><p>元素：论域中的每个对象，常用a,b,c,x,y,z表示。</p></li><li><p>集合：论域中具有某种相同属性的确定的、可以彼此区别的元<br>素的全体，常用A,B等表示。</p></li><li><p>元素a和集合A的关系：a属于A或a不属于A</p></li><li><p>模糊逻辑给集合中每一个元素赋予一个介于0和1之间的实数，描述其属于一个集合的强度，该实数称为元素属于一个集合的隶属度。集合中所有元素的隶属度全体构成集合的隶属函数</p></li><li><p>表示方法：Zadeh、序偶、向量</p><script type="math/tex; mode=display">A=\left\{\mu_{A}\left(x_{1}\right) / x_{1}, \mu_{A}\left(x_{2}\right) / x_{2}, \cdots, \mu_{A}\left(x_{n}\right) / x_{n}\right\} \\A=\int_{x \in U} \mu_{A}(x) / x</script></li><li><p>隶属函数</p></li><li>模糊集合运算</li></ul><script type="math/tex; mode=display">\begin{array}{l}\mu_{A \cap B}(x)=\min \left\{\mu_{A}(x), \mu_{B}(x)\right\}=\mu_{A}(x) \wedge \mu_{B}(x) \\\mu_{A \cup B}(x)=\max \left\{\mu_{A}(x), \mu_{B}(x)\right\}=\mu_{A}(x) \vee \mu_{B}(x) \\\mu_{\overline{A} }(x)=1-\mu_{A}(x) \\\\\mu_{A B}(x)=\mu_{A}(x) \mu_{B}(x) \\\mu_{A+B}(x)=\mu_{A}(x)+\mu_{B}(x)-\mu_{A}(x) \mu_{B}(x) \\\mu_{A \oplus B}(x)=\min \left\{1, \mu_{A}(x)+\mu_{B}(x)\right\}=1 \wedge\left[\mu_{A}(x)+\mu_{B}(x)\right] \\\mu_{A \otimes B}(x)=\max \left\{0, \mu_{A}(x)+\mu_{B}(x)-1\right\}=0 \vee\left[\mu_{A}(x)+\mu_{B}(x)-1\right]\end{array}</script><ul><li>模糊关系运算：模糊关系使用叉积表示 （用$\wedge$，不是数字相乘）</li></ul><script type="math/tex; mode=display">R: A \times B \rightarrow[0,1] \\R =  \mu_{A \times B}(a, b)=\mu_{A}^{T} \circ \mu_{B}</script><ul><li>模糊推理</li></ul><script type="math/tex; mode=display">A \circ B=\vee_{k=1}^{l}\left(a_{i k} \wedge b_{k j}\right)\\ B'=A' \circ R</script><ul><li>模糊决策<ul><li>最大隶属度法（maxarg）</li><li>加权平均法</li><li>中位数法<br>直接相等时 $ sum(list[:j+1]) == sum(list[j+1:])$ 取 $u=j$<br>否则找到最后一个 $ sum(list[:j+1]) &lt; sum(list[j+1:])$ ，令 $u=j+sum(list[j+1:])/sum(list)$</li></ul></li></ul><h2 id="题目：模糊推理应用"><a href="#题目：模糊推理应用" class="headerlink" title="题目：模糊推理应用"></a>题目：模糊推理应用</h2><ul><li><strong><em>▲求解模糊控制的度量步骤</em></strong><ol><li>模糊关系运算，求模糊关系</li><li>模糊推理，求输出</li><li>使用合适决策方法，求决策度量</li></ol></li></ul><blockquote><p><strong>例题</strong></p><p>已知：如果温度低，则将风门开大。</p><p>设温度和风门开度的论域为 ${1,2,3,4,5}$。<br>温度低=1/1+0.6/2+0.3/3+0.0/4+0/5<br>风门大=0/1+0.0/2+0.3/3+0.6/4+1/5</p><p>已知事实：温度较低=0.8/1+1/2+0.6/3+0.3/4+0/5<br>试用模糊推理确定风门开度。</p><p><strong>解答</strong></p><script type="math/tex; mode=display">R=\left[\begin{array}{l}1.0 \\0.6 \\0.3 \\0.0 \\0.0\end{array}\right] \circ\left[\begin{array}{lllll}0.0 & 0.0 & 0.3 & 0.6 & 1.0\end{array}\right]=\left[\begin{array}{ccccc}0.0 & 0.0 & 0.3 & 0.6 & 1.0 \\0.0 & 0.0 & 0.3 & 0.6 & 0.6 \\0.0 & 0.0 & 0.3 & 0.3 & 0.3 \\0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\0.0 & 0.0 & 0.0 & 0.0 & 0.0\end{array}\right] \\\\B^{\prime}=A^{\prime} \circ R=\left[\begin{array}{l}0.8 \\1.0 \\0.6 \\0.3 \\0.0\end{array}\right] \circ\left[\begin{array}{lllll}0.0 & 0.0 & 0.3 & 0.6 & 1.0 \\0.0 & 0.0 & 0.3 & 0.6 & 0.6 \\0.0 & 0.0 & 0.3 & 0.3 & 0.3 \\0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\0.0 & 0.0 & 0.0 & 0.0 & 0.0\end{array}\right] = (0.0,0.0,0.3,0.6,0.8)</script><p>用最大隶属度法进行决策得风门开度为5。<br>用加权平均判决法和中位数法进行决策得风门开度为4。</p></blockquote><h1 id="搜索求解策略"><a href="#搜索求解策略" class="headerlink" title="搜索求解策略"></a>搜索求解策略</h1><h2 id="搜索求解"><a href="#搜索求解" class="headerlink" title="搜索求解"></a>搜索求解</h2><ul><li><p>分类</p><ul><li><p>数据驱动、目的驱动、双向搜索</p></li><li><p>盲目搜索：在不具有对特定问题的任何有关信息的条件下，按固定的步骤（依次或随机调用操作算子）进行的搜索。</p></li><li>启发式搜索：考虑特定问题领域可应用的知识，动态地确定调用操作算子的步骤，优先选择较适合的操作算子，尽量减少不必要的搜索，以求尽快地到达结束状态。</li></ul></li><li><p>状态空间表示法</p><ul><li><p>状态：表示系统状态、事实等叙述型知识的一组变量或数组 $Q= [q_1,q_2,\dots,q_n]$</p></li><li><p>操作：表示引起状态变化的过程型知识的一组关系或函数 $F= {f_1,f_2,\dots,f_m}$</p></li><li><p>状态空间：利用状态变量和操作符号，表示系统或问题的有关知识的符号体系，状态空间是一个四元组</p><script type="math/tex; mode=display">(A,O,S_0,G) \\S: 状态集合 \\ O: 操作算子集合\\S_0: 包含问题的初始状态是S的非空子集\\G: 若干具体状态或满足某些性质的路径信息描述</script></li><li><p>求解路径：从 $S_0$ 结点到 $G$ 结点的路径</p></li><li><p>状态空间解：一个有限的操作算子序列</p></li></ul></li></ul><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><ul><li>回溯法原理：回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</li><li>回溯法步骤<ul><li>用未处理状态表（NPS）使算法能返回（回溯）到其中任一状态。 </li><li>用一张“死胡同”状态表（NSS）来避免算法重新搜索无解的路径。 </li><li>在PS 表中记录当前搜索路径的状态，当满足目的时可以将它作为结果返回。 </li><li>为避免陷入死循环必须对新生成的子状态进行检查，看它是否在该三张表中 。</li></ul></li></ul><ul><li><p>思想：<strong>回溯法解决的问题都可以抽象为树形结构</strong>，因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。递归就要有终止条件，所以必然是一棵高度有限的树（但是递归通常深度之深难以计算）。</p></li><li><p>回溯法解决的问题</p><ul><li><p>组合问题：N个数里面按一定规则找出k个数的集合</p></li><li><p>切割问题：一个字符串按一定规则有几种切割方式</p></li><li><p>子集问题：一个N个数的集合里有多少符合条件的子集</p></li><li><p>排列问题：N个数按一定规则全排列，有几种排列方式</p></li><li><p>棋盘问题：N皇后，解数独等等</p></li></ul></li><li><p>回溯搜索的算法</p><ul><li>PS(path states)表：保存当前搜索路径上的状态。如果找到了目的,PS就是解路径上的状态有序集。</li><li>NPS (new path states)表：新的路径状态表。它包含了等待搜索的状态，其后裔状态还未被搜索到,即未被生成扩展。</li><li>NSS (no solvable states) 表: 不可解状态集，列出了找不到解题路径的状态。如果在搜索中扩展出的状态是它的元素,则可立即将之排除,不必沿该状态继续搜索。</li></ul></li></ul><h2 id="宽度优先搜索（BFS）"><a href="#宽度优先搜索（BFS）" class="headerlink" title="宽度优先搜索（BFS）"></a>宽度优先搜索（BFS）</h2><ul><li>宽度优先搜索(breadth-first search，广度优先搜索)：以接近起始节点的程度（深度）为依据，进行逐层扩展的节点搜索方法。</li></ul><ul><li>open表（NPS表)：已经生成出来但其子状态未被搜索的状态。</li><li>closed表（ PS表和NSS表的合并）：记录了已被生成扩展过的状态。</li></ul><h2 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h2><p>深度优先搜索（Depth-first Search): 首先扩展最新产生的节点, 深度相等的节点按生成次序的盲目搜索。</p><ul><li>防止搜索过程沿着无益的路径扩展下去，往往给出一个节点扩展的最大深度——深度界限；</li><li>与宽度优先搜索算法最根本的不同：将扩展的后继节点放在OPEN表的前端。</li><li>深度优先搜索算法的OPEN表后进先出。</li></ul><h2 id="题目：01背包"><a href="#题目：01背包" class="headerlink" title="题目：01背包"></a>题目：01背包</h2><blockquote><p><strong>例题</strong></p><p>使用回溯法解0/1背包问题<br>$N=3, C=9, W={2,4,5}, V={6,10,7}$</p><p>其解向量x由长度为3的0-1向量组成，并画出其解空间树（从根出发，左1右0），计算其最优值及最优解。</p><p><strong>解答</strong></p><p>这个问题中每个物品要么装入，要么不装入（向左走加入，向右走不加入），其解空间是一棵<strong>子集树</strong>  ${x_1,x_2,x_3}, x_i = {0,1}$，有三层，每层代表每个物品的一个决策，树中每一个结点表示背包的一种选择状态，记录当前放入背包的总重量和总价值，每个分枝结点下面由两条边表示对某物品是否放入背包的两种可能的选择。</p><p><strong>过程</strong></p><p><img src="https://s2.loli.net/2022/04/20/dYNzTEh1PcAi9Za.png" alt="img"></p></blockquote><h2 id="题目：积木问题"><a href="#题目：积木问题" class="headerlink" title="题目：积木问题"></a>题目：积木问题</h2><blockquote><p><strong>例题</strong></p><p>通过搬动积木块，希望从初始状态达到一个目的状态，即三块积木堆叠在一起。</p><p><strong>要求</strong></p><p>算子MOVE（X，Y）的先决条件：</p><ol><li>被搬动积木顶必为空</li><li>若Y是积木，Y顶部也必须为空</li><li>同状态下操作算子运用次数不得多于1次</li></ol><p><strong>过程</strong></p><p><img src="https://s2.loli.net/2022/04/20/6Z4Qjdv51382Byn.png" alt="image-20220420150045744"></p><p>Open表：S6， S7 ， S8 ，S9 ， S10</p><p>Closed表：S0 ，S1 ，S2，S3 ，S4，S5</p><p>扩展节点数：6</p><p>生成节点数：10</p></blockquote><h2 id="题目：卒子穿阵"><a href="#题目：卒子穿阵" class="headerlink" title="题目：卒子穿阵"></a>题目：卒子穿阵</h2><blockquote><p><strong>题目</strong></p><p>要求一卒子从顶部通过下图所示的阵列到达底部。卒子行进中不可进入到代表敌兵驻守的区域（标注1），并不准后退。假定深度限制值为5。</p><div class="table-container"><table><thead><tr><th style="text-align:center">行\列</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th></tr></thead><tbody><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>2</strong></td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>3</strong></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center"><strong>4</strong></td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table></div><p><strong>步骤</strong></p><p>这里做以下规定</p><ul><li>从（1，n）出发，为不同出发点，（1，n）的下一个状态只能为（2，n）</li><li>（n,m）（n&gt;1）下一个状态优先级依次为： {（n+1,m）,(n,m-1),(n,m+1)}(不能后退)</li><li>遇到边缘和敌兵（1）状态为死</li><li>最大深度为5</li><li>如果求全部路径，直接在（1，n）状态之间平移转换。</li></ul><p><img src="https://lcypicgo.oss-cn-beijing.aliyuncs.com/img/202204191943510.png" style="zoom:50%;" /></p><p>如果不限制，maybe：</p><p>没有剪枝，大量冗余</p><p><img src="https://lcypicgo.oss-cn-beijing.aliyuncs.com/img/202204191936900.png" alt="" style="zoom:50%;" /></p><p>如果加上不可重复进入</p><p>maybe：</p><p><img src="https://lcypicgo.oss-cn-beijing.aliyuncs.com/img/202204191947515.png" style="zoom:50%;" /></p></blockquote><h2 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h2><ul><li><p>运用启发式策略的两种基本情况</p><ul><li>一个问题由于在问题陈述和数据获取方面固有的模糊性，可能会使它没有一个确定的解。</li><li>虽然一个问题可能有确定解，但是其状态空间特别大，搜<br>索中生成扩展的状态数会随着搜索的深度呈指数级增长。</li></ul></li><li><p>启发式信息：用来简化搜索过程有关具体问题领域的特性的信息叫做启发信息。</p></li><li><p>分类</p><ul><li>运用<ul><li>陈述性启发信息：用于更准确、更精炼地描述状态</li><li>过程性启发信息：用于构造操作算子</li><li>控制性启发信息：表示控制策略的知识</li></ul></li><li>作用<ul><li>用于扩展节点的选择，即用于决定应先扩展哪一个节点，以免盲目扩展。</li><li>用于生成节点的选择，即用于决定要生成哪些后继节点，以免盲目生成过多无用的节点。</li><li>用于删除节点的选择，即用于决定删除哪些无用节点，以免造成进一步的时空浪费。</li></ul></li></ul></li><li><p>估价函数：$ f(n)$  从初始节点经过n节点到达目标节点的路径的最小代价估计值，其一般形式是</p></li></ul><script type="math/tex; mode=display">f(n) = g(n)+h(n) \\ g(n)：从初始节点 S0 到节点 n 的实际代价 \\ h(n)：从节点 n 到目标节点 S_g 的最优路径的估计代价，称为启发函数。</script><ul><li>估价函数的任务就是估计待搜索结点的“有希望”程度，并依次给它们排定次序（在open表中）</li></ul><h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><ol><li><p>用状态空间法表示问题时,什么是问题的解?求解过程的本质是什么?什么是最优解？最优解唯一吗？</p><p>用状态空间法表示问题时，问题的解就是有向图中从某一节点（初始状态节点）到另一节点（目标状态节点)的路径。求解过程的本质就是对状态空间图的搜索，即在状态空间图上寻找一条从初始状态到目标状态的路径。<br>在不考虑搜索的代价时，即假设状态空间图中各节点之间的有向边的代价相同时，最优解就是解路径中长度最短的那条路径，在考虑搜索代价时，最优解则是解路径中代价最小的那条路径。因为在状态空间图中，可能存在几条长度或代价相等的最短解路径，所以，最优解可能会不唯一。</p></li><li><p>回溯算法和DFS(深度优先搜索)到底有什么区别？</p><p>回溯是一种思想，核心是不断尝试，不行就推到上一步。深度优先遍历是一种具体算法。<br>一种说法认为是<strong>回溯法=树的深度优先搜索+剪枝函数。</strong>但考虑到适用结构，也并不完全对。<br>回溯算法跟深度优先搜索算法都很经典，它们的区别跟关联都在于它们的数据结构，<strong>回溯算法是树结构，深度优先搜索是图结构</strong>。树与图的相似点跟不同点导致了回溯算法跟深度优先搜索算法去的存在相以点、也存在不同点。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>CUMT课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于滴答清单的时间管理</title>
    <link href="/2022/02/28/%E6%BB%B4%E7%AD%94%E6%B8%85%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/02/28/%E6%BB%B4%E7%AD%94%E6%B8%85%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>参考资料</strong></p><p><a href="https://help.dida365.com/">帮助中心 - 滴答清单 (dida365.com)</a></p><p><a href="https://help.dida365.com/tasks">时间管理方法论 | 帮助中心 - 滴答清单 (dida365.com)</a></p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>区分开<strong>自律和自虐</strong></li></ul><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/self-discipline1.png" alt="img"></p><ul><li><strong>专注力</strong>：一次只专注一件事、专注的时间足够久。专注力可视为一种<strong>「选择性注意」</strong>（selective attention）。当海量的外部刺激进入大脑后，我们会在几个并行的潜在目标和思想碎片之中提取其中一种，使其呈现出清晰鲜明的形象，威斯康星大学神经科学家理查德·戴维森将这个过程称为「阶段性锁定」，也就是专注。</li><li><strong>心流</strong>： 心流是一种理想的专注状态，指的是当你全神贯注地在做某件事时，大脑所达到的一种全情投入、欲罢不能的理想境界。在这个过程中，你的神经系统将高度和谐地运转，以至于完全意识不到时间的流逝，并得到前所未有的满足感。（<strong>产生条件</strong>：这件事是可以完成的：具有一定的挑战性，但难度与个人的能力相匹配；这件事目标明确；有即时的积极反馈）</li></ul><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><ul><li><strong>导致拖延的因素</strong><ul><li>对自己的能力缺乏自信</li><li>反感规则，讨厌命令</li><li>目标和回报太过遥远</li><li>自我约束能力差</li></ul></li><li><strong>分不清「必须做」和「我要做」</strong>：一个有充足时间去做「我要做」的事情的人总是从容不迫，而被「必须做」的事务缠住的人往往会认为自己对时间掌控感特别低，内心的挫败感也油然而生）</li><li><strong>迷失在无休止的工作中</strong>：不允许自己有丝毫懈怠，节假日也闲不住，自愿透支个人时间没日没夜地加班，生怕一停下来，就会在竞争中输给同事，就无法快速证明自己的能力。在他们的价值体系里，休息就是在浪费时间。</li><li><strong>习惯多线程工作</strong>：当你在多个任务间频繁切换时，大脑只是在一味地做无用功，在这种状态下，我们的出错率会上升，思考速度会变慢，有效工作的时间实则大大减少。忙碌一天下来，你会发现自己其实一件事都没做好。</li><li><strong>凡事都亲力亲为</strong>：事必躬亲，喜欢独揽包办，习惯性地想把自己变成超人，总是担心别人做事的能力、速度达不到自己的要求，宁可一个人忙得焦头烂额，也不愿意把工作分派给别人。</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul><li><p><strong>专注一件事</strong></p></li><li><p><strong>分解</strong>任务，设定可操作目标</p></li><li><p>给待完成的任务排<strong>优先级</strong></p></li><li><p><strong>学会拒绝</strong></p></li><li><p>把任务改造成<strong>可执行</strong>的具体步骤</p><p><strong>下一步行动 = 动词 + 事件 + 关键人 + 截止日期</strong></p><p>eg：周五晚上 8 点（截止日期），发周报（动词&amp;事件）给 Boss（关键人）</p><p>eg：下周三（截止日期）回复（动词）米兰俱乐部（关键人）的广告邮件预定纪念款球衣（事件）</p></li><li><p><strong>适当授权</strong>：分清「你能做的事」和「你该做的事」。与其自己浪费时间瞎琢磨，不如与他人合作，将任务合理地委派给更专业的人。让被授权的人能够积极地、创造性地处理好自己的工作，并对自己的工作结果负责。</p></li><li><p>决定开始做事的那一刻，<strong>主动屏蔽一切干扰和杂念</strong>，让自己别无选择，只能硬着头皮完成任务：整理桌面，归置好要用的物品、物理隔离电子产品，将其放在你看不见的地方，从社交网络彻底离线，消息事后统一回复、信息断舍离，关掉一切不必要的通知、学会拒绝，和与任务无关的人和事果断说“不”，简明和秩序有助于高效的工作</p></li><li><p><strong>注意力外包</strong>：释放注意力空间内存的有效形式。你可以通过外部工具，随时随地记录新冒出来的想法，提前安排好下一步行动，解放你的大脑。心里别装那么多事儿，自然就能静下心来。</p></li><li><p><strong>练习冥想</strong>：</p><ul><li>第1步：静坐在某个地方，保持心情平静</li><li>第2步：闭上双眼，在脑海中默念吸气、呼气，把注意力集中在身体的变化上</li><li>第3步：当发觉自己开始走神的时候，把思绪拉回来</li><li>第4步：刚开始练习可能很困难，没关系，先从5分钟开始，不断延长冥想的时间</li></ul></li><li><p><strong>科学合理地制定目标</strong>（smart）</p><ul><li>Specific（具体的）：避免模糊，避免理想化，与其决定“成为一名厨艺高手”，不如把目标改成“每个月学会20道菜”。</li><li>Measurable（可度量的）：具体的数量和指标有助于更好地评估进展、落实推进。比如，“每天跳绳30min”，而非“坚持跳绳”。</li><li>Attainable（可实现的）：你的目标应基于能力而略高于能力，别急功近利，对于那些既无必要、又难达成的目标，要么舍弃，要么进行必要的调整，“一个月瘦5斤”要比“一周瘦5斤”更易落实执行。</li><li>Relevant（相关的）：目标应与个人规划密切关联。认真审视你的自我需求，有意识地习得有关技能，假设你想成为一名律师，那么提升辩论水平的重要性远高于精通PS等多媒体软件。</li><li>Time-based（有时限的）：给自己设置DDL，适度的压力与紧迫感能督促你更高效地完成任务。</li></ul></li><li><strong>2分钟原则</strong>：如果一件事迟早要做，且2分钟内就能搞定（如回复邮件，文件分类等），那就一刻也不要犹豫，第一时间付诸行动</li><li><p><strong>5分钟原则</strong>：当你迟迟不愿开始某个任务时，不如告诉自己，「先做5分钟，只要5分钟就好！」，很多时候，当你一旦开始行动，就会停不下来，往往会坚持更长的时间</p></li><li><p><strong>赋能：给事情赋予目标和意义感</strong>：把「必须做」的事情尽可能地变成我要做，把「我要做」的事情做得更好。不仅仅满足于手头的事情，更要去思考，从长远来看，它能够如何帮我达到更高层次的目标</p></li><li>戒掉偏执的完美主义，正视自己的极限，调低期望值</li><li><strong>番茄工作法</strong>（要注意激励自己在最短时间内快速完成任务，聚焦于眼前的任务，直到闹铃响起）<ul><li>计划：筛选出优先级最高的任务（<strong>要事第一</strong>），添加至今日待办，估算分别需要多少番茄钟、将超过x个番茄钟的复杂任务进行拆分，琐碎的、不足一个番茄钟的任务进行合并（<strong>合并同类项</strong>）</li><li>执行：计时期间不可分心，番茄钟一旦因为某些事情暂停，就必须放弃。在一个番茄钟内，不要随意切换专注事件。若出现外部打断，先记录下来。即如果在一个番茄时间内有多余的时间，就对已完成的任务进行优化，看看有没有什么可以改进的地方。</li><li>追踪 （回顾番茄钟的使用过程）</li><li>记录，重点查看：每项任务预估时间和实际时间的差距、用番茄钟过程中出现的打断次数和具体内容、平均每天的专注时长和时段分布</li><li>优化：判断是否需要提高预估能力或者进一步将任务拆分、思考今后如何避免类似的打断、摸索出一天中自己效率最高的时间，优化日程安排</li><li><strong>使用误区</strong>：番茄钟是提升效率而不是量化时间的工具，请关注效果而不是用时，任务的完成度、执行结果比专注时间和番茄个数更重要！分析环节不可省略！ 果断放弃每一个已经夭折的小番茄！ 别试图补救和美化自己的努力程度，分析被打断的原因并避免再犯才是你应做的。</li></ul></li><li><p>牢记自己<strong>浏览的最初目的</strong>，一旦找到自己想要的信息果断关掉手机。听起来很简单对不对？只要你在刷信息时有意识地控制自己，就能很好地避免漫无目的的网络冲浪了。</p></li><li><p><strong>延迟满足</strong>，及时进行自我奖励（你要奖赏的是自己的努力、坚持和进步，而不是结果）可以加一个心愿清单</p></li><li><strong>设定一个完全脱离工作的时间</strong>：工作只是生活的一个维度，在这之外，还有更多事物值得我们关注。要懂得从工作中适当抽身出来，培养兴趣爱好，陪伴家人朋友。这里要注意，千万不要「一边度假，一边还忧心着未完成的任务」，如果可以，尽量别把工作带回家。</li><li><strong>任务分类方法</strong><ul><li>领域/项目分类法：工作（团队家庭个人）、学习、生活、娱乐</li><li>场景分类法：办公室、书桌、家里、超市；手机、电脑</li><li>四象限系统</li><li>时长/能量分类法</li></ul></li></ul><h2 id="软件使用"><a href="#软件使用" class="headerlink" title="软件使用"></a>软件使用</h2><ul><li><p>创建<strong>清单</strong></p><p>场景分类（公司、家）、任务类型（工作、学习、生活）</p></li><li><p><strong>收集箱</strong>：<strong>临时</strong>记录，为了减轻创建任务时的思考和压力而存在的，不要堆在这，最后<strong>及时清空，要归类</strong></p></li><li><p><strong>清单</strong></p><ul><li><p><strong>普通清单</strong></p><p>用户所创建的用来对任务进行归类的清单，如「生活」「工作」「会议」清单等。</p></li><li><p><strong>智能清单</strong></p><ul><li><p><strong>默认智能清单</strong></p><p>默认智能清单如「今天」「明天」「最近七天」「收集箱」「分配给我」等，可以根据一定条件对任务进行筛选及显示。</p><p>「今天」「明天」「最近七天」智能清单中，会显示到期日分别为今天、明天和最近七天的任务。</p><p>「收集箱」是一个临时的任务中转站，所有暂时来不及整理的任务都可以放在收集箱中。收集箱不可以被隐藏或删除。</p><p>「分配给我」是收集来自不同共享清单中分配给您的任务，您可以在这个清单中查看您在不同共享清单中的任务。</p></li></ul></li><li><p>▲自定义智能清单</p></li></ul></li><li><p><strong>标签</strong>：给任务添加标签可以帮助您从不同纬度对任务进行划分和管理，一个任务可以添加多个标签。标签系统支持创建二级标签。在左侧边栏中拖动标签并与另一标签重叠，即可为这两个标签创建父标签。</p></li><li><p>做好<strong>每日安排</strong>并及时<strong>回顾</strong>：点击「今天」智能清单右上角的「圆环」图标，进入「每日计划」模式，我们就可以逐条查看今天要做的所有事情，并方便的进行调整。</p></li><li><p><strong>管理任务的多重维度</strong></p><ul><li>「<strong>清单</strong>」对应事情的「分类」，将同类的事情归纳到一起</li><li>「<strong>日期和提醒</strong>」对应事情的「紧急程度」，用来规划什么时候做哪些事</li><li>「<strong>优先级</strong>」对应「重要程度」，用来来判断今天先做什么，后做什么</li><li>「<strong>情境</strong>」对应工作地点不定的人，「标签」来添加情境，你可以尝试列出这些常用的情境，它们通常由两部分组成：地点、用到的工具。</li><li>「<strong>状态</strong>」则适合于同时跟进多个项目或任务的人</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>时间管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Web应用开发技术》笔记</title>
    <link href="/2022/02/25/%E3%80%8AWeb%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/02/25/%E3%80%8AWeb%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学习选择</p><p>教程：</p><p>课堂</p><p><a href="https://www.w3school.com.cn/index.html">w3school 在线教程</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web">Web 入门 - 学习 Web 开发 | MDN (mozilla.org)</a></p><p>软件：IDEA</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><p>Web应用程序包含：前端的Web浏览器+支持HTTP协议的Web服务器+基于HTML格式的Web文档</p><p>Web的三要素</p><ul><li>超文本技术(HTML)看得懂</li><li>统一资源定位技术(URL)可定位</li><li>应用层协议(HTTP)找得到</li></ul><p>静态网页：这类网页文件里没有程序代码，只有HTML标记，一般以后缀.htm或.html存放。 </p><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220225083721716.png" alt="服务器请求静态网页" style="zoom:67%;" /></p><p>动态网页：这类网页文件不仅含有HTML标记，而且含有程序代码，这种网页的后缀一般根据不同的程序设计语言而不同，如ASP.NET文件的后缀为.aspx；JSP文件为.jsp。 两个显著特点：可以动态产生页面、支持客户端和服务器端的交互功能。</p><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220225084356960.png" alt="动态页面" style="zoom:67%;" /></p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><strong>静态网页</strong></th><th style="text-align:center"><strong>动态网页</strong></th></tr></thead><tbody><tr><td style="text-align:center">内容</td><td style="text-align:center">网页内容固定</td><td style="text-align:center">网页内容动态生成</td></tr><tr><td style="text-align:center">后缀</td><td style="text-align:center">.htm；.html等</td><td style="text-align:center">.ASP，.JSP，.PHP，.CGI, .ASPX等</td></tr><tr><td style="text-align:center">优点</td><td style="text-align:center">无需系统实时生成</td><td style="text-align:center">日常维护简单，更改结构方便，交互性能强</td></tr><tr><td style="text-align:center">缺点</td><td style="text-align:center">交互性能较差，日常维护繁琐</td><td style="text-align:center">需要大量的系统资源合成网页</td></tr><tr><td style="text-align:center">DB</td><td style="text-align:center">不支持</td><td style="text-align:center">支持</td></tr></tbody></table></div><p>工作原理</p><ul><li>C/S模式：服务器通常采用高性能的PC、大型数据库系统。客户端需要安装专用的客户端软件。 这类应用程序一般独立的运行。（很多工作可以在客户端处理后再提交给服务器，客户端响应速度快。管理信息系统具有较强的事务处理能力，能实现复杂的业务流程。客户机端必须装客户端软件及相应环境后，才能访问服务器兼容性不强，对客户端的操作系统有一定的限制）</li><li>B/S模式：客户机上只要安装一个浏览器，服务器安装Web Server。统一了客户端，将系统功能实现的核心部分集中到服务器上，简化了系统的开发、维护和使用。需要借助浏览器来运行。</li></ul><p>主流动态Web技术：JSP/JAVA、ASP/ASP.NET、PHP、Python+Django/Flask/Pyramid、Ruby+Rails/Grape/Sinatra</p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>HTML（Hyper Text Markup Language）它不是一种真正的编程语言，只是一种标记符。</p><p>基本结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE  <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">HTML</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">HEAD</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">TITLE</span>&gt;</span>我的第一个网页 <span class="hljs-tag">&lt;/<span class="hljs-name">TITLE</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">HEAD</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BODY</span>&gt;</span><br>Hello World!<br><span class="hljs-tag">&lt;/<span class="hljs-name">BODY</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">HTML</span>&gt;</span><br></code></pre></td></tr></table></figure><p>ps：最好在一开始就养成习惯，文件夹和文件名使用小写，用短横线而不是空格来分隔。可以避免许多问题。</p><ul><li>网站应该使用什么结构？<br>下面来看看测试网站应该使用什么结构。最基本、最常见的结构是：一个主页、一个图片文件夹、一个样式表文件夹和一个脚本文件夹：<ul><li>index.html ：这个文件一般包含主页内容，即用户第一次访问站点时看到的文本和图像。使用文本编辑器在 test-site 文件夹中新建 index.html。</li><li>images 文件夹 ：这个文件夹包含站点中的所有图像。在 test-site 文件夹中新建 images 文件夹。</li><li>styles 文件夹 ：这个文件夹包含站点所需样式表（比如，设置文本颜色和背景颜色）。在 test-site 文件夹中新建一个 styles 文件夹。</li><li>scripts 文件夹 ：这个文件夹包含提供站点交互功能的 JavaScript 代码（比如读取数据的按钮）。在 test-site 文件夹中新建一个 scripts 文件夹。</li></ul></li></ul><h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><ul><li>HTML 元素以<em>开始标签</em>起始</li><li>HTML 元素以<em>结束标签</em>终止</li><li><em>元素的内容</em>是开始标签与结束标签之间的内容</li><li>某些 HTML 元素具有<em>空内容（empty content）</em></li><li>空元素<em>在开始标签中进行关闭</em>（以开始标签的结束而结束）</li><li>大多数 HTML 元素可拥有<em>属性</em></li></ul><p>HTML 标签对大小写不敏感：<code>&lt;P&gt;</code>等同于<code>&lt;p&gt;</code>。许多网站都使用大写的 HTML 标签。</p><p>W3School 使用的是小写标签，因为万维网联盟（W3C）在 HTML 4 中<em>推荐</em>使用小写，而在未来 (X)HTML 版本中<em>强制</em>使用小写。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">class</td><td style="text-align:left">classname</td><td style="text-align:left">规定元素的类名（classname）</td></tr><tr><td style="text-align:left">id</td><td style="text-align:left">id</td><td style="text-align:left">规定元素的唯一 id</td></tr><tr><td style="text-align:left">style</td><td style="text-align:left">style_definition</td><td style="text-align:left">规定元素的行内样式（inline style）</td></tr><tr><td style="text-align:left">title</td><td style="text-align:left">text</td><td style="text-align:left">规定元素的额外信息（可在工具提示中显示）</td></tr></tbody></table></div><h2 id="标题、水平线、注释"><a href="#标题、水平线、注释" class="headerlink" title="标题、水平线、注释"></a>标题、水平线、注释</h2><p>标题（Heading）是通过<code>&lt;h1&gt;</code>-<code>&lt;h6&gt;</code>等标签进行定义的。</p><p><code>&lt;hr/&gt;</code> 标签在 HTML 页面中创建水平线。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>This is a heading<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>This is a heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-comment">&lt;!-- This is a comment --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is a paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is a paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is a paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>使用空的段落标记 <code>&lt;p&gt;&lt;/p&gt;</code>去插入一个空行是个坏习惯。用 <code>&lt;br /&gt;</code> 标签代替它！（但是不要用<code>&lt;br /&gt;</code> 标签去创建列表）</p><p>在不产生一个新段落的情况下进行换行（新行），请使用<code>&lt;br /&gt;</code> 标签</p><p>在 XHTML、XML 以及未来的 HTML 版本中，不允许使用没有结束标签（闭合标签）的 HTML 元素。</p><p>即使<code>&lt;br&gt;</code> 在所有浏览器中的显示都没有问题，使用 <code>&lt;br /&gt;</code> 也是<em>更长远的保障</em>。</p><p>浏览器会忽略了源代码中的排版（省略了多余的空格和换行）无论你在HTML元素的内容中使用多少空格(包括空白字符，包括换行)，当渲染这些代码的时候，HTML解释器会将连续出现的空白字符减少为一个单独的空格符。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">h1</span>&gt;This is <span class="hljs-selector-tag">a</span> heading&lt;/<span class="hljs-selector-tag">h1</span>&gt;<br>&lt;<span class="hljs-selector-tag">h2</span>&gt;This is <span class="hljs-selector-tag">a</span> heading&lt;/<span class="hljs-selector-tag">h2</span>&gt;<br>&lt;<span class="hljs-selector-tag">p</span>&gt;This is&lt;br /&gt;<span class="hljs-selector-tag">a</span> para&lt;br /&gt;graph with line breaks&lt;/<span class="hljs-selector-tag">p</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>不赞成使用的标签和属性：在 HTML 4 中，有若干的标签和属性是被废弃的。被废弃（Deprecated）的意思是在未来版本的 HTML 和 XHTML 中将不支持这些标签和属性。最好使用样式代替。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">标签<br><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span>定义居中的内容。<br><span class="hljs-tag">&lt;<span class="hljs-name">font</span>&gt;</span> 和 <span class="hljs-tag">&lt;<span class="hljs-name">basefont</span>&gt;</span>定义 HTML 字体。<br><span class="hljs-tag">&lt;<span class="hljs-name">s</span>&gt;</span> 和 <span class="hljs-tag">&lt;<span class="hljs-name">strike</span>&gt;</span>定义删除线文本<br><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>定义下划线文本<br>属性<br>align定义文本的对齐方式<br>bgcolor定义背景颜色<br>color定义文本颜色<br></code></pre></td></tr></table></figure><p>背景颜色（style 属性淘汰了旧的 bgcolor 属性。）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:yellow&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:red&quot;</span>&gt;</span>This is a heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:green&quot;</span>&gt;</span>This is a paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>字体、颜色和尺寸（style 属性淘汰了旧的<code>&lt;font&gt;</code>标签。）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-family:verdana&quot;</span>&gt;</span>A heading<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-family:arial; color:red; font-size:20px;&quot;</span>&gt;</span>A paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 文本对齐（style 属性淘汰了旧的 align 属性）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-align:center&quot;</span>&gt;</span>This is a heading<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="文本格式化、引用"><a href="#文本格式化、引用" class="headerlink" title="文本格式化、引用"></a>文本格式化、引用</h2><p><a href="https://www.w3school.com.cn/html/html_formatting.asp">HTML 文本格式化 (w3school.com.cn)</a></p><p><a href="https://www.w3school.com.cn/html/html_quotation_elements.asp">HTML 引用 (w3school.com.cn)</a></p><ul><li>实体引用： 在HTML中包含特殊字符</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">原义字符</th><th style="text-align:left">等价字符引用</th></tr></thead><tbody><tr><td style="text-align:left">&lt;</td><td style="text-align:left"><code>&amp;lt;</code></td></tr><tr><td style="text-align:left">&gt;</td><td style="text-align:left"><code>&amp;gt;</code></td></tr><tr><td style="text-align:left">“</td><td style="text-align:left"><code>&amp;quot;</code></td></tr><tr><td style="text-align:left">‘</td><td style="text-align:left"><code>&amp;apos;</code></td></tr><tr><td style="text-align:left">&amp;</td><td style="text-align:left"><code>&amp;amp;</code></td></tr></tbody></table></div><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p><a href="https://www.w3school.com.cn/html/html_css.asp">HTML CSS (w3school.com.cn)</a></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>有两种使用<code>&lt;a&gt;</code> 标签的方式：</p><ol><li>通过使用 href 属性 - 创建指向另一个文档的链接（使用 Target 属性，你可以定义被链接的文档在何处显示。）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.w3school.com.cn/&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>Visit W3School!<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>通过使用 name 属性 - 创建文档内的书签（当使用命名锚（named anchors）时，我们可以创建直接跳至该命名锚（比如页面中某个小节）的链接，这样使用者就无需不停地滚动页面来寻找他们需要的信息了。）用 id 属性来替代 name 属性，命名锚同样有效。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">首先，我们在 HTML 文档中对锚进行命名（创建一个书签）：<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;tips&quot;</span>&gt;</span>基本的注意事项 - 有用的提示<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>然后，我们在同一个文档中创建指向该锚的链接：<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#tips&quot;</span>&gt;</span>有用的提示<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>您也可以在其他页面中创建指向该锚的链接：<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.w3school.com.cn/html/html_links.asp#tips&quot;</span>&gt;</span>有用的提示<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>在上面的代码中，我们将 # 符号和锚名称添加到 URL 的末端，就可以直接链接到 tips 这个命名锚了。<br></code></pre></td></tr></table></figure><h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2><p><code>&lt;img&gt;</code>是空标签，意思是说，它只包含属性，并且没有闭合标签。</p><p>当浏览器无法载入图像时，替换文本属性可告诉读者他们失去的信息。此时，浏览器将显示这个替代性的文本而不是图像。为页面上的图像都加上替换文本属性alt是个好习惯，这样有助于更好的显示信息，并且对于那些使用纯文本浏览器的人来说是非常有用的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">background</span>=<span class="hljs-string">&quot;/i/eg_background.jpg&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>gif 和 jpg 文件均可用作 HTML 背景。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>如果图像小于页面，图像会进行重复。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;boat.gif&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Big Boat&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span> =<span class="hljs-string">&quot;/i/eg_cute.gif&quot;</span> <span class="hljs-attr">align</span> =<span class="hljs-string">&quot;left&quot;</span> &gt;</span> <br>带有图像的一个段落。图像的 align 属性设置为 &quot;left&quot;。图像将浮动到文本的左侧。还有bottom（默认） right middle top<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>边框、表头、跨行跨列</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>横跨两列的单元格：<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>电话<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Bill Gates<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>555 77 854<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>555 77 855<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>横跨两行的单元格：<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Bill Gates<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>电话<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>555 77 854<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>555 77 855<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>无序列表、有序列表、定义列表。列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。无序type（disc默认、circle、square），有序type（默认数字、A、a、I、i）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;disc&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>Black hot drink<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>White cold drink<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>用于收集用户输入</p><p>表单元素：不同类型的 input 元素：文本框text、单选按钮radio、提交按钮submit等等。</p><p>action 属性定义在提交表单时执行的动作。向服务器提交表单的通常做法是使用提交按钮。通常，表单会被提交到 web 服务器上的网页。</p><p>GET和POST</p><ul><li>GET（默认方法）如果表单提交是被动的（比如搜索引擎查询），并且没有敏感信息。使用 GET 时，表单数据在页面地址栏中是可见的。GET 最适合少量数据的提交。浏览器会设定容量限制。</li><li>如果表单正在更新数据，或者包含敏感信息（例如密码）。POST 的安全性更好，因为在页面地址栏中被提交的数据是不可见的。</li><li><p>关于 GET 的注意事项：</p><ul><li>以名称/值对的形式将表单数据追加到 URL</li><li>永远不要使用 GET 发送敏感数据！（提交的表单数据在 URL 中可见！）</li><li>URL 的长度受到限制（2048 个字符）</li><li>对于用户希望将结果添加为书签的表单提交很有用</li><li>GET 适用于非安全数据，例如 Google 中的查询字符串</li></ul></li><li><p>关于 POST 的注意事项：</p><ul><li>将表单数据附加在 HTTP 请求的正文中（不在 URL 中显示提交的表单数据）POST 没有大小限制，可用于发送大量数据。</li><li>带有 POST 的表单提交无法添加书签</li></ul></li></ul><p>如果要正确地被提交，每个输入字段必须设置一个 name 属性。否则不会提交</p><p><code>&lt;fieldset&gt;</code> 元素组合表单中的相关数据</p><p><code>&lt;legend&gt;</code>元素为<code>&lt;fieldset&gt;</code> 元素定义标题。</p><p><code>&lt;select&gt;</code> 元素（下拉列表）添加 selected 属性来定义预定义选项。</p><p><code>&lt;textarea&gt;</code>元素定义多行输入字段</p><p><code>&lt;button&gt;</code>按钮</p><p>input 属性：value 属性规定输入字段的初始值，readonly 属性规定输入字段为只读（不能修改），disabled 属性规定输入字段是禁用的。被禁用的元素是不可用和不可点击的。被禁用的元素不会被提交。size 属性规定输入字段的尺寸（以字符计）maxlength 属性规定输入字段允许的最大长度</p><p>主要元素如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;action_page.php&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;GET&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>Personal information:<span class="hljs-tag">&lt;/<span class="hljs-name">legend</span>&gt;</span><br>        First name:<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;firstname&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        User password:<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;psw&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">checked</span>&gt;</span>Male<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>Female<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;vehicle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Bike&quot;</span>&gt;</span>I have a bike<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;vehicle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Car&quot;</span>&gt;</span>I have a car<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cars&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;volvo&quot;</span> <span class="hljs-attr">selected</span>&gt;</span>Volvo<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;saab&quot;</span>&gt;</span>Saab<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;fiat&quot;</span>&gt;</span>Fiat<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;10&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;30&quot;</span>&gt;</span>The cat was playing in the garden.<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit按钮&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;Hello World!&#x27;)&quot;</span>&gt;</span>Click Me!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span> <br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">form属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">accept-charset</td><td style="text-align:left">规定在被提交表单中使用的字符集（默认：页面字符集）。</td></tr><tr><td style="text-align:left">action</td><td style="text-align:left">规定向何处提交表单的地址（URL）（提交页面）。</td></tr><tr><td style="text-align:left">autocomplete</td><td style="text-align:left">规定浏览器应该自动完成表单（默认：开启）。</td></tr><tr><td style="text-align:left">enctype</td><td style="text-align:left">规定被提交数据的编码（默认：url-encoded）。</td></tr><tr><td style="text-align:left">method</td><td style="text-align:left">规定在提交表单时所用的 HTTP 方法（默认：GET）。或者post</td></tr><tr><td style="text-align:left">name</td><td style="text-align:left">规定识别表单的名称（对于 DOM 使用：document.forms.name）。</td></tr><tr><td style="text-align:left">novalidate</td><td style="text-align:left">规定浏览器不验证表单。</td></tr><tr><td style="text-align:left">target</td><td style="text-align:left">规定 action 属性中地址的目标（默认：_self）。_blank等</td></tr></tbody></table></div><p>HTML5 增加了多个新的输入类型：color、date、datetime、datetime-local、email、month、number、range、search、tel、time、url、week</p><p>Input form* 属性：input 的 form属性规定 <code>&lt;input&gt;</code> 元素所属的表单。此属性的值必须等于它所属的 <code>&lt;form&gt;</code> 元素的 id 属性。位于 HTML 表单之外的输入字段,但仍是表单的一部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/action_page.php&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;form1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span>姓氏：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fname&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fname&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;lname&quot;</span>&gt;</span>名字：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;lname&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lname&quot;</span> <span class="hljs-attr">form</span>=<span class="hljs-string">&quot;form1&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="canvas、SVG"><a href="#canvas、SVG" class="headerlink" title="canvas、SVG"></a>canvas、SVG</h2><p>canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCanvas&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://www.w3school.com.cn/html/html5_canvas.asp">HTML5 Canvas (w3school.com.cn)</a></p><p>可伸缩矢量图形 (Scalable Vector Graphics)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.1&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;190&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">polygon</span> <span class="hljs-attr">points</span>=<span class="hljs-string">&quot;100,10 40,180 190,60 10,60 160,180&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对比</p><ul><li>Canvas<ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ul></li><li>SVG<ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ul></li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p><code>&lt;object&gt;</code>HTML 文档中的嵌入式对象,它旨在将插件（例如 Java applet、PDF 阅读器和 Flash 播放器）嵌入网页中，但也可以用于将 HTML 包含在 HTML 中</p><p><code>&lt;embed&gt;</code>也定义了 HTML 文档中的嵌入式对象。元素没有结束标记。它无法包含替代文本。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;500px&quot;</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&quot;snippet.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100%&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;500px&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;snippet.html&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&quot;audi.jpeg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;audi.jpeg&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="音视频"><a href="#音视频" class="headerlink" title="音视频"></a>音视频</h2><p> HTML5<code>&lt;audio&gt;</code></p><p>mp3 文件在Internet Explorer、Chrome 以及 Safari 有效。为了使这段音频在 Firefox 和 Opera 中同样有效，添加了一个 ogg 类型的文件。如果失败，会显示错误消息。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">&quot;controls&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;song.mp3&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/mp3&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;song.ogg&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/ogg&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;song.mp3&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure><p>网站上找播放器代码复制粘贴</p><p>使用超链接：浏览器会启动“辅助应用程序”来播放该文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;song.mp3&quot;</span>&gt;</span>Play Sound<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p> HTML5<code>&lt;video&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;320&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;240&quot;</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">&quot;controls&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.ogg&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/ogg&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.webm&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/webm&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&quot;movie.mp4&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;320&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;240&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.swf&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;320&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;240&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h2><p>HTML5 是最新的 HTML 标准。</p><p>HTML5 是跨平台的，被设计为在不同类型的硬件（PC、平板、手机、电视机等等）之上运行。HTML5 的一些最有趣的新特性：</p><ul><li>新的语义元素，比如<code>&lt;header&gt;</code>,<code>&lt;footer&gt;</code>, <code>&lt;article&gt;</code>, and <code>&lt;section&gt;</code>。（语义化标签）</li><li>新的表单控件，比如数字、日期、时间、日历和滑块。</li><li>强大的图像支持（借由 <code>&lt;b&gt;</code> 和 <code>&lt;svg&gt;</code>）</li><li>强大的多媒体支持（借由 <code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code>）</li><li>强大的新 API，比如用本地存储取代 cookie。</li></ul><p>所有现代浏览器都支持 HTML5。所有浏览器，不论新旧，都会自动把未识别元素当做行内元素来处理。</p><h1 id="CSS-1"><a href="#CSS-1" class="headerlink" title="CSS"></a>CSS</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><ul><li><p>CSS 指的是Cascading Style Sheets)</p></li><li><p>CSS 描述了如何在屏幕、纸张或其他媒体上显示 HTML 元素</p></li><li><p>CSS 节省了大量工作。它可以同时控制多张网页的布局</p></li><li><p>外部样式表存储在 .CSS 文件中</p></li><li><p>HTML 从未打算包含用于格式化网页的标签，创建 HTML 的目的是描述网页的内容，css解决这个问题</p></li><li><p>语法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>p 是 CSS 中的选择器（它指向要设置样式的 HTML 元素：<p>）。</li><li>color 是属性，red 是属性值</li><li>text-align 是属性，center 是属性值</li></ul></li><li><p>使用方法</p><ol><li><p>外部 CSS</p><p>通过使用外部样式表，您只需修改一个文件即可改变整个网站的外观。每张 HTML 页面必须在 head 部分的 <code>&lt;link&gt;</code> 元素内包含对外部样式表文件的引用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mystyle.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: lightblue;<br>&#125;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: navy;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps:请勿在属性值和单位之间添加空格（例如 <code>margin-left: 20 px;</code>）。正确的写法是：<code>margin-left: 20px;</code></p></li><li><p>内部 CSS</p><p>如果一张 HTML 页面拥有唯一的样式，那么可以使用内部样式表。内部样式是在 head 部分的 <code>&lt;style&gt;</code>元素中进行定义。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css"><span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">  <span class="hljs-attribute">background-color</span>: linen;</span><br><span class="css">&#125;</span><br><span class="css"></span><br><span class="css"><span class="hljs-selector-tag">h1</span> &#123;</span><br><span class="css">  <span class="hljs-attribute">color</span>: maroon;</span><br><span class="css">  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">40px</span>;</span><br><span class="css">&#125; </span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>行内 CSS</p><p>行内样式（也称内联样式）可用于为单个元素应用唯一的样式。如需使用行内样式，请将 style 属性添加到相关元素。style 属性可包含任何 CSS 属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:blue;text-align:center;&quot;</span>&gt;</span>This is a heading<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p>优先级：行内样式、内外部样式表（都有看最后的）、浏览器默认样式</p></li><li><p>id 具有唯一性,class 具有普遍性</p></li></ul><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><ul><li>分类<ul><li>简单选择器（根据名称、id（#）、类（.）、通用（*）来选取元素）</li><li>组合器选择器（根据它们之间的特定关系来选取元素）</li><li>伪类选择器（根据特定状态（,等）选取元素）</li><li>伪元素选择器（选取元素的一部分并设置其样式）</li><li>属性选择器（根据属性或属性值来选取元素）</li></ul></li></ul><p><img src="https://s2.loli.net/2022/03/05/ZhrfpuNcJgF1z5k.png" alt="img" style="zoom:67%;" /></p><p>伪类：用来添加一些选择器的特殊效果</p><div class="table-container"><table><thead><tr><th>选择器</th><th>含义</th></tr></thead><tbody><tr><td>E:first-child</td><td>匹配父元素的第一个子元素</td></tr><tr><td>E:link</td><td>匹配所有未被点击的链接</td></tr><tr><td>E:visited</td><td>匹配所有已被点击的链接</td></tr><tr><td>E:active</td><td>匹配鼠标已经其上按下、还没有释放的E元素</td></tr><tr><td>E:hover</td><td>匹配鼠标悬停其上的E元素</td></tr><tr><td>E:focus</td><td>匹配获得当前焦点的E元素</td></tr><tr><td>E:lang(c)</td><td>匹配lang属性等于c的E元素</td></tr><tr><td>E:first-line</td><td>匹配E元素的第一行</td></tr><tr><td>E:first-letter</td><td>匹配E元素的第一个字母</td></tr><tr><td>E:before</td><td>在E元素之前插入生成的内容</td></tr><tr><td>E:after</td><td>在E元素之后插入生成的内容</td></tr><tr><td>E:enabled</td><td>匹配表单中激活的元素</td></tr><tr><td>E:disabled</td><td>匹配表单中禁用的元素</td></tr><tr><td>E:checked</td><td>匹配表单中被选中的radio（单选框）或checkbox（复选框）元素</td></tr><tr><td>E:selection</td><td>匹配用户当前选中的元素</td></tr></tbody></table></div><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><ul><li>background-color</li><li>color:DodgerBlue;</li><li>border:2px solid Tomato</li><li>在 CSS 中，还可以使用 RGB 值、HEX 值、HSL 值、RGBA 值或者 HSLA 值来指定颜色</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>background-color</li><li><p>background-image:url(“paper.gif”);</p></li><li><p>background-repeat: repeat-x/repeat-y/no-repeat</p></li><li><p>background-attachment: 背景图像是应该滚动还是固定的（不会随页面的其余部分一起滚动）fixed/scroll</p></li><li><p>background-position: right top   etc.</p></li><li><p>background 简写属性(按上述顺序写，缺失不要紧)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#ffffff</span> <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;tree.png&quot;</span>) no-repeat right top;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="框模型"><a href="#框模型" class="headerlink" title="框模型"></a>框模型</h2><h3 id="框模型介绍"><a href="#框模型介绍" class="headerlink" title="框模型介绍"></a>框模型介绍</h3><p>所有 HTML 元素都可以视为方框。在 CSS 中，在谈论设计和布局时，会使用术语“盒模型”或“框模型”。</p><p>CSS 框模型实质上是一个包围每个 HTML 元素的框。它包括：外边距、边框、内边距以及实际的内容。下图展示了框模型</p><p><img src="https://www.w3school.com.cn/i/css/boxmodel.gif" alt="CSS 框模型" style="zoom:50%;" /></p><ul><li>内容 - 框的内容，其中显示文本和图像。</li><li>内边距 - 清除内容周围的区域。内边距是透明的。</li><li>边框 - 围绕内边距和内容的边框。</li><li>外边距 - 清除边界外的区域。外边距是透明的。</li></ul><h3 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h3><ul><li><p>margin-X：auto、length（px、pt、cm）、%、inherit（允许负值）</p></li><li><p>margin 简写属性，可以设置一到四个值</p></li><li><p>外边距合并：当两个垂直外边距相遇时，它们将形成一个外边距。</p><ul><li><p>合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并。</p><p><img src="https://www.w3school.com.cn/i/css/margin_collapsing_1.gif" alt="CSS 外边距合并实例 1" style="zoom: 50%;" /></p></li><li><p>当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生合并。</p><p><img src="https://www.w3school.com.cn/i/css/margin_collapsing_example_2.gif" alt="CSS 外边距合并实例 2" style="zoom:50%;" /></p></li><li><p>外边距甚至可以与自身发生合并。假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并。如果这个外边距遇到另一个元素的外边距，它还会发生合并。</p><p><img src="https://s2.loli.net/2022/03/03/FKIGfgRaH8LOdCS.png" alt="CSS 外边距合并实例 3" style="zoom:50%;" /></p><p><img src="https://www.w3school.com.cn/i/css/margin_collapsing_example_4.gif" alt="CSS 外边距合并实例 4" style="zoom:50%;" /></p></li></ul></li></ul><h3 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h3><ul><li><p>padding-X：length（px、pt、cm）、%、inherit（不允许负值）</p></li><li><p>padding 简写属性，可以设置一到四个值</p></li><li><p>内边距和元素宽度</p><p>CSS width 属性指定元素内容区域的宽度。内容区域是元素（盒模型）的内边距、边框和外边距内的部分。</p><p>因此，如果元素拥有指定的宽度，则添加到该元素的内边距会添加到元素的总宽度中。这通常是不希望的结果。</p><p>若要将宽度保持为 300px，无论填充量如何，可以使用 box-sizing 属性。这将导致元素保持其宽度。如果增加内边距，则可用的内容空间会减少。</p></li></ul><h3 id="height、width"><a href="#height、width" class="headerlink" title="height、width"></a>height、width</h3><ul><li><p>height 和 width 属性用于设置元素的高度和宽度。</p></li><li><p>height 和 width 属性<strong>不包括内边距、边框或外边距</strong>。它设置的是<strong>元素内边距、边框以及外边距内的区域的高度或宽度</strong>。</p></li><li>auto、length（px、pt、cm）、%、initial、inherit</li><li>max-width：length（px、pt、cm）、%、none</li></ul><h3 id="border边框"><a href="#border边框" class="headerlink" title="border边框"></a>border边框</h3><ul><li><p>border-width</p><ul><li>宽度设置为特定大小（以 px、pt、cm、em 计），也可以使用以下三个预定义值之一：thin、medium 或 thick。</li><li>属性可以设置一到四个值（一个所有，两个上下再左右，三个上、左右、下，四个上右下左顺时针）</li></ul></li><li><p>border-style</p><ul><li>类型：dotted 点线、dashed 虚线、solid 实线、double 双边、none 无边框、hidden 隐藏边框</li><li><strong>除非设置了 border-style 属性，否则其他 CSS 边框属性都不会有任何作用</strong></li></ul></li><li><p>border-color </p><ul><li>和颜色差不多，如果未设置，继承元素的颜色。</li><li>可以设置一到四个值。</li></ul></li><li><p>border-X-Y（X=top/right/bottom/left, Y=style/width/color）每一侧指定属性的不同的值</p></li><li><p>border <strong>简写属性</strong> （border-width、border-style（必需）、border-color）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid red;<br>&#125;<br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">border-left</span>: <span class="hljs-number">6px</span> solid red;<br>  <span class="hljs-attribute">background-color</span>: lightgrey;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>border-radius 圆角边框</p></li></ul><h3 id="轮廓"><a href="#轮廓" class="headerlink" title="轮廓"></a>轮廓</h3><p>轮廓与边框不同，轮廓是在元素边框之外绘制的，并且可能与其他内容<strong>重叠</strong>。同样，轮廓也<strong>不是</strong>元素尺寸的一部分；元素的总宽度和高度不受轮廓线宽度的影响</p><ul><li>outline-width<ul><li>宽度设置为特定大小（以 px、pt、cm、em 计），也可以使用以下三个预定义值之一：thin、medium 或 thick。</li><li>属性可以设置一到四个值（一个所有，两个上下再左右，三个上、左右、下，四个上右下左顺时针）</li></ul></li><li>outline-style 类型<ul><li>dotted 点、dashed 虚、solid 实、double 双、none 无、hidden 隐藏</li><li><strong>除非设置了 outline-style属性，否则其他 CSS 轮廓属性都不会有任何作用</strong></li></ul></li><li>outline-color<ul><li>和颜色差不多，还有invert反转</li></ul></li><li>outline <strong>简写属性</strong> （border-width、border-style（必需）、border-color）</li><li>outline-offset 轮廓偏移，属性在元素的轮廓与边框之间添加空间。元素及其轮廓之间的空间是透明的。</li></ul><h2 id="行内元素和块元素"><a href="#行内元素和块元素" class="headerlink" title="行内元素和块元素"></a>行内元素和块元素</h2><ul><li>行内元素（inline element）<br>特点是只占内容的宽度，默认不会换行，行内元素一般放文本或者其它的行内元素。常见内联元素<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code></li><li>块元素(block element)<br>特点不管内容有多少，它要换行，同时沾满整行，块元素可以放文本，行内元素，块元素。常见块元素：<code>&lt;div&gt;</code>，<code>&lt;p&gt;</code>。</li><li>区别：行内元素只占内容的宽度，块元素内容不管内容多少要占全行。 行内元素只能容纳文本和其它行内元素，块元素可以容纳文本，行内元素和块元素。</li></ul><h2 id="文本、字体、图标、链接"><a href="#文本、字体、图标、链接" class="headerlink" title="文本、字体、图标、链接"></a>文本、字体、图标、链接</h2><h3 id="文本字体"><a href="#文本字体" class="headerlink" title="文本字体"></a>文本字体</h3><ul><li><p>font-size</p><p>CSS 定义了 5 个常用的字体名称:  serif, sans-serif, monospace, cursive,和 fantasy. 这些都是非常通用的，当使用这些通用名称时，使用的字体完全取决于每个浏览器，而且它们所运行的每个操作系统也会有所不同。这是一种糟糕的情况，浏览器会尽力提供一个看上去合适的字体。</p></li></ul><p><code>font-family: Helvetica, Arial, sans-serif;</code></p><ul><li><p>font-size</p></li><li><p>font-style</p></li><li><p>font-weight</p></li><li><p>font简写:如果你想要使用 font 的简写形式，在所有这些属性中，只有 font-size 和 font-family 是一定要指定的。</p><p><code>font: italic normal bold normal 3em/1.5 Helvetica, Arial, sans-serif;</code></p></li><li><p>text-transform</p></li><li><p>text-decoration</p></li><li><p>text-shadow</p></li><li><p>text-align</p></li><li><p>line-height</p></li></ul><h3 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h3><ul><li><p>LoVe Fears HAte</p><p>未访问过的 (Unvisited) 、访问过的 (Visited)、悬停 (Hover) 、选中 (Focus) 、激活 (Active)</p></li><li><p>加图片</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href*=<span class="hljs-string">&quot;http&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;https://mdn.mozillademos.org/files/12982/external-link-52.png&#x27;</span>) no-repeat <span class="hljs-number">100%</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="列表、表格"><a href="#列表、表格" class="headerlink" title="列表、表格"></a>列表、表格</h2><h2 id="溢出和浮动"><a href="#溢出和浮动" class="headerlink" title="溢出和浮动"></a>溢出和浮动</h2><h2 id="CSS-定位"><a href="#CSS-定位" class="headerlink" title="CSS 定位"></a>CSS 定位</h2><ul><li>普通流：块级框从上到下一个接一个地排列（不设宽度时，独占一行），框之间的垂直距离是由框的垂直外边距计算出来，行内元素会按顺序依次前后排列。</li><li>浮动float：设置元素浮动到页面的边缘。取值如下：<ul><li>none：缺省值，不浮动</li><li>left:元素在页面左边缘浮动,让出自己右边空间，给下一个元素显示；</li><li>right:元素在页面右边缘浮动,直到碰到他的父元素的右边界。</li><li>浮动目的：就是可以让多个块级元素一行内显示，从而实现布局效果。</li></ul></li><li>使用 position 属性，可以选择 4 种不同类型的定位<ul><li>static元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。</li><li>relative元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。</li><li>absolute元素框从文档流完全删除，并相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。</li><li>fixed元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身。</li><li>粘性定位(sticky positioning)是最后一种我们能够使用的定位方式。它将默认的静态定位(static positioning)和固定定位(fixed positioning)相混合。当一个元素被指定了position: sticky时，它会在正常布局流中滚动，直到它出现在了我们给它设定的相对于容器的位置，这时候它就会停止随滚动移动，就像它被应用了position: fixed一样。</li></ul></li></ul><h2 id="响应式Web设计"><a href="#响应式Web设计" class="headerlink" title="响应式Web设计"></a>响应式Web设计</h2><p>核心方法一：响应式布局，流动布局为最佳选择，百分比和em为最佳单位</p><p>核心方法二：媒介查询，为站点设定视口、使用媒介查询</p><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><ul><li><p>JavaScript 组成</p><ul><li>ECMAScript(核心)，描述了该语javascript组成，语言的语法和基本对象。 </li><li>文档对象模型（DOM），描述处理网页内容的方法和接口。</li><li>浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口。</li></ul></li><li><p>将JavaScript嵌入网页中的三种方法</p><ol><li>使用<code>&lt;script&gt;…&lt;/script&gt;</code> 标签将语句嵌入文档</li><li>将外部JavaScript 源文件链接到 html 文档中,<code>&lt;script src= &quot;test.js&quot;&gt;&lt;/script&gt;</code>可使多个网页共享一个脚本文件内的代码,一般在其中定义一系列在多个网页中都可能要用到的函数</li><li>作为网页元素的事件处理程序,当事件触发时自动运行<code>&lt;marquee  onmouseover=&quot;this.stop()&quot;&gt;</code></li></ol></li></ul><h2 id="变量、函数、运算符、方法"><a href="#变量、函数、运算符、方法" class="headerlink" title="变量、函数、运算符、方法"></a>变量、函数、运算符、方法</h2><ul><li>var 关键词声明变量</li><li>局部变量：函数内声明变量，必须要以 var 声明</li><li>全局变量：函数外声明的变量.</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">函数名</span>([参数[,参数...]])&#123;<br>&lt;语句组&gt;<br>[<span class="hljs-keyword">return</span> <span class="hljs-type">&lt;表达式&gt;；]</span><br>&#125; <br></code></pre></td></tr></table></figure><ul><li><p>全局变量不需要以 var 关键字进行声明，但局部变量则必须<br>以此关键字来声明。(建议所有变量都采用var声明)  Javascript没有块级作用域</p></li><li><p>+：如果操作数都是数字时执行加法运算，如果其中的操作数有字符串时，会执行连接字符串的作用</p></li><li>？：</li><li>typeof</li></ul><div class="table-container"><table><thead><tr><th>eval(string)</th><th>计算javascript代码串，把对应的字符串解析成JS代码并运行</th></tr></thead><tbody><tr><td>isNaN()</td><td>检测一个值是否是非数字的值</td></tr><tr><td>parseInt()</td><td>将字符串转换为整数</td></tr><tr><td>parseFloat()</td><td>将字符串转换为数字</td></tr><tr><td>alert()</td><td>弹出对话框显示消息</td></tr><tr><td>confirm()</td><td>用对话框询问一个回答为是或否的问题</td></tr><tr><td>prompt()</td><td>弹出对话框，请求用户输入一个字符串</td></tr><tr><td>document.write()</td><td>向文档窗口输出字符串</td></tr></tbody></table></div><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>W3C 文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问、更新文档的内容、结构和样式。</p><p>属性是您能够获取或设置的值（就比如改变 HTML 元素的内容）。</p><p>方法是您能够完成的动作（比如添加或删除 HTML 元素）。</p><ul><li>查找 HTML 元素</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">document.getElementById(<em>id</em>)</td><td style="text-align:left">通过元素 id 来查找元素</td></tr><tr><td style="text-align:left">document.getElementsByTagName(<em>name</em>)</td><td style="text-align:left">通过标签名来查找元素</td></tr><tr><td style="text-align:left">document.getElementsByClassName(<em>name</em>)</td><td style="text-align:left">通过类名来查找元素</td></tr></tbody></table></div><ul><li>改变 HTML 元素</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">element.innerHTML = <em>new html content</em></td><td style="text-align:left">改变元素的 inner HTML</td></tr><tr><td style="text-align:left">element.attribute = <em>new value</em></td><td style="text-align:left">改变 HTML 元素的属性值</td></tr><tr><td style="text-align:left">element.setAttribute(<em>attribute</em>, <em>value</em>)</td><td style="text-align:left">改变 HTML 元素的属性值</td></tr><tr><td style="text-align:left">element.style.property = <em>new style</em></td><td style="text-align:left">改变 HTML 元素的样式</td></tr></tbody></table></div><ul><li>添加删除</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">document.createElement(<em>element</em>)</td><td style="text-align:left">创建 HTML 元素</td></tr><tr><td style="text-align:left">document.removeChild(<em>element</em>)</td><td style="text-align:left">删除 HTML 元素</td></tr><tr><td style="text-align:left">document.appendChild(<em>element</em>)</td><td style="text-align:left">添加 HTML 元素</td></tr><tr><td style="text-align:left">document.replaceChild(<em>element</em>)</td><td style="text-align:left">替换 HTML 元素</td></tr><tr><td style="text-align:left">document.write(<em>text</em>)</td><td style="text-align:left">写入 HTML 输出流</td></tr></tbody></table></div><ul><li>添加事件处理程序</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">document.getElementById(id).onclick = function(){<em>code</em>}</td><td style="text-align:left">向 onclick 事件添加事件处理程序</td></tr></tbody></table></div><h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><ul><li>主要的 jQuery 函数为： $() 函数（jQuery 函数）。通过向该函数传递 DOM 对象，返回 jQuery 对象，使用 jQuery的 功能。</li><li>jQuery 允许通过 CSS 选择器来选取元素。</li><li>在 JavaScript 中，可以分配一个函数以处理窗口加载事件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html">下载jQuery库，地址 http://jquery.com/<br>注意不同的库版本<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;jquery-2.1.4.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>从 CDN 中载入 jQuery, 如从 Google 中加载 jQuery<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>   <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://code.jquery.com/jquery-3.3.1.min.js&quot;</span>   <span class="hljs-attr">integrity</span>=<span class="hljs-string">&quot;sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=&quot;</span>   <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">&quot;anonymous&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>//<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">“https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js”</span>&gt;</span><span class="javascript"><span class="hljs-comment">//百度</span></span><br><span class="javascript"></span><br></code></pre></td></tr></table></figure><ul><li><p>基础语法是：<code>$(selector).action()</code></p><p>美元符号定义 jQuery<br>选择符（selector）“查询”和“查找” HTML 元素<br>jQuery 的 action() 执行对元素的操作</p></li></ul><h2 id="选择器-1"><a href="#选择器-1" class="headerlink" title="选择器"></a>选择器</h2><ul><li><p>jQuery 使用 CSS 选择器来选取 HTML 元素。</p><p><code>$(&quot;p&quot;)</code>选取<code>&lt;p&gt;</code> 元素。</p><p><code>$(&quot;p.intro&quot;)</code>选取所有 class=”intro” 的<code>&lt;p&gt;</code> 元素。</p><p><code>$(&quot;p#demo&quot;)</code>选取所有 id=”demo” 的<code>&lt;p&gt;</code>元素。</p></li><li><p>jQuery 使用 XPath 表达式来选择带有给定属性的元素。</p><p><code>$(&quot;[href]&quot;)</code> 选取所有带有 href 属性的元素。</p><p><code>$(&quot;[href=&#39;#&#39;]&quot;)</code>选取所有带有 href 值等于 “#” 的元素。</p><p><code>$(&quot;[href!=&#39;#&#39;]&quot;)</code>选取所有带有 href 值不等于 “#” 的元素。</p><p><code>$(&quot;[href$=&#39;.jpg&#39;]&quot;)</code> 选取所有 href 值以 “.jpg” 结尾的元素。</p></li><li><p>jQuery CSS 选择器可用于改变 HTML 元素的 CSS 属性。</p><p><code>$(&quot;p&quot;).css(&quot;background-color&quot;,&quot;red&quot;);</code>把所有 p 元素的背景颜色更改为红色</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">语法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">$(this)</td><td style="text-align:left">当前 HTML 元素</td></tr><tr><td style="text-align:left">$(“p”)</td><td style="text-align:left">所有 <code>&lt;p&gt;</code>元素</td></tr><tr><td style="text-align:left">$(“p.intro”)</td><td style="text-align:left">所有 class=”intro” 的 <code>&lt;p&gt;</code>元素</td></tr><tr><td style="text-align:left">$(“.intro”)</td><td style="text-align:left">所有 class=”intro” 的元素</td></tr><tr><td style="text-align:left">$(“#intro”)</td><td style="text-align:left">id=”intro” 的元素</td></tr><tr><td style="text-align:left">$(“ul li:first”)</td><td style="text-align:left">每个 <code>&lt;ul&gt;</code> 的第一个<code>&lt;li&gt;</code> 元素</td></tr><tr><td style="text-align:left">$(“[href$=’.jpg’]”)</td><td style="text-align:left">所有带有以 “.jpg” 结尾的属性值的 href 属性</td></tr><tr><td style="text-align:left">$(“div#intro .head”)</td><td style="text-align:left">id=”intro” 的<code>&lt;div&gt;</code> 元素中的所有 class=”head” 的元素</td></tr></tbody></table></div><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul><li><p>由于 jQuery 是为处理 HTML 事件而特别设计的，最好</p><ul><li>把所有 jQuery 代码置于事件处理函数中</li><li>把所有事件处理函数置于文档就绪事件处理器中</li><li>把 jQuery 代码置于单独的 .js 文件中</li><li>如果存在名称冲突，则重命名 jQuery 库</li></ul></li><li><p>jQuery 名称冲突</p><p>jQuery 使用 $ 符号作为 jQuery 的简介方式。</p><p>某些其他 JavaScript 库中的函数（比如 Prototype）同样使用 $ 符号。</p><p>jQuery 使用名为 noConflict() 的方法来解决该问题。</p><p><code>var jq=jQuery.noConflict()</code>，帮助您使用自己的名称（比如 jq）来代替 $ 符号。</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">Event 函数</th><th style="text-align:left">绑定函数至</th></tr></thead><tbody><tr><td style="text-align:left">$(document).ready(function)</td><td style="text-align:left">将函数绑定到文档的就绪事件（当文档完成加载时）</td></tr><tr><td style="text-align:left">$(selector).click(function)</td><td style="text-align:left">触发或将函数绑定到被选元素的点击事件</td></tr><tr><td style="text-align:left">$(selector).dblclick(function)</td><td style="text-align:left">触发或将函数绑定到被选元素的双击事件</td></tr><tr><td style="text-align:left">$(selector).focus(function)</td><td style="text-align:left">触发或将函数绑定到被选元素的获得焦点事件</td></tr><tr><td style="text-align:left">$(selector).mouseover(function)</td><td style="text-align:left">触发或将函数绑定到被选元素的鼠标悬停事件</td></tr></tbody></table></div><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ul><li><code>$(selector).hide/show(speed,callback);</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">  $(<span class="hljs-string">&quot;#hide&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">  $(<span class="hljs-string">&quot;p&quot;</span>).hide(<span class="hljs-number">1000</span>);</span><br><span class="javascript">  &#125;);</span><br><span class="javascript">  $(<span class="hljs-string">&quot;#show&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">  $(<span class="hljs-string">&quot;p&quot;</span>).show(<span class="hljs-number">500</span>);</span><br><span class="javascript">  &#125;);</span><br><span class="javascript">&#125;);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>toggle(speed,callback)</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">  $(<span class="hljs-string">&quot;button&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">  $(<span class="hljs-string">&quot;p&quot;</span>).toggle(<span class="hljs-number">1000</span>);</span><br><span class="javascript">  &#125;);</span><br><span class="javascript">&#125;);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>fadeIn(speed,callback)</code></li><li><code>fadeOut(speed,callback)</code></li><li><code>fadeToggle(speed,callback)</code></li><li><code>fadeTo(speed,opacity,callback)</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">  $(<span class="hljs-string">&quot;button&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    $(<span class="hljs-string">&quot;#div1&quot;</span>).fadeToggle();</span><br><span class="javascript">    $(<span class="hljs-string">&quot;#div2&quot;</span>).fadeToggle(<span class="hljs-string">&quot;slow&quot;</span>);</span><br><span class="javascript">    $(<span class="hljs-string">&quot;#div3&quot;</span>).fadeToggle(<span class="hljs-number">3000</span>);</span><br><span class="javascript">  &#125;);</span><br><span class="javascript">&#125;);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>slideDown()\slideUp()\slideToggle()</code></li></ul><h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JSP是Servlet API的一个扩展。JSP在处理请求之前都要编译成Servlet，所以它具有Servlet的所有优势，包括访问Java API。服务器上的JSP程序负责处理客户端的请求，其程序代码对于客户端来说不可见。 </p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>JSP所有的程序都在服务器端运行，服务器端收到用户通过浏览器提交的请求，经过一定处理后再以HTML的形式返回给客户端，客户端得到的只是在浏览器中看到的静态网页。</p><h2 id="交互步骤"><a href="#交互步骤" class="headerlink" title="交互步骤"></a>交互步骤</h2><ol><li>客户端和服务器建立连接</li><li>客户端发送请求</li><li>服务器发出响应</li><li>关闭连接</li></ol><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220225090115596.png" alt="JSP与客户端的交互步骤" style="zoom:60%;" /></p><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><h1 id="新技术"><a href="#新技术" class="headerlink" title="新技术"></a>新技术</h1><h1 id="课程考核相关"><a href="#课程考核相关" class="headerlink" title="课程考核相关"></a>课程考核相关</h1><h2 id="课程考核"><a href="#课程考核" class="headerlink" title="课程考核"></a>课程考核</h2><ul><li>30%平时+30%实验+40%软件</li><li>实验一：HTML 5 + CSS + JavaScript</li><li>实验二：动态Web页面设计实验</li><li>实验三：Web数据库实验</li><li>实验四：网站设计及实现实验</li><li>详见《考察成果要求》</li></ul><h2 id="课前分享"><a href="#课前分享" class="headerlink" title="课前分享"></a>课前分享</h2><ul><li>XML与XHTML</li><li>MySQL</li><li>正则表达式</li><li>网站建设</li><li>网站快速开发技术</li><li>Web领域中“传奇”人物</li><li>自己提一个相关的题目 </li><li>展示一些自己的作品</li></ul>]]></content>
    
    
    <categories>
      
      <category>CUMT课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>CSS</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python数据分析与展示</title>
    <link href="/2022/02/09/%E3%80%8APython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%B1%95%E7%A4%BA%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/02/09/%E3%80%8APython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%B1%95%E7%A4%BA%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学习选择</p><p>基础：先看的这个，<a href="https://www.icourse163.org/course/BIT-1001870002?tid=1462344444">Python数据分析与展示，北京理工大学，中国大学MOOC(慕课) (icourse163.org)</a></p></blockquote><h1 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h1><h2 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h2><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220209120433655.png"  style="zoom:67%;" /></p><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220209120605903.png" style="zoom:67%;" /></p><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220209120638406.png"  style="zoom:67%;" /></p><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220209120736609.png"  style="zoom:67%;" /></p><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220209121143397.png"  style="zoom:67%;" /></p><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220209121252867.png" style="zoom:67%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#原数组不变</span><br>new_a = a.astype(new_type)<br><span class="hljs-comment">#转list</span><br>ls = a.tolist()<br><br><span class="hljs-comment">#补充</span><br>b[(b&gt;=<span class="hljs-number">60</span>) &amp; (b&lt;=<span class="hljs-number">80</span>)]<br><span class="hljs-comment"># 显示60~80间的数据, 此处用&amp;, 不能用and</span><br>b[(b&lt;<span class="hljs-number">60</span>) | (b&gt;<span class="hljs-number">90</span>)]<br><span class="hljs-comment"># 显示&lt;60  或 &gt;90的数据,此处用|, 不能用or</span><br>b[~(b&lt;<span class="hljs-number">60</span>)]<br><span class="hljs-comment"># ~非, 显示 &gt;=60的数据)</span><br><br>b&lt;<span class="hljs-number">70</span><br>np.where(b&lt;<span class="hljs-number">70</span>,b,<span class="hljs-number">0</span>)<br><br>b.T() <span class="hljs-comment"># 矩阵转置</span><br>b.I() <span class="hljs-comment"># 矩阵的逆</span><br></code></pre></td></tr></table></figure><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220209121757500.png" style="zoom:67%;" /></p><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220209125542168.png" style="zoom:67%;" /></p><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220209125714166.png"  style="zoom:67%;" /></p><ul><li>随机数</li></ul><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220209131258858.png"  style="zoom:67%;" /></p><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220209131653651.png" style="zoom:67%;" /></p><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220209132009671.png" style="zoom:67%;" /></p><ul><li>统计函数</li></ul><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/2233157-b77105789e36c847.jpg"  style="zoom:67%;" /></p><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220209132916324.png" style="zoom:67%;" /></p><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220209133037338.png" style="zoom:67%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#梯度 np.gradient(f) #两侧/一侧、偏导</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>c = np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">20</span>,(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(c)<br>c_grad = np.gradient(c)<br><span class="hljs-built_in">print</span>(c_grad)<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">[[13  6  9 19]</span><br><span class="hljs-string"> [ 4  4 16  4]</span><br><span class="hljs-string"> [13  7  2  3]]</span><br><span class="hljs-string">[array([[ -9. ,  -2. ,   7. , -15. ],</span><br><span class="hljs-string">        [  0. ,   0.5,  -3.5,  -8. ],</span><br><span class="hljs-string">        [  9. ,   3. , -14. ,  -1. ]]),</span><br><span class="hljs-string"> array([[ -7. ,  -2. ,   6.5,  10. ],</span><br><span class="hljs-string">        [  0. ,   6. ,   0. , -12. ],</span><br><span class="hljs-string">        [ -6. ,  -5.5,  -2. ,   1. ]])]</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h2><ul><li>csv只能有效存储一维、二维数组</li></ul><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220209130057579.png" style="zoom:67%;" /></p><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220209130302550.png" style="zoom:67%;" /></p><ul><li>任意维度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#1.</span><br><span class="hljs-comment">#sep=&#x27;&#x27;时，存取的是二进制文件</span><br>a.tofile(<span class="hljs-string">&quot;b.dat&quot;</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%d&#x27;</span>)<br>np.fromfile(<span class="hljs-string">&quot;b.dat&quot;</span>, dtype=np.<span class="hljs-built_in">int</span>, sep=<span class="hljs-string">&#x27;,&#x27;</span>, count=-<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">#2.便携文件存储</span><br><span class="hljs-comment">#存取文件扩展名.npy/.npz</span><br>np.save(fname, array)<br>np.load(frame)<br></code></pre></td></tr></table></figure><h1 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h1><h1 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h1>]]></content>
    
    
    <categories>
      
      <category>课外学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python网络爬虫</title>
    <link href="/2022/02/06/%E3%80%8APython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/02/06/%E3%80%8APython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学习选择</p><p>基础：先看的这个，基础操作，用的idle，有些跳了步骤，可能东西比较老（requests、解析（beautiful）、Re、Scrapy）<a href="https://www.icourse163.org/course/BIT-1001870002?tid=1462344444">Python数据分析与展示，北京理工大学，中国大学MOOC(慕课) (icourse163.org)</a></p><p>进阶：<strong>建议不如直接看这个</strong>，讲得更细节，用的pycharm，东北老师，讲课老精神了（直接看p51-104，对于基础，补充了Urllib、解析（xpath、jsonpath）、selenium）<a href="https://www.bilibili.com/video/BV1Db4y1m7Ho?p=71">尚硅谷Python爬虫教程小白零基础速通（含python基础+爬虫案例），哔哩哔哩，bilibili</a></p></blockquote><h1 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h1><h2 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h2><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220208160917249.png" style="zoom:67%;" /></p><ul><li>get</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#urllib.parse.quote()</span><br><span class="hljs-keyword">import</span> urllib.request<br><span class="hljs-keyword">import</span> urllib.parse<br>url = <span class="hljs-string">&#x27;https://www.baidu.com/s?wd=&#x27;</span><br>headers = &#123;<br><span class="hljs-string">&#x27;User‐Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&#x27;</span><br>&#125;<br>url = url + urllib.parse.quote(<span class="hljs-string">&#x27;小野&#x27;</span>)<br>request = urllib.request.Request(url=url,headers=headers)<br>response = urllib.request.urlopen(request)<br><span class="hljs-built_in">print</span>(response.read().decode(<span class="hljs-string">&#x27;utf‐8&#x27;</span>))<br><br><span class="hljs-comment">#urllib.parse.urlencode（）</span><br><span class="hljs-keyword">import</span> urllib.request<br><span class="hljs-keyword">import</span> urllib.parse<br>url = <span class="hljs-string">&#x27;http://www.baidu.com/s?&#x27;</span><br>data = &#123;<br><span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;小刚&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;男&#x27;</span>,<br>&#125;<br>data = urllib.parse.urlencode(data)<br>url = url + data<br><span class="hljs-built_in">print</span>(url)<br>headers = &#123;<br><span class="hljs-string">&#x27;User‐Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&#x27;</span><br>&#125;<br>request = urllib.request.Request(url=url,headers=headers)<br></code></pre></td></tr></table></figure><ul><li>post</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.request<br><span class="hljs-keyword">import</span> urllib.parse<br>url = <span class="hljs-string">&#x27;https://fanyi.baidu.com/sug&#x27;</span><br>headers = &#123;<br>    <span class="hljs-string">&#x27;user‐agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&#x27;</span><br>&#125;<br>keyword = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入您要查询的单词&#x27;</span>)<br>data = &#123;<br><span class="hljs-string">&#x27;kw&#x27;</span>:keyword<br>&#125;<br>data = urllib.parse.urlencode(data).encode(<span class="hljs-string">&#x27;utf‐8&#x27;</span>)<br>request = urllib.request.Request(url=url,headers=headers,data=data)<br>response = urllib.request.urlopen(request)<br><span class="hljs-built_in">print</span>(response.read().decode(<span class="hljs-string">&#x27;utf‐8&#x27;</span>))<br><br><span class="hljs-keyword">import</span> json<br><span class="hljs-comment"># loads将字符串转换为python对象</span><br>obj = json.loads(content)<br><span class="hljs-comment"># python对象转换为json字符串 ensure_ascii=False 忽略字符集编码</span><br>s = json.dumps(obj,ensure_ascii=<span class="hljs-literal">False</span>)<br><span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure><ul><li>ajax的get请求(前后端分离的情况,可以拿到json)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 爬取豆瓣电影前10页数据</span><br><span class="hljs-comment"># https://movie.douban.com/j/chart/top_list?type=20&amp;interval_id=100%3A90&amp;action=&amp;start=0&amp;limit=20</span><br><br><span class="hljs-keyword">import</span> urllib.request<br><span class="hljs-keyword">import</span> urllib.parse<br><br><span class="hljs-comment"># 下载前10页数据</span><br><span class="hljs-comment"># 下载的步骤：1.请求对象的定制 2.获取响应的数据 3.下载</span><br><span class="hljs-comment"># 每执行一次返回一个request对象</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_request</span>(<span class="hljs-params">page</span>):</span><br>base_url = <span class="hljs-string">&#x27;https://movie.douban.com/j/chart/top_list?type=20&amp;interval_id=100%3A90&amp;action=&amp;&#x27;</span><br>headers = &#123;<br><span class="hljs-string">&#x27;User‐Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&#x27;</span><br>&#125;<br>    data=&#123;<br>        <span class="hljs-string">&#x27;start&#x27;</span>:(page‐<span class="hljs-number">1</span>)*<span class="hljs-number">20</span>,<br>        <span class="hljs-string">&#x27;limit&#x27;</span>:<span class="hljs-number">20</span><br>    &#125;<br>    <span class="hljs-comment"># data编码</span><br>    data = urllib.parse.urlencode(data)<br>    url = base_url + data<br>    request = urllib.request.Request(url=url,headers=headers)<br>    <span class="hljs-keyword">return</span> request<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_content</span>(<span class="hljs-params">request</span>):</span><br>    response = urllib.request.urlopen(request)<br>    content = response.read().decode(<span class="hljs-string">&#x27;utf‐8&#x27;</span>)<br>    <span class="hljs-keyword">return</span> content<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">down_load</span>(<span class="hljs-params">page,content</span>):</span><br>    <span class="hljs-comment"># with open（文件的名字，模式，编码）as fp:</span><br>    <span class="hljs-comment"># fp.write(内容)</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;douban_&#x27;</span>+<span class="hljs-built_in">str</span>(page)+<span class="hljs-string">&#x27;.json&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf‐8&#x27;</span>)<span class="hljs-keyword">as</span> fp:<br>    fp.write(content)<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    start_page = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入起始页码&#x27;</span>))<br>    end_page = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入结束页码&#x27;</span>))<br>    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start_page,end_page+<span class="hljs-number">1</span>):<br>    request = create_request(page)<br>    content = get_content(request)<br>    down_load(page,content)<br></code></pre></td></tr></table></figure><ul><li><p>异常错误</p><ol><li>HTTPError类是URLError类的子类</li><li>导入的包urllib.error.HTTPError urllib.error.URLError</li><li>http错误：http错误是针对浏览器无法连接到服务器而增加出来的错误提示。引导并告诉浏览者该页是哪里出 了问题。</li><li>通过urllib发送请求的时候，有可能会发送失败，这个时候如果想让你的代码更加的健壮，可以通过try‐ except进行捕获异常，异常有两类，URLError\HTTPError</li></ol></li><li><p>cookie登录</p><ol><li>cookie 跳过登录</li><li>refer 防盗链</li></ol></li><li>handle 定制更高级的请求头（随着业务逻辑的复杂 请求对象的定制已经满足不了我们的需求（动态cookie和代理 不能使用请求对象的定制）</li><li>代理服务器（突破自身IP访问限制，访问国外站点。访问一些单位或团体内部资源。提高访问速度。隐藏真实IP）(代理池\快代理)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.request<br>url = <span class="hljs-string">&#x27;http://www.baidu.com/s?wd=ip&#x27;</span><br>headers = &#123;<br><span class="hljs-string">&#x27;User ‐ Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla / 5.0(Windows NT 10.0;Win64;x64) AppleWebKit / 537.36(KHTML, like Gecko) Chrome / 74.0.3729.169Safari / 537.36&#x27;</span><br>&#125;<br>request = urllib.request.Request(url=url,headers=headers)<br>proxies = &#123;<span class="hljs-string">&#x27;http&#x27;</span>:<span class="hljs-string">&#x27;117.141.155.244:53281&#x27;</span>&#125;<br>handler = urllib.request.ProxyHandler(proxies=proxies)<br>opener = urllib.request.build_opener(handler)<br>response = opener.<span class="hljs-built_in">open</span>(request)<br>content = response.read().decode(<span class="hljs-string">&#x27;utf‐8&#x27;</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;daili.html&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf‐8&#x27;</span>)<span class="hljs-keyword">as</span> fp:<br>fp.write(content)<br></code></pre></td></tr></table></figure><h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><p><img src="https://s2.loli.net/2022/02/06/y4Jae2OriWfUgDK.png" style="zoom: 67%;" /></p><p><img src="https://s2.loli.net/2022/02/06/XaKJYEPZCgIF7qR.png" style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2022/02/06/nldsfZD1eJ8hcHK.png" style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2022/02/06/6VxtmPieTaAk3N4.png"  style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2022/02/06/yS4AEgRn5IFNmhC.png" style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2022/02/06/Yr1KXAeq7HjnpSW.png" style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2022/02/06/bV8Iwk7qiHZMKvR.png"  style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2022/02/06/yQjRklAz4Sq8GVU.png" style="zoom:67%;" /></p><ul><li>代理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">proxy = &#123;<span class="hljs-string">&#x27;http&#x27;</span>:<span class="hljs-string">&#x27;219.149.59.250:9797&#x27;</span>&#125;<br>r = requests.get(url=url,params=data,headers=headers,proxies=proxy)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getHTMLText</span>(<span class="hljs-params">url</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        r=requests.get(url, timeout=<span class="hljs-number">30</span>)<br>        r.raise_for_status()<br>        <span class="hljs-comment">#如果状态不是200，引发HTTPError异常</span><br>        r.encoding=r.apparent_encoding<br>        <span class="hljs-keyword">return</span> r.text<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;产生异常&quot;</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    url = <span class="hljs-string">&quot;http://www.baidu.com&quot;</span><br><span class="hljs-built_in">print</span>(getHTMLText(url))<br><br><span class="hljs-comment">#实例2：亚马逊商品页面的爬取</span><br><span class="hljs-keyword">import</span> requests<br>url = <span class="hljs-string">&quot;https://www.amazon.cn/gp/product/B01M8L5Z3Y&quot;</span><br><span class="hljs-keyword">try</span>:<br>    kv = &#123;<span class="hljs-string">&#x27;user-agent&#x27;</span>:<span class="hljs-string">&#x27;Mozilla/5.0&#x27;</span>&#125;<br>    r = requests.get(url, headers=kv)<br>    r.raise_for_status()<br>    r.encoding = r.apparent_encoding<br>    <span class="hljs-built_in">print</span>(r.text[<span class="hljs-number">1000</span>:<span class="hljs-number">2000</span>])<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;爬取失败&quot;</span>)<br><br><span class="hljs-comment">#实例3：百度/360搜索关键字提交</span><br><span class="hljs-keyword">import</span> requests<br>keyword = <span class="hljs-string">&quot;Python&quot;</span><br>url =<span class="hljs-string">&#x27;http://www.baidu.com/s&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    kv = &#123;<span class="hljs-string">&#x27;wd&#x27;</span>: <span class="hljs-string">&#x27;keyword&#x27;</span>&#125;<br>    r = requests.get(url, params=kv)<br>    <span class="hljs-built_in">print</span>(r.status_code)<br>    <span class="hljs-built_in">print</span>(r.request.url)<br>    r.raise_for_status()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(r.text))<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;爬取失败&quot;</span>)<br>    <br><span class="hljs-comment">#网络图片的爬取和存储</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> os<br>url = <span class="hljs-string">&quot;http://xwzx.cumt.edu.cn/_upload/article/images/2f/99/d44299934d00afe8f03684d5c59b/f682d3bc-972c-4d5a-9542-c52e0b72032f.jpg&quot;</span><br>root = <span class="hljs-string">&quot;D://pics//&quot;</span><br>path = root + url.split(<span class="hljs-string">&#x27;/&#x27;</span>)[-<span class="hljs-number">1</span>]<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(root):<br>        os.mkdir(root)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(path):<br>        r = requests.get(url)<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(r.content)<br>            f.close()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文件保存成功&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文件已存在&quot;</span>)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;爬取失败&quot;</span>)<br><br><span class="hljs-comment">#实例5：IP地址归属地的自动查询</span><br><span class="hljs-keyword">import</span> requests<br>url = <span class="hljs-string">&quot;https://ipchaxun.com/&quot;</span><br><span class="hljs-keyword">try</span>:<br>    r = requests.get(url+<span class="hljs-string">&#x27;202.204.80.112&#x27;</span>)<br>    r.raise_for_status()<br>    r.encoding = r.apparent_encoding<br>    <span class="hljs-built_in">print</span>(r.text[-<span class="hljs-number">500</span>:])<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;爬取失败&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><h2 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h2><ul><li><p>xpath基本语法</p><ol><li><p>路径查询</p><p> //：查找所有子孙节点，不考虑层级关系 </p><p>/ ：找直接子节点</p></li><li><p>谓词查询 </p><p>//div[@id]</p><p> //div[@id=”maincontent”] </p></li><li><p>属性查询</p><p> //@class </p></li><li><p>模糊查询 </p><p>//div[contains(@id, “he”)]</p><p> //div[starts‐with(@id, “he”)]</p></li><li><p>内容查询 </p><p>//div/h1/text()</p></li><li><p>逻辑运算 </p><p>//div[@id=”head” and @class=”s_down”]</p><p>//title | //price （其实这是列表的用法）</p></li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><span class="hljs-comment">#解析本地文件</span><br>html_tree = etree.parse(<span class="hljs-string">&#x27;XX.html&#x27;</span>)<br><span class="hljs-comment">#服务器响应文件</span><br>html_tree = etree.HTML(response.read().decode(<span class="hljs-string">&#x27;utf‐8&#x27;</span>)<br>html_tree.xpath([xpath路径])<br></code></pre></td></tr></table></figure><h2 id="jsonpath"><a href="#jsonpath" class="headerlink" title="jsonpath"></a>jsonpath</h2><p>教程连接（<a href="http://blog.csdn.net/luxideyao/article/details/77802389）">http://blog.csdn.net/luxideyao/article/details/77802389）</a></p><h2 id="Beautiful-Soup"><a href="#Beautiful-Soup" class="headerlink" title="Beautiful Soup"></a>Beautiful Soup</h2><p><img src="https://s2.loli.net/2022/02/06/Kkmhg8qZSUITBGQ.png" style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2022/02/06/K5LNoJG2VsDctzB.png" style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2022/02/06/hfmyXuoV5dTLl8Q.png" style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2022/02/06/JtE7syTib1vWk6P.png" style="zoom:67%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#CrawUnivRanking.py</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> bs4<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getHTMLText</span>(<span class="hljs-params">url</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        r = requests.get(url, timeout=<span class="hljs-number">30</span>)<br>        r.raise_for_status()<br>        r.encoding = r.apparent_encoding<br>        <span class="hljs-keyword">return</span> r.text<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fillUnivList</span>(<span class="hljs-params">ulist, html</span>):</span><br>    soup = BeautifulSoup(html, <span class="hljs-string">&quot;html.parser&quot;</span>)<br>    <span class="hljs-keyword">for</span> tr <span class="hljs-keyword">in</span> soup.find(<span class="hljs-string">&#x27;tbody&#x27;</span>).children:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(tr, bs4.element.Tag):<br>            tds = tr(<span class="hljs-string">&#x27;td&#x27;</span>)<br>            ulist.append([tds[<span class="hljs-number">0</span>].string, tds[<span class="hljs-number">1</span>].string, tds[<span class="hljs-number">3</span>].string])<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printUnivList</span>(<span class="hljs-params">ulist, num</span>):</span><br>    tplt = <span class="hljs-string">&quot;&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^10&#125;\t&#123;2:^10&#125;&quot;</span><br>    <span class="hljs-built_in">print</span>(tplt.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;排名&quot;</span>,<span class="hljs-string">&quot;学校名称&quot;</span>,<span class="hljs-string">&quot;总分&quot;</span>,<span class="hljs-built_in">chr</span>(<span class="hljs-number">12288</span>)))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num):<br>        u=ulist[i]<br>        <span class="hljs-built_in">print</span>(tplt.<span class="hljs-built_in">format</span>(u[<span class="hljs-number">0</span>],u[<span class="hljs-number">1</span>],u[<span class="hljs-number">2</span>],<span class="hljs-built_in">chr</span>(<span class="hljs-number">12288</span>)))<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    uinfo = []<br>    url = <span class="hljs-string">&#x27;https://www.zuihaodaxue.cn/zuihaodaxuepaiming2016.html&#x27;</span><br>    html = getHTMLText(url)<br>    fillUnivList(uinfo, html)<br>    printUnivList(uinfo, <span class="hljs-number">20</span>) <span class="hljs-comment"># 20 univs</span><br>main()<br></code></pre></td></tr></table></figure><h2 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h2><p><img src="https://s2.loli.net/2022/02/06/b8H5g6Lv7VCXxGn.png" style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2022/02/06/5CEwfnGBL73dSpc.png" style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2022/02/06/inYpyLteGKQoIBR.png"  style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2022/02/06/I9y6UAKVsu5BCZo.png" style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2022/02/06/FKyVemjPzCSbTO7.png" style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2022/02/06/RGWbYF29I8Ljkqf.png"  style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2022/02/06/4Rapl59VjyGEFUh.png" style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2022/02/06/Ob9xqz2kFimZGRL.png" style="zoom:67%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#CrowTaobaoPrice.py</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getHTMLText</span>(<span class="hljs-params">url</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        kv = \<br>            &#123;<br>                <span class="hljs-string">&#x27;user-agent&#x27;</span>:<span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36 Edg/97.0.1072.76&#x27;</span>,<br>                <span class="hljs-string">&#x27;Cookie&#x27;</span>:<span class="hljs-string">&#x27;【去审查元素自己看看】&#x27;</span><br>            &#125;<br>        r = requests.get(url, timeout=<span class="hljs-number">30</span>, headers=kv)<br>        r.raise_for_status()<br>        r.encoding = r.apparent_encoding<br>        <span class="hljs-keyword">return</span> r.text<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;getHTMLText&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parsePage</span>(<span class="hljs-params">ilt, html</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        plt = re.findall(<span class="hljs-string">r&#x27;\&quot;view_price\&quot;\:\&quot;[\d\.]*\&quot;&#x27;</span>,html)<br>        tlt = re.findall(<span class="hljs-string">r&#x27;\&quot;raw_title\&quot;\:\&quot;.*?\&quot;&#x27;</span>,html)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(plt)):<br>            price = <span class="hljs-built_in">eval</span>(plt[i].split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">1</span>])<br>            title = <span class="hljs-built_in">eval</span>(tlt[i].split(<span class="hljs-string">&#x27;:&#x27;</span>)[<span class="hljs-number">1</span>])<br>            ilt.append([price , title])<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;parsePage&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printGoodsList</span>(<span class="hljs-params">ilt</span>):</span><br>    tplt = <span class="hljs-string">&quot;&#123;:4&#125;\t&#123;:8&#125;\t&#123;:16&#125;&quot;</span><br>    <span class="hljs-built_in">print</span>(tplt.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;序号&quot;</span>, <span class="hljs-string">&quot;价格&quot;</span>, <span class="hljs-string">&quot;商品名称&quot;</span>))<br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> g <span class="hljs-keyword">in</span> ilt:<br>        count = count + <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(tplt.<span class="hljs-built_in">format</span>(count, g[<span class="hljs-number">0</span>], g[<span class="hljs-number">1</span>]))<br>        <br>goods = <span class="hljs-string">&#x27;书包&#x27;</span><br>depth = <span class="hljs-number">3</span><br>start_url = <span class="hljs-string">&#x27;https://s.taobao.com/search?q=&#x27;</span> + goods<br>infoList = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(depth):<br>    <span class="hljs-keyword">try</span>:<br>        url = start_url + <span class="hljs-string">&#x27;&amp;s=&#x27;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-number">44</span>*i)<br>        html = getHTMLText(url)<br>        parsePage(infoList, html)<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">continue</span><br>printGoodsList(infoList)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#CrawBaiduStocksB.py</span><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> traceback<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getHTMLText</span>(<span class="hljs-params">url, code=<span class="hljs-string">&quot;utf-8&quot;</span></span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        r = requests.get(url)<br>        r.raise_for_status()<br>        r.encoding = code<br>        <span class="hljs-keyword">return</span> r.text<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getStockList</span>(<span class="hljs-params">lst, stockURL</span>):</span><br>    html = getHTMLText(stockURL, <span class="hljs-string">&quot;GB2312&quot;</span>)<br>    soup = BeautifulSoup(html, <span class="hljs-string">&#x27;html.parser&#x27;</span>) <br>    a = soup.find_all(<span class="hljs-string">&#x27;a&#x27;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:<br>        <span class="hljs-keyword">try</span>:<br>            href = i.attrs[<span class="hljs-string">&#x27;href&#x27;</span>]<br>            lst.append(re.findall(<span class="hljs-string">r&quot;[s][hz]\d&#123;6&#125;&quot;</span>, href)[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">continue</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getStockInfo</span>(<span class="hljs-params">lst, stockURL, fpath</span>):</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> stock <span class="hljs-keyword">in</span> lst:<br>        url = stockURL + stock + <span class="hljs-string">&quot;.html&quot;</span><br>        html = getHTMLText(url)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">if</span> html==<span class="hljs-string">&quot;&quot;</span>:<br>                <span class="hljs-keyword">continue</span><br>            infoDict = &#123;&#125;<br>            soup = BeautifulSoup(html, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>            stockInfo = soup.find(<span class="hljs-string">&#x27;div&#x27;</span>,attrs=&#123;<span class="hljs-string">&#x27;class&#x27;</span>:<span class="hljs-string">&#x27;stock-bets&#x27;</span>&#125;)<br><br>            name = stockInfo.find_all(attrs=&#123;<span class="hljs-string">&#x27;class&#x27;</span>:<span class="hljs-string">&#x27;bets-name&#x27;</span>&#125;)[<span class="hljs-number">0</span>]<br>            infoDict.update(&#123;<span class="hljs-string">&#x27;股票名称&#x27;</span>: name.text.split()[<span class="hljs-number">0</span>]&#125;)<br>            <br>            keyList = stockInfo.find_all(<span class="hljs-string">&#x27;dt&#x27;</span>)<br>            valueList = stockInfo.find_all(<span class="hljs-string">&#x27;dd&#x27;</span>)<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(keyList)):<br>                key = keyList[i].text<br>                val = valueList[i].text<br>                infoDict[key] = val<br>            <br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(fpath, <span class="hljs-string">&#x27;a&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                f.write( <span class="hljs-built_in">str</span>(infoDict) + <span class="hljs-string">&#x27;\n&#x27;</span> )<br>                count = count + <span class="hljs-number">1</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\r当前进度: &#123;:.2f&#125;%&quot;</span>.<span class="hljs-built_in">format</span>(count*<span class="hljs-number">100</span>/<span class="hljs-built_in">len</span>(lst)),end=<span class="hljs-string">&quot;&quot;</span>)<br>        <span class="hljs-keyword">except</span>:<br>            count = count + <span class="hljs-number">1</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\r当前进度: &#123;:.2f&#125;%&quot;</span>.<span class="hljs-built_in">format</span>(count*<span class="hljs-number">100</span>/<span class="hljs-built_in">len</span>(lst)),end=<span class="hljs-string">&quot;&quot;</span>)<br>            <span class="hljs-keyword">continue</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    stock_list_url = <span class="hljs-string">&#x27;https://quote.eastmoney.com/stocklist.html&#x27;</span><br>    stock_info_url = <span class="hljs-string">&#x27;https://gupiao.baidu.com/stock/&#x27;</span><br>    output_file = <span class="hljs-string">&#x27;D:/BaiduStockInfo.txt&#x27;</span><br>    slist=[]<br>    getStockList(slist, stock_list_url)<br>    getStockInfo(slist, stock_info_url, output_file)<br><br>main()<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/jzj_c_love/article/details/104093877">python爬取淘宝商品信息&amp;requests.get()和网页源代码不一致_jzj_c_love的博客-CSDN博客</a></p><h1 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h1><ul><li><p>selenium的使用步骤？</p><ol><li>导入：from selenium import webdriver</li><li>创建谷歌浏览器操作对象： path = 谷歌浏览器驱动文件路径 browser = webdriver.Chrome(path) </li><li>访问网址 url = 要访问的网址 browser.get(url)</li></ol></li><li><p>selenium的元素定位 find_element</p></li><li><p>访问元素信息</p><p>获取元素属性 .get_attribute(‘class’) </p><p>获取元素文本 .text </p><p>获取标签名 .tag_name</p></li><li><p>交互</p><p>点击:click() </p><p>输入:send_keys()</p><p> 后退操作:browser.back() </p><p>前进操作:browser.forword()</p><p>模拟JS滚动: js=’document.documentElement.scrollTop=100000’ browser.execute_script(js) </p><p>执行js代码 获取网页代码：page_source </p><p>退出：browser.quit()</p></li><li><p>Chrome handless</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-comment">#这个是浏览器自带的 不需要我们再做额外的操作</span><br><span class="hljs-keyword">from</span> selenium.webdriver.chrome.options <span class="hljs-keyword">import</span> Options<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">share_browser</span>():</span><br>    <span class="hljs-comment">#初始化</span><br>    chrome_options = Options()<br>    chrome_options.add_argument(<span class="hljs-string">&#x27;‐‐headless&#x27;</span>)<br>    chrome_options.add_argument(<span class="hljs-string">&#x27;‐‐disable‐gpu&#x27;</span>)<br>    <span class="hljs-comment">#浏览器的安装路径 打开文件位置</span><br>    <span class="hljs-comment">#这个路径是你谷歌浏览器的路径</span><br>    path = <span class="hljs-string">r&#x27;[---]&#x27;</span><br>    chrome_options.binary_location = path<br>    browser = webdriver.Chrome(chrome_options=chrome_options)<br>    <span class="hljs-keyword">return</span> browser<br><br><span class="hljs-comment">#封装调用：</span><br><span class="hljs-keyword">from</span> handless <span class="hljs-keyword">import</span> share_browser<br>browser = share_browser()<br>browser.get(<span class="hljs-string">&#x27;http://www.baidu.com/&#x27;</span>)<br>browser.save_screenshot(<span class="hljs-string">&#x27;handless1.png&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="Scrapy"><a href="#Scrapy" class="headerlink" title="Scrapy"></a>Scrapy</h1><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220207162133107.png"  style="zoom:67%;" /></p><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220207162218001.png" style="zoom:67%;" /></p><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220207165234066.png" style="zoom:67%;" /></p><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220207165852697.png" style="zoom:67%;" /></p><p><img src="http://r6x04xz01.hd-bkt.clouddn.com/image-20220209014418171.png" style="zoom:67%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#dang.py</span><br><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">from</span> scrapy_dangdang_095.items <span class="hljs-keyword">import</span> ScrapyDangdang095Item<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DangSpider</span>(<span class="hljs-params">scrapy.Spider</span>):</span><br>    name = <span class="hljs-string">&#x27;dang&#x27;</span><br>    <span class="hljs-comment"># 如果是多页下载的话 那么必须要调整的是allowed_domains的范围 一般情况下只写域名</span><br>    allowed_domains = [<span class="hljs-string">&#x27;category.dangdang.com&#x27;</span>]<br>    start_urls = [<span class="hljs-string">&#x27;http://category.dangdang.com/cp01.01.02.00.00.00.html&#x27;</span>]<br>    base_url = <span class="hljs-string">&#x27;http://category.dangdang.com/pg&#x27;</span><br>    page = <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span>(<span class="hljs-params">self, response</span>):</span><br><span class="hljs-comment">#       pipelines 下载数据</span><br><span class="hljs-comment">#       items     定义数据结构的</span><br><span class="hljs-comment">#         src = //ul[@id=&quot;component_59&quot;]/li//img/@src</span><br><span class="hljs-comment">#         alt = //ul[@id=&quot;component_59&quot;]/li//img/@alt</span><br><span class="hljs-comment">#         price = //ul[@id=&quot;component_59&quot;]/li//p[@class=&quot;price&quot;]/span[1]/text()</span><br><span class="hljs-comment">#         所有的seletor的对象 都可以再次调用xpath方法</span><br>        li_list = response.xpath(<span class="hljs-string">&#x27;//ul[@id=&quot;component_59&quot;]/li&#x27;</span>)<br><br>        <span class="hljs-keyword">for</span> li <span class="hljs-keyword">in</span> li_list:<br>            src = li.xpath(<span class="hljs-string">&#x27;.//img/@data-original&#x27;</span>).extract_first()<br>            <span class="hljs-comment"># 第一张图片和其他的图片的标签的属性是不一样的</span><br>            <span class="hljs-comment"># 第一张图片的src是可以使用的  其他的图片的地址是data-original</span><br>            <span class="hljs-keyword">if</span> src:<br>                src = src<br>            <span class="hljs-keyword">else</span>:<br>                src = li.xpath(<span class="hljs-string">&#x27;.//img/@src&#x27;</span>).extract_first()<br><br>            name = li.xpath(<span class="hljs-string">&#x27;.//img/@alt&#x27;</span>).extract_first()<br>            price = li.xpath(<span class="hljs-string">&#x27;.//p[@class=&quot;price&quot;]/span[1]/text()&#x27;</span>).extract_first()<br><br>            book = ScrapyDangdang095Item(src=src,name=name,price=price)<br><br>            <span class="hljs-comment"># 获取一个book就将book交给pipelines</span><br>            <span class="hljs-keyword">yield</span> book<br><br><br><span class="hljs-comment">#       每一页的爬取的业务逻辑全都是一样的，所以我们只需要将执行的那个页的请求再次调用parse方法就可以了</span><br>        <span class="hljs-keyword">if</span> self.page &lt; <span class="hljs-number">100</span>:<br>            self.page = self.page + <span class="hljs-number">1</span><br>            url = self.base_url + <span class="hljs-built_in">str</span>(self.page) + <span class="hljs-string">&#x27;-cp01.01.02.00.00.00.html&#x27;</span><br><br><span class="hljs-comment">#             怎么去调用parse方法</span><br><span class="hljs-comment">#             scrapy.Request就是scrpay的get请求</span><br><span class="hljs-comment">#             url就是请求地址</span><br><span class="hljs-comment">#             callback是你要执行的那个函数  注意不需要加（）</span><br>            <span class="hljs-keyword">yield</span> scrapy.Request(url=url,callback=self.parse)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#items.py</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScrapyDangdang095Item</span>(<span class="hljs-params">scrapy.Item</span>):</span><br>    <span class="hljs-comment"># name = scrapy.Field()</span><br>    <span class="hljs-comment"># 通俗的说就是你要下载的数据都有什么</span><br>    src = scrapy.Field()<br>    name = scrapy.Field()<br>    price = scrapy.Field()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#pipelines.py</span><br><span class="hljs-keyword">from</span> itemadapter <span class="hljs-keyword">import</span> ItemAdapter<br><br><span class="hljs-comment"># 如果想使用管道的话 那么就必须在settings中开启管道</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScrapyDangdang095Pipeline</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">open_spider</span>(<span class="hljs-params">self,spider</span>):</span><br>        self.fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;book.json&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_item</span>(<span class="hljs-params">self, item, spider</span>):</span><br>        self.fp.write(<span class="hljs-built_in">str</span>(item))<br>        <span class="hljs-keyword">return</span> item<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close_spider</span>(<span class="hljs-params">self,spider</span>):</span><br>        self.fp.close()<br><br><span class="hljs-keyword">import</span> urllib.request<br><br><span class="hljs-comment"># 多条管道开启</span><br><span class="hljs-comment"># 定义管道类 + 在settings中开启管道</span><br><span class="hljs-comment">#&#x27;scrapy_dangdang_095.pipelines.DangDangDownloadPipeline&#x27;:301</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DangDangDownloadPipeline</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_item</span>(<span class="hljs-params">self, item, spider</span>):</span><br>        url = <span class="hljs-string">&#x27;http:&#x27;</span> + item.get(<span class="hljs-string">&#x27;src&#x27;</span>)<br>        filename = <span class="hljs-string">&#x27;./books/&#x27;</span> + item.get(<span class="hljs-string">&#x27;name&#x27;</span>) + <span class="hljs-string">&#x27;.jpg&#x27;</span><br>        urllib.request.urlretrieve(url = url, filename= filename)<br>        <span class="hljs-keyword">return</span> item<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#settings.py文件中被修改</span><br>ITEM_PIPELINES = &#123;<br>    <span class="hljs-comment">#  管道可以有很多个  那么管道是有优先级的  优先级的范围是1到1000   值越小优先级越高</span><br>    <span class="hljs-string">&#x27;scrapy_dangdang_095.pipelines.ScrapyDangdang095Pipeline&#x27;</span>: <span class="hljs-number">300</span>,<br>    <span class="hljs-comment">#DangDangDownloadPipeline</span><br>    <span class="hljs-string">&#x27;scrapy_dangdang_095.pipelines.DangDangDownloadPipeline&#x27;</span>:<span class="hljs-number">301</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>课外学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《软件工程》笔记与结课小结</title>
    <link href="/2022/01/10/%E3%80%8A%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/01/10/%E3%80%8A%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="判定表-树"><a href="#判定表-树" class="headerlink" title="判定表/树"></a>判定表/树</h2><p><a href="https://blog.csdn.net/qq_44723773/article/details/110098252">软件工程导论——结构程序设计（判定树和判定表的练习）</a></p><h2 id="DFD"><a href="#DFD" class="headerlink" title="DFD"></a>DFD</h2><p><a href="https://blog.csdn.net/weixin_43616178/article/details/88859372">数据流图——从软考真题中学画数据流图DFD</a></p><p><img src="https://s2.loli.net/2022/01/10/CRS8KVGX4b6i9e3.png" style="zoom: 67%;" /></p><h2 id="N-S、PAD"><a href="#N-S、PAD" class="headerlink" title="N-S、PAD"></a>N-S、PAD</h2><p><img src="https://s2.loli.net/2022/01/10/W3XeJABGwP4N9D5.png" alt=""></p><p><img src="https://s2.loli.net/2022/01/10/ykQSIgRehKzYM21.png" alt=""></p><p><img src="https://s2.loli.net/2022/01/10/9O2VXkvYf4SudlK.png" style="zoom: 67%;" /></p><p><img src="https://s2.loli.net/2022/01/10/GpNZUrdfn5Lijbv.png"  style="zoom: 67%;" /></p><p><img src="https://s2.loli.net/2022/01/10/nUIVbfBCekzqpyH.png" style="zoom: 67%;" /></p><h2 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a>等价类划分</h2><p>等价类方法</p><p>余额宝提现到银行卡增加新规则:快速到账(2小时)日限额1w元，超过1w元只能选择普通到账</p><p><img src="https://s2.loli.net/2022/01/10/ijZKeuEBRSXogT4.png"  style="zoom: 50%;" /></p><p>某报表处理系统要求用户输入处理报表的日期，日期限制在2001年1月至2008年12月，即系统只能对该段期间内的报表进行处理，如日期不在此范围内，则显示输入错误信息。系统日期规定由年、月的6位数字字符组成，前四位代表年，后两位代表月。</p><p>分析输入条件有：200101到200812；6位；数字</p><p><img src="https://s2.loli.net/2022/01/10/gjZVrHl2zynRNme.png" style="zoom:80%;" /></p><p>邮箱名要求6~18个字符，可使用字母、数字、下划线、需以字母开头。</p><p><img src="https://s2.loli.net/2022/01/10/CxU6qzOouHyp2l4.png" style="zoom: 67%;" /></p><h2 id="用例图、类图"><a href="#用例图、类图" class="headerlink" title="用例图、类图"></a>用例图、类图</h2><p><a href="http://www.360doc.com/content/14/0806/11/8072791_399795400.shtml">用例图、类图之间的几种关系</a></p><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><p>Actor是与系统交互的人或其他更件系统。（谁使用系统的功能？谁来维护和管理系统，以保证系统正常工作？谁对系统产生的结果感兴趣？系统控制的硬件设备有哪些？系统需要与其他哪些系统交互？）</p><p>通信关联 直线</p><p>用例关系</p><p>包含、扩展、泛化</p><p><img src="https://s2.loli.net/2022/01/10/aKTV27uYD9UlJRF.png" alt="image-20220110225753442" style="zoom:67%;" /></p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><a href="https://www.jianshu.com/p/57620b762160">UML类图</a></p><p><img src="https://s2.loli.net/2022/01/10/PlSNEckFTfdeWYR.png"  style="zoom:50%;" /></p><p><img src="https://s2.loli.net/2022/01/10/pNRqkMyjZmtOGsY.png" style="zoom:67%;" /></p><ul><li>关联（association）【实线指向需要知道的类】</li><li>泛化(Generalization)表示类与类之间的继承关系，接口与接口之间的继承关系，或类对接口的实现关系<ul><li>继承（inheritance）类【实线空三角指向基类】</li><li>实现/接口（realization/implementation）类—接口【虚线空三角指向接口/棒棒糖表示法】</li></ul></li><li>依赖（dependency）【虚线指向需要依赖的类】</li><li>聚合（aggregation）【空心菱形在主类】</li><li>组合（composition）【实心菱形在主类】</li></ul><h2 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h2><ul><li><p><strong>判定表</strong>，疫情相关 （10分）</p></li><li><p>画<strong>顶层一层二层数据流图</strong>、不能有原则性错误（守恒流入流出、顶层不给外部存储、数据源输入流输出流名称、分解均匀自然、考试需求比较笼统发挥空间大）（25分）</p></li><li><p>给程序流程图，画<strong>N-S图</strong>，画<strong>PAD图</strong>（2*10=20分）</p></li><li><p><strong>等价类方法</strong>划分（20分）</p></li><li><p><strong>用例图</strong>（包含，扩展，actor通信关联）、<strong>类图</strong>、<strong>选择什么编程语言，理由</strong>（25分）</p></li></ul><p>题型都是应用题。课程考核重点包括判定表/树，SA，N-S、PAD，测试用例设计，面向对象用例模型、动态模型。对于DFD、顺序图/协作图，要注意“形”。</p>]]></content>
    
    
    <categories>
      
      <category>CUMT课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>会议期刊介绍</title>
    <link href="/2021/12/30/%E4%BC%9A%E8%AE%AE%E6%9C%9F%E5%88%8A%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/12/30/%E4%BC%9A%E8%AE%AE%E6%9C%9F%E5%88%8A%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="衡量标准"><a href="#衡量标准" class="headerlink" title="衡量标准"></a>衡量标准</h1><p><a href="http://www.sztspi.com/archives/30937.html">摘录原文</a></p><h2 id="SCI（科学引文索引）"><a href="#SCI（科学引文索引）" class="headerlink" title="SCI（科学引文索引）"></a>SCI（科学引文索引）</h2><p>Science Citation Index，简称 SCI，由美国科学信息研究所（Institute for Scientific Information, 简称 ISI）在美国费城创办的引文数据库，创始人为情报专家尤金·加菲尔德。目前SCI由信息提供商汤森路透公司（Thomson Reuters）负责运营。</p><p>世界著名的三大科学统计与科学评价检索系统——<strong>SCI（科学引文索引）、EI（工程索引）、ISTP（科技会议录索引）</strong>中，SCI 最为重要。被SCI收录的学术期刊称为SCI期刊，收录于SCI期刊的科技论文称为SCI论文。它以布拉德福(S. C. Bradford)文献离散律理论、以加菲尔德(E. Garfield)引文分析理论为主要基础，通过论文的被引用频次等的统计，对学术期刊和科研成果进行多方位的评价研究，从而评判一个国家或地区、科研单位、高校、期刊、个人的科研产出绩效，来反映其在国际上的学术水平。</p><p>加菲尔德(E. Garfield)引文分析理论是怎么来的？要说清楚这个事情，先要了解文献与文献之间的关系。首先要知道，几乎没有一篇文章是独立存在的，里面有一部分重要的内容就是“参考文献（References）”，这让科学研究以“站在巨人的肩膀上”快速方展。所以文章与文章之间就有了错综复杂相互引用的关系，就好像Facebook上的人际关系网一样，文章之间也有引用关系网，总结起来有四种关系：<strong>你引用我（Cited）、你被我引用（Citing）、咱俩互不引用但说的事儿相关（Relavant）、完全没关系</strong></p><p>然后加菲尔德(E. Garfield)就这些关系提出了一种新的研究理论，利用文章间的引用关系可以对一个Idea做三个维度的扩展研究。</p><p>比如你先找到了一篇你认为非常感兴趣的文章A，发现A引用B，B又引用了C … 这个维度就是“越查越深（早）”(也就是这篇文章的引文)；如果发现从A被B引用，B又被C引用…这个维度就是“越查越新”（施引）；如果发现A与B、C都没有互引但很相关，这个维度就是“越查越广”。这三个维度很好地保证了科研的完整性，所以基于这个理论，加菲尔德(E. Garfield)搞了个机构叫ISI（美国科学信息研究所），把论文的引用关系梳理清楚，大大地提高了科研人员的研究效率。</p><p>这就不得不说大名鼎鼎的数据库就叫“<strong>Web of Science</strong>”，里面按学科和类型分了好几个库，期刊方面有：<strong>理工科的叫SCI（Science Citation Index，科学引文索引）</strong>，社会科学的叫SSCI（Social Sciences Citation Index，社会科学引文索引），艺术人文的叫AHCI（Arts &amp; Humanities Citation Index，艺术与人文引文索引）</p><h2 id="影响因子IF"><a href="#影响因子IF" class="headerlink" title="影响因子IF"></a>影响因子IF</h2><p>ISI（美国科学信息研究所）在早期把这些引用关系进行了排名，基于“谁被引用得多，谁的质量就高”这种想法，创立了一个概念叫“影响因子”。</p><p>具体来说，影响因子（Impact Factor，IF）是汤森路透（Thomson Reuters）出品的期刊引证报告（Journal Citation Reports，JCR）中的一项数据。</p><p>影响因子=前两年所发论文在第三年被引用次数/该期刊前两年发表论文总数。</p><p>影响因子实质上是期刊论文的平均被引率，用来衡量期刊的质量（是衡量期刊的，也就是你论文发表的位置的）和影响力。影响因子的高低，不仅取决于期刊论文被引用次数的多少，也取决于期刊所发表论文的数量。影响因子一般取值范围为1~5，呈动态变化。</p><p>然后把引用量最高的期刊分不同学科做了一个排行榜，这就形成了“核心期刊”的概念，你经常听到的“SCI核心期刊”就是在Web of Science中，理工科领域被引用次数最多的一些期刊（注意是期刊不是文章）。</p><p>总结一下：</p><p>1）文献与文献之间存在相互引用的关系；</p><p>2）Web of Science基于这种关系做了一个数据库，可以从深、新、广三个维度查文献，SCI是其中一个理工科集合；</p><p>3）在这个数据库里按引用量做了一个排行榜，产生了“核心期刊”的概念，这个概念被中国学术界广泛和过度的运用。</p><p>最后再提醒一点，Web of Science数据库最大地价值是用三个维度查找相关文献来做科研，而不是查“核心期刊”。</p><p>本来影响因子只是评价期刊的一个指标，后来南京大学有一个老师就在国内大力推崇这种评价体系，导致后来发SCI期刊文章成了评职称的重要甚至唯一指标，用着用着被妖魔化了，出了好多技巧专门研究怎么发SCI论文，有相当一部分违背了科学研究的本意。现在国外早已不再使用SCI为单一指标来评价学术，还会考虑比如社交媒体的影响力。</p><h2 id="期刊分区"><a href="#期刊分区" class="headerlink" title="期刊分区"></a>期刊分区</h2><p>分区（Quartile）是指将SCI期刊领域和学术影响力分类。主流参考的SCI分区依据主要有汤森路透JCR以及中科院JCR分区表。</p><p>汤森路透JCR分区将把某一个学科的所有期刊都按照上一年的影响因子降序排列，然后平均4等分(各25%)，分为Q1（1%-25%），Q2（26%-50%），Q3（51%-75%），Q4（76%-100%）。</p><p>中科院JCR分区表根据该SCI期刊的三年平均IF，先将SCI期刊按照所属领域分为14个大类和176个小类，再将同一学科所有期刊按照该年的IF降序排列，分为一区（1%-5%），二区（6%-20%），三区（21%-50%），四区（51%-100%）。中科院一区的也是Top期刊，一般而言，发表在一区和二区的SCI论文，通常被认为是该学科领域的比较重要的成果。</p><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>中国采用的核心有多种，其中最受认可的是三大核心：<strong>北京大学图书馆“中文核心期刊”、南京大学“中文社会科学引文索引（CSSCI）来源期刊”、中国科学技术信息研究所“中国科技论文统计源期刊”（又称“中国科技核心期刊”</strong>）。</p><p>其中以中文核期刊和科技核心期刊认可度最高，晋升职称常说的核心也指的是这两种，如果一个期刊同时被这两家机构评为核心就称为双核心。CSSCI每两年评选一次，而北大核心每四年评选一次。</p><h1 id="期刊会议"><a href="#期刊会议" class="headerlink" title="期刊会议"></a>期刊会议</h1><p><a href="https://www.ccf.org.cn/c/2019-04-25/663625.shtml">中国计算机学会推荐国际学术会议和期刊目录</a></p><h2 id="人工智能的顶刊-顶会"><a href="#人工智能的顶刊-顶会" class="headerlink" title="人工智能的顶刊/顶会"></a>人工智能的顶刊/顶会</h2><p>查阅期刊IF：<a href="https://www.letpub.com.cn/index.php?page=journalapp">https://www.letpub.com.cn/index.php?page=journalapp</a></p><p>中国计算机学会推荐国际学术刊物(人工智能)（A）</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">全称</th><th style="text-align:center">出版社</th><th>地址</th></tr></thead><tbody><tr><td style="text-align:center">AI</td><td style="text-align:center">Artificial Intelligence</td><td style="text-align:center">Elsevier</td><td><a href="http://dblp.uni-trier.de/db/journals/ai/">http://dblp.uni-trier.de/db/journals/ai/</a></td></tr><tr><td style="text-align:center">TPAMI</td><td style="text-align:center">IEEE Trans on Pattern Analysis and Machine Intelligence</td><td style="text-align:center">IEEE</td><td><a href="http://dblp.uni-trier.de/db/journals/pami/">http://dblp.uni-trier.de/db/journals/pami/</a></td></tr><tr><td style="text-align:center">IJCV</td><td style="text-align:center">International Journal of Computer Vision</td><td style="text-align:center">Springer</td><td><a href="http://dblp.uni-trier.de/db/journals/ijcv/">http://dblp.uni-trier.de/db/journals/ijcv/</a></td></tr><tr><td style="text-align:center">JMLR</td><td style="text-align:center">International Journal of Computer Vision</td><td style="text-align:center">MIT Press</td><td><a href="http://dblp.uni-trier.de/db/journals/ijcv/">http://dblp.uni-trier.de/db/journals/ijcv/</a></td></tr></tbody></table></div><p>中国计算机学会推荐国际学术会议(人工智能)（A）</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">全称</th><th style="text-align:center">出版社</th><th>地址</th></tr></thead><tbody><tr><td style="text-align:center">AAAI</td><td style="text-align:center">AAAI Conference on Artificial Intelligence</td><td style="text-align:center">AAAI</td><td><a href="http://dblp.uni-trier.de/db/conf/aaai/">http://dblp.uni-trier.de/db/conf/aaai/</a></td></tr><tr><td style="text-align:center">NeurIPS</td><td style="text-align:center">Annual Conference on Neural Information Processing Systems</td><td style="text-align:center">MIT Press</td><td><a href="http://dblp.uni-trier.de/db/conf/nips/">http://dblp.uni-trier.de/db/conf/nips/</a></td></tr><tr><td style="text-align:center">ACL</td><td style="text-align:center">Annual Meeting of the Association for Computational Linguistics</td><td style="text-align:center">ACL</td><td><a href="http://dblp.uni-trier.de/db/conf/acl/">http://dblp.uni-trier.de/db/conf/acl/</a></td></tr><tr><td style="text-align:center">CVPR</td><td style="text-align:center">EEE Conference on Computer Vision and Pattern Recognition</td><td style="text-align:center">IEEE</td><td><a href="http://dblp.uni-trier.de/db/conf/cvpr/">http://dblp.uni-trier.de/db/conf/cvpr/</a></td></tr><tr><td style="text-align:center">ICCV</td><td style="text-align:center">International Conference on Computer Vision</td><td style="text-align:center">IEEE</td><td><a href="http://dblp.uni-trier.de/db/conf/iccv/">http://dblp.uni-trier.de/db/conf/iccv/</a></td></tr><tr><td style="text-align:center">ICML</td><td style="text-align:center">International Conference on Machine Learning</td><td style="text-align:center">ACM</td><td><a href="http://dblp.uni-trier.de/db/conf/icml/">http://dblp.uni-trier.de/db/conf/icml/</a></td></tr><tr><td style="text-align:center">IJCAI</td><td style="text-align:center">International Joint Conference on Artificial Intelligence</td><td style="text-align:center">Morgan Kaufmann</td><td><a href="http://dblp.uni-trier.de/db/conf/ijcai/">http://dblp.uni-trier.de/db/conf/ijcai/</a></td></tr></tbody></table></div><h2 id="计算机技术核心期刊大全（中国）"><a href="#计算机技术核心期刊大全（中国）" class="headerlink" title="计算机技术核心期刊大全（中国）"></a>计算机技术核心期刊大全（中国）</h2><ul><li><p>计算机学报<br>简介：《计算机学报》是中国计算机领域的权威学术刊物。 其宗旨是报道我国计算机科学和技术领域最高水平的科研成果。 《计算机学报》创立于1978年，以中文编辑形式与读者见面，同时以英文摘要形式向国际各大检索系统提供基本内容介绍。 本刊是中国计算机领域的代表性学术刊物，作为科学研究档案，代表了计算机领域各研究阶段的水平。</p><p>收录：北京大学《中文核心期刊总览》EI 工程索引(美)(2018)CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>计算机学报<br>简介：《计算机学报》是中国计算机领域的权威学术刊物。 其宗旨是报道我国计算机科学和技术领域最高水平的科研成果。 《计算机学报》创立于1978年，以中文编辑形式与读者见面，同时以英文摘要形式向国际各大检索系统提供基本内容介绍。 本刊是中国计算机领域的代表性学术刊物，作为科学研究档案，代表了计算机领域各研究阶段的水平。</p><p>收录：北京大学《中文核心期刊总览》EI 工程索引(美)(2018)CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>自动化学报<br>简介：《自动化学报》 (月刊)创刊于1963年，是中国自动化学会、中国科学院自动化研究所共同主办的高级学术期刊。 刊载自动化科学和技术领域的高水平理论性和应用性的科研成果。 内容如下：1)自动控制2 )系统理论和系统工程3 )自动化工过程技术和应用4 )自动化系统计算机辅助技术5 )机器人6 )人工智能和智能控制7 )模式识别和图像处理8 )信息处理和信息服务9 )基于网络的自动化等。</p><p>收录：北京大学《中文核心期刊总览》EI 工程索引(美)(2018)CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>简介：《计算机研究与发展》 (月刊)创刊于1958年，中国科学医院计算技术研究所，中国计算机学会主办。 刊载内容： 计算机科学技术领域高水平的学术论文，最新科研成果和重大应用成果。 刊载内容：评估、计算机基础理论、软件技术、信息安全、计算机网络、图形图像、体系结构、人工智能、计算机应用、数据库技术、存储技术和计算机相关领域。</p><p>收录：北京大学《中文核心期刊总览》EI 工程索引(美)(2018)CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>控制与决策<br>简介：《控制与决策》创刊于1986年，由教育部主管、东北大学主办。本刊是自动控制与管理决策领域的学术性期刊，主要刊登自动控制理论及其应用，系统理论与系统工程，决策理论与决策方法，自动化技术及其应用，人工智能与智能控制，机器人，以及自动控制与决策领域的其他重要课题。主要栏目有：综述与评论、论文与报告、短文、信息与动态等。</p><p>收录：北京大学《中文核心期刊总览》EI 工程索引(美)(2018)CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>中国图象图形学报<br>简介：《中国图象图形学报》是由中国科学院遥感与数字地球研究所、中国图象图形学会、北京应用物理与计算数学研究所共同创办，是集计算机图像图形高科技理论、技术方法与应用研究成果产业化于一体的综合性学术期刊。主要刊登图像图形科学及其密切相关领域的基础研究和应用研究方面，并具有创新性的、高水平科研学术论文，论文形式主要有综述、技术报告，项目进展、学术动态、新技术评论、新产品介绍和产业化研究等。内容涉及图像分析和识别、图像理解和计算机视觉、计算机图形学、虚拟现实和增强现实、系统仿真、动漫等众多领域，同时还根据各时期的研究热点和前沿课题开设相应的主 题专栏。读者对象不从事国防、军事、航空、航天、通信、电子、汽车、农业、气象、环保、遥感、测绘、油田、建筑、交通、金融、电信、教育、医疗、影视、艺术等科技人员、企业主管及高等院校的研究生，大学生。</p><p>收录：北京大学《中文核心期刊总览》CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>计算机辅助设计与图形学学报<br>简介：创刊于1989年，是我国CAD和计算机图形学领域第一个公开出版的学术刊物，原为季刊，1996年起改为双月刊，从2000年起改为月刊。该刊以快速传播CAD与计算机图形学领域的知识与经验为目的，刊登有创新的学术论文，报导最新科研成果和学术动态，及时反映该领域发展水平与发展方向。读者对象为从事CAD和计算机图形及其他有关学科的科研、工程技术人员及高等院校师生。</p><p>收录：北京大学《中文核心期刊总览》EI 工程索引(美)(2018)CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>计算机应用研究</p><p>简介：《计算机应用研究》创刊于1984年，是由国家科技部所属四川省计算机研究院主办，北京、天津、山东、吉林、云南、贵州、安徽、河南、广西、甘肃、内蒙古等十余省市计算中心协办的计算技术类学术刊物。主要刊载内容包括本学科领域高水平的学术论文、本学科最新科研成果和重大应用成果。栏目内容涉及计算机学科新理论、计算机基础理论、算法理论研究、算法设计与分析、系统软件与软件工程技术、模式识别与人工智能、体系结构、先进计算、并行处理、数据库技术、计算机网络与通信技术、信息安全技术、计算机图像图形学及其最新热点应用技术。</p><p>收录：北京大学《中文核心期刊总览》CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>计算机科学<br>简介：《计算机科学》（Computer Science）创刊于1974年1月（月刊），由重庆西南信息有限公司（原科技部西南信息中心）主管主办，曾用刊名计算机应用与应用数学，是中国计算机学会（CCF）会刊。主要报道国内外计算机科学与技术的发展动态、涉及面广的方法论与技术、反映新苗头且能起承先启后作用的研究成果。</p><p>收录：北京大学《中文核心期刊总览》CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>计算机应用<br>简介：《计算机应用》创刊于1981年，是中国计算机学会会刊。本刊旨在介绍计算机应用技术，推动经济发展和科技进步，促进计算机应用创新的开发。 多年来，中国计算机学会一直关注着国内计算机各应用领域的专家。读者对象：计算机应用工程技术人员、大专院校师生、企事业单位管理干部、科研院所从事计算机开发应用人员、计算机公司职员等必备的工具，是启迪思维、开拓进取、更新知识、开发应用的良师益友。</p><p>收录：北京大学《中文核心期刊总览》CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>计算机工程<br>简介：《计算机工程》创刊于1975年，是中国电子科技集团公司第三十二研究所（华东计算技术研究所）和上海市计算机学会主办的学术性刊物，刊登内容： 热点与综述、人工智能与模式识别、先进计算与数据处理、网络空间安全、移动互联与通信技术、体系结构与软件技术、图形图像处理、开发研究与工程应用等。</p><p>收录：北京大学《中文核心期刊总览》CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>控制理论与应用<br>简介：《控制理论与应用》1984年创刊，是教育部主管、由华南理工大学和中科院数学与系统科学研究院联合主办的全国学术刊物。主要报道在控制理论与应用方面的高水平学术论文，特别是系统控制、最优化和自动化领域中的新兴问题、原创方法及尖端技术，为控制领域的科学家和工程师们提供一个交流最新成果的平台。主要报道系统控制科学中具有新观念、新思想的理论研究成果及其在各个领域中, 特别是高科技领域中的应用研究成果和在国民经济有关领域技术开发、技术改造中的应用成果. 内容包括: 1） 系统建模、辨识与估计; 2) 数据驱动建模与控制；3)过程控制; 4)智能控制; 5)网络控制; 6) 非线性系统控制; 7) 随机系统控制; 8) 预测控制; 9) 多智能体系统及分布式控制; 10）鲁棒与自适应控制；11) 系统优化理论与算法; 12) 混杂系统与离散事件系统; 13）工程控制系统；14）航空与航天控制系统；15）新兴战略产业中的控制系统；16）博弈论与社会网络；17）微纳与量子系统；18）模式识别与机器学习；19）智能机器人；20) 先进控制理论在实际系统中的应用; 21）系统控制科学中的其它重要问题。《控制理论与应用》的读者对象是从事控制理论与应用研究的科技人员、高校师生及其他有关人员。设置的栏目主要有: 综述与评论,长论文,论文, 短文, 书刊评介, 读者来信, 国内外学术活动信息等。</p><p>收录：北京大学《中文核心期刊总览》EI 工程索引(美)(2018)CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>模式识别与人工智能<br>简介：《模式识别与人工智能》 (双月刊)创刊于1989年，是中国自动化学会、国家智能计算机研发中心和中国科学院合肥智能机械研究所共同主办、科学</p><p>出版社出版的学术期刊。 本刊主要发表模式识别、人工智能、智能系统等研究成果和进展，旨在推动信息科学技术的发展。</p><p>收录：北京大学《中文核心期刊总览》CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>遥感技术与应用<br>简介：《遥感技术与应用》是综合性学术刊物，主要刊登国内外遥感理论、技术及应用研究领域的学术论文与综述，优先报道国内外遥感研究与应用的新技术、新理论、新方法和新成果，推动高新技术在地球科学研究及社会发展中的应用，重点介绍国家自然科学基金项目、交流国家攀登计划、攻关计划工作等科研成果。针对目前遥感领域的热点问题和发展动态，经第六届编委会讨论决定，将栏目细化调整为微波遥感、光学遥感、数据处理、模型与反演、遥感应用、专家述评、GIS、深空探测、重大项目、综述等。</p><p>收录：中国科技论文统计源期刊（CSTPCD核心库）以及中国科学引文数据库来源期刊（CSCD核心库），清华大学中国学术期刊综合评价数据库统计源期刊，被中文科技期刊数据库全文收录</p></li><li><p>国土资源遥感<br>简介：《国土资源遥感》是由中国地质调查局主管，中国自然资源航空物探遥感中心主办的技术性刊物（季刊，国内外公开发行），创刊于1989年。主要刊登实用性强的遥感、GIS及GPS（3S）技术理论及其应用论文，宣传3S技术在国土资源调查与开发、国土整治的规划与管理，环境和灾害监测，水文地质、工程地质勘查，建设工程选址、选线及城市规划等领域应用的新方法和重要成果，以从事国土资源遥感及其相关研究领域的研究人员、应用人员及大专院校有关师生为读者对象。</p><p>收录：中文核心期刊、中国科学引文数据库（CSCD）核心期刊、中国科技核心期刊、俄罗斯《文摘杂志》（AJ）收录期刊、美国化学文摘（CA2008)收录期刊、美国《乌利希期刊指南》(Ulrichsweb) 中国科技论文统计源期刊、中国学术期刊综合评价数据库统计源期刊、中国期刊全文数据库全文收录期刊</p></li><li><p>计算机科学与探索<br>简介：《计算机科学与探索》是由中国电子科技集团公司主管、华北计算技术研究所主办的国内外公开发行的高级学术期刊。报道计算机(硬件、软件)各学科具有创新性、前沿性、开拓性、探索性的科研成果。 内容包括高性能计算机、体系结构、并行处理、计算机科学更新理论、算法设计与分析、人工智能和模式识别、系统软件、软件工程、数据库、计算机网络、信息安全包括图形学和计算机辅助设计、虚拟现实、多媒体技术和交叉学科的相互渗透和新理论的推导等。</p><p>收录：北大中文核心期刊，中国科学引文数据库（CSCD）核心期刊，中国科技论文统计源期刊（中国科技核心期刊），中国学术期刊综合评价数据库（CAJCED）统计源期刊，中国科技论文与引文数据库（CSTPCD）统计源期刊，中文科技期刊数据库（VIP）收录期刊，并被 “英国《科学文摘》（SA/INSPEC）”“美国《剑桥科学文摘》（CSA）”“美国《乌利希期刊指南》（Ulrich’s PD）”“《日本科学技术振兴机构中国文献数据库》（JST）”“波兰《哥白尼索引》（IC）”收录，</p></li><li><p>信息与控制<br>简介：《信息与控制》是经中华人民共和国新闻出版总署批准，由中国科学院主管，中国科学院沈阳自动化研究所、中国自动化学会共同主办的科技类核心期刊，主要刊载信息与控制科学领域基础研究和应用基础研究方面具有创新性的、高水平的、有重要意义的研究成果，由科学出版社出版。重点关注控制科学与技术、与控制理论相关的应用信息技术在机械制造、能源电力、冶金化工、资源环境、航空工业以及国防工业等国家重要高科技和经济领域中的应用研究成果。主要内容包括：1）控制理论与控制工程；2）智能信息处理；3）人工智能与模式识别；4）先进控制与优化技术；5）企业信息管理与信息系统；6）工业控制网络与系统；7）人机系统等。</p><p>收录：北京大学《中文核心期刊总览》CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>智能系统学报<br>简介：《智能系统学报》是由中国人工智能学会和哈尔滨工程大学联合主办，是中国人工智能学会会刊。主要刊登神经网络与神经计算、智能信息处理、自然语言理解、智能系统工程、机器翻译、复杂系统、机器学习、知识工程与分布式智能、机器人、智能制造、粗糙集与软计算、免疫系统、机器感知与虚拟现实、智能控制与智能管理、可拓工程、人工智能基础等内容。</p><p>收录：美国《剑桥科学文摘》、英国《科学文摘》、中文核心期刊、中国科学引文数据库（CSCD）来源期刊、中国科技核心期刊等重要数据库收录。</p></li><li><p>计算机应用与软件<br>简介：《计算机应用与软件》创刊于1984年，由上海市计算技术研究所和上海计算机软件技术开发中心共同主办。注重刊登反映计算机应用和软件技术开发应用方面的新理论、新方法、新技术以及创新应用的文章。主要栏目包括：最新技术动态、综合评述、软件技术与研究、数据工程、应用技术与研究、网络与通信、多媒体技术应用、人工智能与识别、图像处理与应用、嵌入式软件与应用、算法、安全技术、信息技术交流及其他相关内容。主要面向从事计算机应用和软件技术开发的科研人员、工程技术人员、高校师生等。</p><p>收录：《中国科技论文统计源期刊（中国科技核心期刊）》、《中国学术期刊综合评价数据库来源期刊》、《万方数据—数字化期刊群全文收录期刊》、《中文科技期刊数据库（全文版）收录期刊》、《中国科学引文数据库来源期刊（2015-2016）》、美国《剑桥科学文摘》收录期刊、美国《乌利希国际期刊指南》等数据库收录。</p></li><li><p>计算机工程与科学<br>简介：《计算机工程与科学》隶属于中国人民解放军国防科技大学计算机学院，是计算机类综合性学术刊物,1973年创刊,是中国计算机学会会刊，由国防科技大学计算机学院主办。注重刊登计算机学科在理论、工程与应用等方面的研究论文、技术报告和科研成果，主要涉及计算机体系结构、并行处理、超级计算、人工智能、软件工程、计算机仿真、多媒体与可视化、数据库、计算机网络与分布式处理、计算机安全与保密、中文信息处理、微机开发与应用及其他相关内容。</p><p>收录：中文核心期刊、中国科学引文数据库扩展库来源期刊(CSCD扩展库来源期刊)、中国科技信息研究所中国科技论文统计分析源期刊（科技核心期刊）、中国学术期刊（光盘版）全文入编期刊、万方数据库全文入编期刊、英国《科学文摘》（INSPEC）、美国《史蒂芬斯全文数据库》（EBSCO host）、美国《乌利希期刊指南（网络版）》；《计算机工程与科学》在美国《科学引文索引（扩展库）》（SCIE）</p></li><li><p>控制工程<br>简介：《控制工程》是教育部科技司主管、东北大学主办的学术类期刊。常设栏目： 工业过程管理与决策系统、决策与控制一体化系统、工业过程及控制系统、运动体控制系统、安全监控系统、建模与仿真系统、工业互联网系统、人工智能驱动的自动化等。主要读者对象为从事于自动化工程技术的高等院校教师、研究生，科研院所的研究人员，工矿企业的工程技术人员等。</p><p>收录：中文核心期刊，中国科技核心期刊，中国科学引文数据库核心期刊（CSCD），中国科技论文统计用刊，中国科学文献数据用刊，中国学术期刊综合评价数据库来源期刊。从2002年开始，被俄罗斯《文摘杂志》（AJ），美国《剑桥科学文摘》(CSA), 英国《科学文摘》（SA）等著名国际检索机构全文检索。</p></li></ul><p><a href="https://blog.csdn.net/qq_43060870/article/details/112448649">下载顶刊的期刊的那点事</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《Java网络编程》《JavaEE程序设计》笔记</title>
    <link href="/2021/12/30/%E3%80%8AJava%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B%E3%80%8AJavaEE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/12/30/%E3%80%8AJava%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B%E3%80%8AJavaEE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java语言基础"><a href="#Java语言基础" class="headerlink" title="Java语言基础"></a>Java语言基础</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li><p>标识符规则</p><ul><li>由字母、 数字、下划线、 $组成。不能由数字开头。</li><li>不能含有其他任何字符（包括空格）</li><li>不能是Java中的保留字(关键字)。</li><li>大小写敏感，长度无限制。</li></ul></li><li><p>变量类型</p><ul><li>8种基本数据类型（byte1, short2, int4, long8, float4, double8, char2, boolean）</li><li>构造数据类型（类）</li></ul></li><li><p>常量类型</p><ul><li>数值常量</li><li>符号常量：<code>final int a = 10;</code>，值一旦确定不可更改，类静态成员常量只能在定义时初始化</li><li>注意事项<ul><li>一个整型常量在机器中默认以int类型存储</li><li>一个实型常量在机器中默认以double类型存储</li><li>十进制表示法小数点的两侧都必须有数字</li><li>科学表示法尾数必须有，但小数部分可无，阶码必须是整数</li><li>不可将布尔类型看做整型值。</li></ul></li></ul></li></ul><h2 id="运算符及表达式"><a href="#运算符及表达式" class="headerlink" title="运算符及表达式"></a>运算符及表达式</h2><ul><li><p>自增自减</p><ul><li>只能用于变量，而不能用于常量或表达式</li><li><code>a = 5; a--+10;</code>表达式的值为15，a变为4</li></ul></li><li><p>除法</p><ul><li>整数相除，截尾法取整</li><li>浮点数相除，是通常意义的除法</li></ul></li><li><p>除余</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">5</span>%<span class="hljs-number">2</span>=<span class="hljs-number">1</span><br><span class="hljs-number">5.2</span>%<span class="hljs-number">2</span>=<span class="hljs-number">1.2</span><br><span class="hljs-number">5.2</span>%<span class="hljs-number">2.2</span>=<span class="hljs-number">0.8</span> <br><span class="hljs-number">10</span>%-<span class="hljs-number">4</span>=<span class="hljs-number">2</span><br>-<span class="hljs-number">10</span>%-<span class="hljs-number">4</span>=-<span class="hljs-number">2</span> <br></code></pre></td></tr></table></figure></li><li><p>如果整数相除或取模，第二个操作数为0，编译无错，运行会出错。如果浮点数相除，第二个操作数为0，结果为Infinity，0.0/0除外是NaN。如果浮点数取模，第二个操作数为0，结果为NaN</p></li><li><p>字符串连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//A的ASCII码是65，a的ASCII码是97(65+32)</span><br><span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>        <span class="hljs-comment">//98</span><br><span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-number">2</span>+<span class="hljs-number">2.5</span>    <span class="hljs-comment">//69.5</span><br><span class="hljs-string">&quot;&quot;</span>+<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>     <span class="hljs-comment">//a1</span><br><span class="hljs-string">&quot;abc&quot;</span>+<span class="hljs-number">1</span>+<span class="hljs-number">2.3</span>  <span class="hljs-comment">//abc12.2</span><br><span class="hljs-number">1</span>+<span class="hljs-number">2.3</span>+<span class="hljs-string">&quot;abc&quot;</span>  <span class="hljs-comment">//3.3abc</span><br><span class="hljs-number">1</span>+<span class="hljs-string">&quot;abc&quot;</span> +<span class="hljs-number">2.3</span> <span class="hljs-comment">//1abc2.3</span><br></code></pre></td></tr></table></figure></li><li><p>对象运算符用来确定一对象是否是某一指定类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Test t1 = <span class="hljs-keyword">new</span> Test();<br><span class="hljs-keyword">if</span>(t1 <span class="hljs-keyword">instanceof</span> Test) System.out.println(<span class="hljs-string">&quot;Yes&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>逻辑运算符，&amp;和|没有短路逻辑，&amp;&amp;和||有</p></li><li><p>移位之前先把移的位数与被移位的位数求余数，然后移动这个位数</p></li><li><p>优先级</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">优先级</th><th style="text-align:center">运算符</th><th style="text-align:center">类型</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">()</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">+、-  、++、—、 !、~</td><td style="text-align:center">单目运算符</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">*、/、%</td><td style="text-align:center">算术运算符</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">+、-</td><td style="text-align:center">算术运算符</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">&lt;&lt;、&gt;&gt;  、&gt;&gt;&gt;</td><td style="text-align:center">移位运算符</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">&lt;、&lt;=、&gt;、&gt;=</td><td style="text-align:center">关系运算符</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">==、!=</td><td style="text-align:center">关系运算符</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">逻辑运算符</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">&#124;&#124;</td><td style="text-align:center">逻辑运算符</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">?:</td><td style="text-align:center">条件运算符</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">=、+=、-=、*=、/=、%=、^=</td><td style="text-align:center">赋值运算符</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">&amp;=、&#124;=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=</td><td style="text-align:center">赋值运算符</td></tr></tbody></table></div><ul><li><p>一个实型常量在机器中默认以double类型存储。实型常量后加后缀F或f在机器中以float类型存储。</p></li><li><p>数据类型转换</p><ul><li><p>自动转换，自动把精度较低的类型转换为另一种精度较高的类型，如果byte、short、char在一起运算时，会先将这些值转换为int型。再进行运算，结果为int型。</p></li><li><p>手动强制转换</p><ul><li>强制类型转换可能造成信息的丢失</li><li>布尔型与其它基本类型之间不能转换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> i; <span class="hljs-keyword">byte</span> b,c;<br>b=(<span class="hljs-keyword">byte</span>)<span class="hljs-number">345</span>;      <span class="hljs-comment">//上机测试知b得到89(345%256)  </span><br>c=(<span class="hljs-keyword">byte</span>)<span class="hljs-number">356</span>;      <span class="hljs-comment">//上机测试知c得到100(356%256)</span><br>i=(<span class="hljs-keyword">int</span>)(<span class="hljs-number">3.8</span>+<span class="hljs-number">6</span>);   <span class="hljs-comment">//截尾法</span><br></code></pre></td></tr></table></figure><ul><li>TIPS<ul><li><strong>在运算过程中，运算的结果至少是int型</strong>，即如果参与运算的两个数级别比int型低或是int型，则结果为int型</li><li>参与运算的数据如果有一个级别比int型高，则运算结果的类型与类型级别高的数相同</li><li>参与运算的两个数据如果类型不一样，会先把低级的数据转换成高级的类型的数据后再作运算，结果是高级的类型</li></ul></li></ul></li><li><p>隐含强制转换</p><ul><li>把int类型的常量赋给byte、short变量时不需要强制类型转换</li><li>把int类型的变量赋给byte、short类型的变量时必须强制转换，否则会出错</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">float</span> x=<span class="hljs-number">3.3f</span>;<br><span class="hljs-keyword">double</span> y=<span class="hljs-number">2.9</span>;<br><span class="hljs-keyword">byte</span> a=<span class="hljs-number">5</span>;<br>x+(<span class="hljs-keyword">int</span>)y/<span class="hljs-number">3</span>*a;    <span class="hljs-comment">//float</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><ul><li><p>标准输入输出</p><ul><li><p><code>System.out</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println();<br>System.out.print();<br></code></pre></td></tr></table></figure><ul><li><code>System.in</code>读一个字节，<strong>需要捕获异常</strong><code>IOException</code></li><li><code>int read()</code>从流中读取一个字节并将该字节作为整数返回,若没有数据则返回-1 </li><li><code>int read(byte b[])</code> 从流中读取多个字节放到b中, 返回实际读取到的字节数 </li><li><code>int read(byte b[],int off,int len)</code> 从流中读取最多len字节的数据, 放到数组b的下标off开始的单元中，返回读取到的字节数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ReadChar.java </span><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadChar</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">char</span> ch=(<span class="hljs-keyword">char</span>)System.in.read();<br>            System.out.println(ch);    <br>        &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>e.printStackTrace();<br>&#125;<br>   &#125; <br>&#125;<br><br><span class="hljs-comment">//ReadString.java</span><br><span class="hljs-keyword">import</span> java.io.*;    <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadString</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> c;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br>                c = (<span class="hljs-keyword">char</span>)System.in.read();<br>                System.out.print(c);<br>            &#125; <span class="hljs-keyword">while</span>(c!=<span class="hljs-string">&#x27;\n&#x27;</span>);<br>        &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//ReadStringOrInt.java </span><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadStringOrInt</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br><span class="hljs-keyword">byte</span> buf[]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">20</span>];  <br>String str;<br>        <span class="hljs-keyword">int</span> anInt;         <br>    <span class="hljs-keyword">try</span> &#123;    <br>System.in.read(buf);  <br>str=<span class="hljs-keyword">new</span> String(buf);<br>anInt=Integer<br>                .parseInt(str.trim()); <br>            <span class="hljs-comment">//trim必须</span><br>        &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            e.printStackTrace(); <br>&#125; <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>Scanner</code></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Scanner sc = new Scanner(System.in)<span class="hljs-comment">;</span><br><span class="hljs-attribute">i</span> = sc.nextInt()<span class="hljs-comment">;</span><br><span class="hljs-attribute">i</span> = sc.next()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>选择、循环、跳转等语句没啥说的跟其他语言差不多</p><ul><li><code>for</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//一种特殊的for循环</span><br><span class="hljs-keyword">int</span>[] scores = &#123;<span class="hljs-number">89</span>, <span class="hljs-number">72</span>, <span class="hljs-number">64</span>, <span class="hljs-number">58</span>, <span class="hljs-number">93</span>&#125;;<br><span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> sco: scores ) &#123;<br>    System.out.println(sco);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>switch</code></p><p>注意<code>break</code></p></li></ul></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><p>声明\创建数组空间\初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] list1; list1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">int</span>[] list2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">int</span>[] a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>]; b[<span class="hljs-number">0</span>]=<span class="hljs-number">8</span>; b[<span class="hljs-number">1</span>]=<span class="hljs-number">9</span>;<br><span class="hljs-keyword">int</span>[] c; c = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">int</span>[] d = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-comment">//WRONG</span><br><span class="hljs-comment">//int[] a; a = &#123;1,2,3,4&#125;; </span><br><span class="hljs-comment">//int a[5]; </span><br><br><span class="hljs-keyword">int</span>[][] a; a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<br><span class="hljs-keyword">int</span>[][] b; b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>][];<br><span class="hljs-keyword">int</span>[][] c = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<br><span class="hljs-keyword">int</span>[][] d =&#123;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;&#125;;<br><span class="hljs-keyword">int</span>[][] e = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;&#125;;<br><br><span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>][];<br>f[<span class="hljs-number">0</span>]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br>f[<span class="hljs-number">1</span>]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">//不规则数组</span><br></code></pre></td></tr></table></figure><p>ps: 如果括号写在后面会提示是C样式的定义，建议统一写在前面，但是写在前面还是写在后面都是没有影响的</p></li></ul><h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//类首说明</span><br>[修饰符] <span class="hljs-class"><span class="hljs-keyword">class</span> 类名 [<span class="hljs-keyword">extends</span>] [<span class="hljs-keyword">implements</span>]</span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-comment">//类体</span><br>[成员变量说明]<br>[构造方法说明]<br>[静态初始化说明]<br>[成员方法说明]<br>&#125;；<br></code></pre></td></tr></table></figure><h2 id="类首说明"><a href="#类首说明" class="headerlink" title="类首说明"></a>类首说明</h2><ul><li>修饰符<ul><li>访问权限修饰符<code>缺省/public</code></li><li>抽象类<code>abstract</code></li><li>最终类<code>final</code></li></ul></li><li><code>extends</code>Java中一个类最多能继承一个类（单继承）</li><li><code>implements</code>接口名可以有多个</li></ul><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><ul><li>访问权限修饰符<code>public&gt;protected&gt;缺省&gt;private</code></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">同一个类</th><th style="text-align:center">不同包的子类</th><th style="text-align:center">同一个包中</th><th style="text-align:center">不同包中的非子类</th></tr></thead><tbody><tr><td style="text-align:center">缺省friendly</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">public</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table></div><p>tips</p><ul><li>具有继承关系的子类可以继承父类的一些成员变量，即可以<strong>不创建对象</strong>就可以直接访问。如果是同一个包的子类可以继承到缺省/public/protected修饰的变量，如果是不同的包的子类就只能继承到public/protected的；</li><li>如果是其他类，不管是一个包还是不在一个包，都要创建该类的对象才能引用</li><li>如果是main方法，不管是本类还是非本类，要访问实例变量都要创建对象，可以引申到其他所有的类方法中</li><li>私有成员只能在本类中访问，如果在main方法中访问私有成员，必须创建对象</li><li><p>如果是创建对象，不同包的子类中定义的父类的对象只能调用public，不同包的子类中定义的子类的对象可以调用public、protected</p></li><li><p><code>static</code></p><p>static修饰的成员变量称为类变量（静态变量）；不用static修饰的成员变量又叫对象变量（实例变量）。可以通过类来访问静态成员变量，也可以通过该类的对象访问静态成员变量。</p></li><li><p><code>final</code></p><p>无论是实例变量，还是类变量，都可以被说明成常量。final修饰符和static修饰符并不冲突</p><ul><li>类常量，一定要在定义时就给定初始值，声明赋值不分开</li><li>对象常量，一个final成员变量，没有static修饰，不同的对象可以有不同的值。一定要给初始值，但可有两种方法：（1）在定义变量时赋初始值（声明赋值可分开）（2）在每一个构造函数中进行赋值</li></ul></li><li><p><code>transient</code>和<code>volatile</code></p></li><li><p>成员变量的使用</p><ul><li>类内部：只用变量名即可访问（类内的静态方法例如main访问对象变量例外）</li><li>类外部：对象变量要构造对象、类变量2种都行（static）</li></ul></li></ul><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><ul><li><p>成员方法首部声明</p><p><code>[方法修饰] 返回类型 方法名（[形参]）[throws异常]</code></p><ul><li>访问修饰符： 缺省/public/protected/private</li><li>非访问修饰符：static/abstract/final/native/synchronized</li></ul></li><li><p>成员方法调用</p><ul><li>内部调用：直接</li><li>外部调用：类方法（static）、对象方法<ul><li>在类方法中不能直接引用对象变量。在<strong>类方法（static）中不能使用super、this关键字</strong>。类方法不能直接调用类中的对象方法。</li><li>对象方法可以引用对象变量，也可以引用类变量。对象方法中可以使用supper、this关键字。对象方法中可以调用类方法。</li></ul></li></ul></li><li>方法的重载<ul><li>或者参数个数不同，或者参数类型不同，或者参数类型顺序不同</li></ul></li></ul><h2 id="构造方法、对象创建"><a href="#构造方法、对象创建" class="headerlink" title="构造方法、对象创建"></a>构造方法、对象创建</h2><ul><li><p>对象成员变量初始化</p><ol><li>自动初始化</li><li>通过一个成员方法显示地初始化为其他值</li><li>定义构造方法时初始化</li></ol></li><li><p>构造方法</p><p><code>[修饰符] 方法名（[形参]）[throws异常] &#123;方法体&#125;</code></p><ul><li>编译器内部机理<ol><li>为对象分配内存空间(堆)；</li><li>按缺省值初始化对象中的实例变量的值；</li><li>调用对象的构造方法(可以在构造方法中初始化其他的值)。</li></ol></li><li>构造方法重载</li></ul></li><li><p>对象创建</p><ul><li>对象的声名</li><li>对象的实例化</li><li>对象的初始化</li></ul><p>ps：对象是引用型变量，new以类为模板，开辟空间并执行相应的构造方法，完成对象的实例化和初始化，并返回该对象的一个引用（即该对象所在的内存首地址)</p></li><li><p>对象的成员变量及方法的访问</p></li><li><p>this</p><ul><li>在方法及构造方法中，可以使用this来访问对象的属性和方法。构造方法中，用this调用另一构造方法。</li><li>通过this不仅可以引用该类中定义的变量和方法，还可以引用该类的父类中定义的成员变量和方法。</li><li>在所有的非static方法中，都隐含了一个参数this。<strong>而static方法中，不能使用this。</strong></li></ul></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><code>class 新的子类名 extends 继承的父类名(必须有且只能一个)</code></p><ul><li><p>Object类是Java中所有类的直接父类或间接父类。 </p></li><li><p>子类特性：子类拥有其父类的<strong>所有</strong>属性和方法。但父类中说明为private的属性和方法，子类不可直接访问。子类可以对父类的方法覆盖或重载。</p></li><li><p>属性的继承、隐藏和添加</p><ul><li>子类可以继承父类的所有属性（只要该属性没有private修饰）</li><li>子类重新定义一个与父类那里继承来的成员变量完全相同的变量，就称作属性的隐藏。</li><li>在定义子类时，加上的新的属性变量，就可以使子类比父类多一些属性</li></ul></li><li><p>方法的继承、覆盖、重载和添加</p><ul><li><p>父类的非私有方法也可以被子类自动继承</p></li><li><p>覆盖：在子类中定义的方法和父类中的方法的首部是一样的，包括方法名、参数列表、返回类型和异常抛出。但方法体的实现改变了。</p><p>ps：覆盖的方法的首部必须要和被覆盖的方法的首部完全匹配、返回值类型一致，才能达到覆盖的效果。覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</p></li><li><p>重载：方法名相同，但参数列表不同（实际是相当于在子类中新加了一个方法）</p><p>ps：在使用重载时只能通过不同的参数表样式。不能通过访问权限、返回类型、抛出的异常进行重载。被重载的方法不能为private，否则在其子类中只是新定义了一个方法。</p></li><li><p>添加</p></li><li><p>ps：在继承机制中，不允许在子类中降低成员(包括变量和方法)的访问权限（访问权限大小关系是private&lt;缺省&lt;protected&lt;public）。即如果一个方法在父类中是protected的，那么在子类中要重载或覆盖该方法时，就不能把该方法改成是缺省或private，否则会出现编译错误。</p></li></ul></li><li><p><strong>向上转型和向下转型</strong></p><ul><li><p>向上转型</p><ul><li><p>用父类的引用变量去引用子类的实例，这是允许的。当向上转型之后，父类引用变量可以访问子类中属于父类的属性和方法，但是不能访问子类独有的属性和方法。</p></li><li><p>向上转型，在运行时，会遗忘子类对象中与父类对象中不同的方法。也会覆盖与父类中相同的方法（重写）。</p></li><li><p><strong>向上转型之后的方法调用问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Show</span><span class="hljs-params">(D obj)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;(A-D)&quot;</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Show</span><span class="hljs-params">(A obj)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;(A-A)&quot;</span>); &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Show</span><span class="hljs-params">(B obj)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;(B-B)&quot;</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Show</span><span class="hljs-params">(A obj)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;(B-A)&quot;</span>); &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Show</span><span class="hljs-params">(B obj)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;(C-B)&quot;</span>); &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Show</span><span class="hljs-params">(D obj)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;(D-D)&quot;</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Show</span><span class="hljs-params">(B obj)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;(D-B)&quot;</span>); &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mainTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>       A a1 = <span class="hljs-keyword">new</span> A();<br>       A a2 = <span class="hljs-keyword">new</span> B();<br>       B b = <span class="hljs-keyword">new</span> B();<br>       C c = <span class="hljs-keyword">new</span> C();<br>       D d = <span class="hljs-keyword">new</span> D();<br>       System.out.println(a1.Show(b)); <span class="hljs-comment">//(A-A)</span><br>       System.out.println(a1.Show(c)); <span class="hljs-comment">//(A-A)</span><br>       System.out.println(a1.Show(d)); <span class="hljs-comment">//(A-D)</span><br>       System.out.println(a2.Show(b)); <span class="hljs-comment">//(B-A)</span><br>       System.out.println(a2.Show(c)); <span class="hljs-comment">//(B-A)</span><br>       System.out.println(a2.Show(d)); <span class="hljs-comment">//(A-D)</span><br>       System.out.println(b.Show(b));  <span class="hljs-comment">//(B-B)</span><br>       System.out.println(b.Show(c));  <span class="hljs-comment">//(B-B)</span><br>       System.out.println(b.Show(d));  <span class="hljs-comment">//(A-D)</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//先改写类方法，再直接判断</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li>向下转型<ul><li>并不是所有的对象都可以向下转型，<strong>只有当这个对象原本就是子类对象通过向上转型得到的时候才能够成功转型</strong></li></ul></li></ul><ul><li><p>super</p><ul><li><p>使用情况：子类隐藏了超类中的变量或方法，而在程序中又要使用超类中被隐藏的变量或方法时使用。或者在子类的构造方法中引用超类的构造方法时使用。</p></li><li><p><strong>构造方法是不能继承的</strong>，因为继承意味着与父类的构造方法同名，但显然子类的构造方法不可能与父类的构造方法同名。但是子类的构造方法一定会调用父类的构造方法，以此类推，将继承阶层串联起来，使每个父类的构造方法皆被调用。（构造方法不能继承并不意味着子类不能调用父类的构造方法，且可以显式调用，放在第一句）</p></li><li><p>注意事项</p><ul><li>通过super不仅可以访问直接父类中定义的属性和方法，还可以访问间接父类中定义的属性和方法。</li><li>由于它指的是父类对象，所以super不能在static环境中使用，包括类变量、类方法和static语句块。</li><li>使用super不能访问本类定义的属性和方法</li><li>在构造方法中使用super时，super语句必须放在第一句 </li><li>在子类的构造方法中，super可以不明确使用，也可以明确使用。</li><li>建议：在写多个继承关系的类时，尽量在子类的构造方法中明确使用super调用父类的构造方法，<strong>继承默认调用super（）</strong></li></ul></li><li><p>构造方法的调用顺序</p><ul><li>首先调用父类的构造方法。这个步骤会反复递归，使继承阶层的<strong>根源最先</strong>被构建，然后是次一层的子类，直至最末一层子类为止；</li><li>根据各个成员的<strong>声明顺序</strong>，执行成员变量的初始化赋值；</li><li>执行该构造方法中的各语句。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;base&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Base</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Base(): &quot;</span> + name);<br>        tellName();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tellName</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Base tell name: &quot;</span> + name);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;derived&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Derived</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Derived():&quot;</span>+ name);<br>        tellName();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tellName</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Derived tell name: &quot;</span> + name);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">new</span> Derived();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*输出</span><br><span class="hljs-comment">Base(): base</span><br><span class="hljs-comment">Derived tell name: null</span><br><span class="hljs-comment">Derived():derived</span><br><span class="hljs-comment">Derived tell name: derived</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>父类对象与子类对象的转换</p><ul><li>原则<ul><li>子类对象转为父类对象时，可以是显示的或隐式的，子类对象直接向父类对象赋值；</li><li>父类对象不能被任意的转换成某一子类的对象，只有父类对象指向的实际是一个子类对象，那么这个父类对象可以转换成子类对象，但此时必须用强制类型转换。</li><li>如果一个方法的形式参数定义的是父类对象，那么调用这个方法时，可以使用子类对象作为实际参数。</li></ul></li></ul></li><li><p><strong>抽象类与抽象方法</strong></p><ul><li>抽象类不能创建任何对象，抽象类必须产生其子类，由子类创建对象。</li><li>抽象类中可以包含抽象方法，也可以不包含抽象方法，但如果类中的某一方法是抽象的，整个类就必须被说明成抽象的。 </li><li>抽象方法在子类中必须被实现，否则子类仍是抽象的。</li><li>抽象类不是可有可无的</li></ul></li><li><p>final类和final方法</p><ul><li>如果一个类被final修饰符所修饰和限定，说明这个类不能被继承，即不可能有子类，就不能重载或覆盖它的任何方法</li><li>所有已被private修饰符限定为私有的方法，以及所有包含在final类中的方法，都被默认为是final的。因为这些方法不可能被子类所继承，所以不可能被重载，自然都是最终的方法。</li></ul></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><code>[修饰符] interface 接口名 [extends] [接口列表] &#123;接口体&#125;</code></p><ul><li><p>接口定义了一些没有实现的方法和静态常量集，使程序设计和实现相互分离，同时弥补Java只支持单重继承的不足，也可以约束实现接口的类。</p></li><li><p>Java接口反映了对象较高层次的抽象，为描述相互似乎没有关系的对象的共性提供了一种有效的手段。 </p></li><li><p>和类的区别</p><ul><li>类只能单继承，而接口可以多继承。</li><li>类中的方法可以是具体的，也可以抽象的。 接口中的方法都是抽象的。</li><li>接口中的方法要用类来实现，一个类可以实现多个接口。</li></ul></li><li><p><strong>和抽象类的区别</strong></p><ul><li>接口要被子类实现，抽象类要被子类继承</li><li>接口中变量全为公共静态常量，抽象类中可以有普通变量</li><li>接口中都是方法的声明，抽象类中可以有方法的实现</li><li>接口不可以有构造函数，抽象类可以有</li><li>接口可以多实现，抽象类必须单继承</li><li>接口方法都是抽象方法，抽象类可以有非抽象方法</li><li>接口优先于抽象类</li></ul></li><li><p>首部修饰符：不使用修饰符（同包访问），或者public（任意访问）</p></li><li><p>接口体：接口的成员：成员变量和方法</p><ul><li>成员变量：隐含public、static、final的静态最终变量（常量）</li><li>方法：隐含public和abstract的抽象方法（不能使用static、native、synchronized、final）</li></ul></li><li><p>对接口的引用</p></li><li><p>使用接口实现多重继承</p></li><li><p>多态性建立的基础</p><ul><li>继承</li><li>向上转型</li><li>动态绑定：能在运行期间判断参数的实际类型，并分别调用适当的方法体，从而实现了多态性。在Java中所有非final和非static的方法都会自动地进行动态绑定。</li></ul></li><li><p>简单工厂模式（静态工厂方法模式）</p><ul><li>角色：工厂角色（能根据业务动态选择生产哪些产品）、抽象产品角色（产品有哪些特点，能做什么）、具体产品角色（产品怎么做）</li><li><strong>简单工厂乐器类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Playable</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wind</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Playable</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">&quot;管乐器~~吹&quot;</span>);&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Percussion</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Playable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">&quot;打击乐器~~打&quot;</span>);&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stringed</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Playable</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">&quot;弦乐器~~弹&quot;</span>);&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstrumentFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Playable <span class="hljs-title">createInstrument</span><span class="hljs-params">(String insName)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;wind&quot;</span>.equals(insName)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Wind();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;percussion&quot;</span>.equals(insName))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Percussion();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;stringed&quot;</span>.equals(insName)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Stringed();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleFactoryMain</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Playable aWind = InstrumentFactory.createInstrument(<span class="hljs-string">&quot;wind&quot;</span>);<br>        Playable aPercussion = InstrumentFactory.createInstrument(<span class="hljs-string">&quot;percussion&quot;</span>);<br>        Playable aStringed = InstrumentFactory.createInstrument(<span class="hljs-string">&quot;stringed&quot;</span>);<br>        <span class="hljs-keyword">if</span> (aWind != <span class="hljs-keyword">null</span>) aWind.play();<br>        <span class="hljs-keyword">if</span> (aPercussion != <span class="hljs-keyword">null</span>) aPercussion.play();<br>        <span class="hljs-keyword">if</span> (aStringed != <span class="hljs-keyword">null</span>) aStringed.play();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ul><li><p>作用</p><ul><li>包能够让程序员将类组织成单元，通过文件夹或目录来组织文件和应用程序；</li><li>包减少了名称冲突带来的问题，可以防止同名的类发生冲突；</li><li>包能够更大面积的保护类、变量和方法，而不是分别对每个类进行保护；</li><li>包可以用于标示类。</li></ul></li><li><p>创建：说明语句必须放在整个.java文件的第一行。可以在不同的文件中使用相同的包说明语句，这样就可以将不同文件中的类都包含到相同的程序包中。</p></li><li><p>包的引用</p><ul><li><p>使用全名引用</p><ul><li>同包的类相互引用时：在使用的属性或方法名前加上类名作为前缀即可</li><li>不同包中的类相互引用时：在类名的前面再加上包名，类的全名</li></ul></li><li><p>使用import</p><p>import可以加载整个包中的文件或包中的某一个文件。</p></li></ul></li></ul><h2 id="Java变量及其传递"><a href="#Java变量及其传递" class="headerlink" title="Java变量及其传递"></a>Java变量及其传递</h2><ul><li><p>成员变量与局部变量区别</p><ul><li>从语法形式上看：成员变量是属于类或接口的，而局部变量是在方法中定义的变量或方法的参变量；成员变量可以被public，private，static等修饰，而局部变量则不能被访问控制符及static修饰；成员变量及局部变量都可以被final修饰。</li><li>从变量在内存中的存储方式看：成员变量是对象的一部分，而对象是存在于堆中的，而局部变量是存在于栈中的。</li><li>从变量在内存中的存在时间上看：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而产生，随着方法调用结束而自动消失。</li><li>成员变量如果没有赋初值，则会自动以该类型的默认值（0,false,null等）赋值；而局部变量则不会自动赋值，必须显示地赋值后才能使用。 </li></ul></li><li><p>变量的传递</p><ul><li><p>Java中方法参数传递方式是按值传递。如果参数是基本类型，传递的是基本类型的字面量值的拷贝。如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。</p></li><li><p><a href="https://www.zhihu.com/question/31203609">其他知乎解答</a></p></li><li><p>对于基本类型的变量形参修改了并不能反映到函数外面的实参</p></li><li>对于引用类型的变量，在形参中修改了对象实体值可以反映到实参，在形参中修改了对象引用值，不能反映到实参</li><li>String和StringBuffer的其他区别：<ol><li>StirngBuffer是可以变话的，如果改变了StringBuffer变量的长度或内容，不会改变对这个对象的引用。</li><li>String是固定的，如果改变了String变量的长度或内容，就会新建一个String对象，原来的String变量会指向新的String对象。</li></ol></li></ul></li><li><p>引用型变量的比较</p><ul><li><p>问题引入：<code>==</code>和<code>!=</code>用来比较引用型变量时,只能判断运算符两边引用的是不是同一个对象,即对象的地址值（或对象引用值）是不是相同，需要用<code>equals()</code>方法比较两个对象的内容(对象实体值)是否相同。</p></li><li><p>ps：Java为节省内存空间、提高运行效率，编译时将String Pool中所有相同的字符串合并，只占用一个空间。导致引用变量a和b指向同一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">String a=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;hello&quot;</span>);<br>String b=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;hello&quot;</span>);<br>System.out.println(a==b);        <span class="hljs-comment">//false</span><br>System.out.println(a.equals(b)); <span class="hljs-comment">//true</span><br>String c=<span class="hljs-string">&quot;hello&quot;</span>;<br>String d=<span class="hljs-string">&quot;hello&quot;</span>;<br>System.out.println(c==d);        <span class="hljs-comment">//true</span><br>System.out.println(c.equals(d)); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure></li><li><p>自己定义的类如果要支持equals方法必须重写从Object类继承来的equals方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Object类中的equals方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>==obj);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li>内部类不能与外部类同名（否则，编译器无法区分内部类与外部类），如果内部类还有内部类，内部类的内部类不能与它的任何一层外部类同名。 </li><li>创建<ul><li>创建非静态内部类的对象时一定要确保已经有一个外部类对象<ul><li>利用外部类的方法创建并返回，因为方法是由外部类对象调用的，那创建该内部类对象时，一定已经拥有了所属的外部类对象了</li><li>创建内部类还可以在除外部类中的其它类中，但是要确保该类具有访问内部类的权限，并且已经创建了一个外部类对象。</li></ul></li><li>内部类的修饰符</li><li>静态内部类<ul><li>实例化static内部类时，在new前面不需要用对象变量</li><li>static内部类中不能访问其外部类的非static属性及方法，即只能访问static成员</li><li>方法中的内部类，可以访问其外部类的成员；若是static方法中的内部类，可以访问外部类的static成员。</li><li>方法中的内部类，不能访问该方法的局部变量，除非是final的局部变量。</li></ul></li></ul></li><li>使用<ul><li>内部类中访问外部类的成员<ul><li>内部类中是可以直接访问外部类的其他属性与方法的，即使它们是private的。</li><li>如果内部类中有与外部类同名的属性与方法，可以使用<code>outerClass.this.x</code>或<code>this.x</code>的格式来表达外部类的引用，从而区分外部类和内部类的同名的属性与方法。</li></ul></li><li>方法和作用域中的内部类</li></ul></li><li>匿名内部类<ul><li>这种类不取名字，而直接用其父类的名字或者它所实现的接口的名字</li><li>类的定义与创建该类的一个对象同时进行，即类的定义前面有一个new，没有类的首部，对象的创建和类体共同构成一个匿名类表达式，后面以“;”结束；</li><li>类中不能定义构造方法，因为它没有名字。</li></ul></li></ul><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>Java把程序运行过程中可能遇到的问题分为两类，一类是致命性的，即程序遇到了非常严重的不正常状态，不能简单地恢复执行，这就是错误(对应Error类)，如程序运行过程中内存耗尽。另一类是非致命性的，通过某种处理后程序还能继续运行，这就是异常(对应Exception类)。</li><li>按异常在编译时是否被检测来分，Exception类子类有两种：运行时异常和非运行时异常（一般异常）<ul><li>运行时异常：RuntimeException类及其所有子类。运行时异常是程序员编写程序不正确所导致的异常，理论上，程序员经过检查和测试可以查出这类错误。如除数为零等，错误的强制类型转换、数组越界访问、空引用。</li><li>非运行时异常（一般异常）：指可以由编译器在编译时检测到的、可能会发生在方法执行过程中的异常，如找不到指定的文件等，这不是程序本身的错误，如果这些异常情况没有发生，程序本身仍然是完好的</li></ul></li><li>处理异常的三种方法<ul><li>用户可以用try-catch-finally语句进行捕获和处理</li><li>如果不想捕获和处理异常，可以通过throws语句声明要抛出的异常</li><li>用户可以定义自己的异常类,并用throw语句来抛出。</li></ul></li></ul><h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//访问文本文件text.txt，并将其在屏幕上打印出来。</span><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TryCatchFinally</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            FileInputStream in = <br>                <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;text.txt&quot;</span>);<br>            <span class="hljs-keyword">int</span> s;<br>            <span class="hljs-keyword">while</span>((s=in.read())!=-<span class="hljs-number">1</span>) <br>                System.out.print(s);<br>            in.close();<br>        &#125; <span class="hljs-keyword">catch</span>(FileNotFoundException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;捕获异常：&quot;</span>+e);<br>        &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>System.out.println(<span class="hljs-string">&quot;捕获异常：&quot;</span>+e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;finally块总是执行！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当产生的异常找到了第一个与之相匹配的参数时，就执行包含这一参数的catch语句中的Java代码，执行完catch语句后，程序恢复执行，但不会回到异常发生处继续执行，而是执行try-catch结构后面的代码。</li><li>可以用一个catch块来处理多个异常类型，此时catch的参数应该是这多个异常的父类。</li><li>有多个catch块时，要细心安排catch块的顺序。将子类的catch块放在前面，父类的catch块放在后面。</li><li>执行过程<ul><li>try块中的语句没有产生异常。在这种情况下，Java首先执行try块中的所有的语句，然后执行finally子句中的代码，最后执行try…catch..finally块后面的语句；</li><li>try块中的语句产生了异常，而且此异常在方法内被捕获。在这种情况下，Java首先执行try块中的语句，直到产生异常处，然后跳过此try块中剩下的语句，执行捕获此异常的catch子句的处理代码；然后执行finally子句中的代码</li><li>如果在catch子句又重新抛出了异常。也会执行finally，然后将这个异常抛出给方法的调用者；</li><li>try块中产生了异常，而此异常在方法内没有被捕获。在这种情况下，Java将执行try块中的代码直到产生异常，然后跳过try块中的代码而转去执行finally子句中的代码，最后将异常抛出给方法的调用者。</li></ul></li></ul><h2 id="throws抛出异常"><a href="#throws抛出异常" class="headerlink" title="throws抛出异常"></a>throws抛出异常</h2><p>不捕获异常，而是将异常交由上一层处理，在其他地方捕获异常。如果使用后者，那么应该（在某些情况下）向编译器表明：此方法可能会抛出异常，但方法本身不会捕获它。可以在方法头中用<code>throws</code>子句来实现此功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.调用的方法抛出了异常 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    ……<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInput</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>……<br>    System.in.read();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 2.检测到了错误并使用throw语句抛出异常</span><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    ……<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInput</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>……<br>IOException ae = <br>            <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;buffer is full&quot;</span>);<br><span class="hljs-keyword">throw</span> ae; <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="throw抛出异常"><a href="#throw抛出异常" class="headerlink" title="throw抛出异常"></a>throw抛出异常</h2><ul><li>一般这种抛出异常的语句应该在满足一定条件执行，例如把throw语句if分支中</li><li>含有<code>throw</code>语句的方法，应该在方法头定义中用<code>throws</code>语句声明所有可能抛出的异常</li><li>抛出异常三步：确定异常类；创建异常类的实例；抛出异常。</li></ul><h1 id="类库"><a href="#类库" class="headerlink" title="类库"></a>类库</h1><h2 id="java-lang"><a href="#java-lang" class="headerlink" title="java.lang"></a>java.lang</h2><ul><li><p><code>String</code></p><ul><li><p>可创建一个对象，用于代表一个字符串(不变的字符串)，并定义了类似查找，比较和连接字符的操作。所有字符串常量都是String对象，存储在String Pool（字符串池）中，字符串池是常量池的一部分。</p></li><li><p>String类对象一旦创建，其内容不可更改。String类的所有方法都不会改变String类对象内容，要改变String类对象的值就必须创建一个新的String对象。</p></li><li>String是类，在比较字符串内容时，不能用==，而应该用<code>equals</code>方法。String类覆盖了Object类的equals方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//求字串，前闭后开</span><br>String a=<span class="hljs-string">&quot;hello&quot;</span>;<br>String b=a.substring(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>); <span class="hljs-comment">// 得到hell</span><br><br><span class="hljs-comment">//长度</span><br>String c=<span class="hljs-string">&quot;hello你好&quot;</span>;<br><span class="hljs-keyword">int</span> d=c.length();          <span class="hljs-comment">// 得到7</span><br><br><span class="hljs-comment">//得到字符串中指定下标的字符。</span><br>String a=”hello”; <span class="hljs-keyword">char</span> b;<br>b=a.charAt(<span class="hljs-number">0</span>);             <span class="hljs-comment">// 得到下标为0的字符h</span><br><br><span class="hljs-comment">//字符数组转换为String</span><br><span class="hljs-keyword">char</span>[] a=&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>&#125;;<br>String b=<span class="hljs-keyword">new</span> String(a);<br><br><span class="hljs-comment">//String转换为字符数组</span><br>String a=<span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">char</span>[] b=a.toCharArray();<br><br><span class="hljs-comment">//字节数组转换为String</span><br><span class="hljs-keyword">byte</span>[] a=&#123;<span class="hljs-number">65</span>,<span class="hljs-number">66</span>,<span class="hljs-number">67</span>,<span class="hljs-number">68</span>&#125;;<br>String b=<span class="hljs-keyword">new</span> String(a);    <span class="hljs-comment">// 得到ABCD</span><br><br><span class="hljs-comment">//大小写转换</span><br>String s1=<span class="hljs-string">&quot;Hello&quot;</span>;<br>String s2=s1.toUpperCase(); <span class="hljs-comment">// 得到HELLO</span><br>String s3=s1.toLowerCase(); <span class="hljs-comment">// 得到hello</span><br><br><span class="hljs-comment">//其他数据类型to字符串</span><br>String out2 = String.valueOf(<span class="hljs-number">100</span>);<br>String out3 = <span class="hljs-string">&quot;&quot;</span>+<span class="hljs-number">100</span>;<br>String out1 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">100</span>).toString();<br></code></pre></td></tr></table></figure></li><li><p><code>StringBuffer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//三种创建方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuffer</span><span class="hljs-params">()</span>；</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span>；</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuffer</span><span class="hljs-params">(String str)</span>；</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//更新</span></span><br><span class="hljs-function">StringBuffer s</span>=<span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;hello&quot;</span>);<br>s.append(<span class="hljs-string">&quot;java&quot;</span>);   <span class="hljs-comment">// s变为hellojava</span><br>s.insert(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;sun&quot;</span>);  <span class="hljs-comment">// s变为hellosunjava</span><br>s.setCharAt(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;H&#x27;</span>); <span class="hljs-comment">// s变为Hellosunjava</span><br>s.delete(<span class="hljs-number">5</span>,<span class="hljs-number">8</span>);      <span class="hljs-comment">// s变为Hellojava</span><br><br><span class="hljs-comment">//StringBuffer对象和String对象的转换</span><br>StringBuffer s = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;hello&quot;</span>);<br>String a = s.toString();<br></code></pre></td></tr></table></figure></li><li><p>数据类型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将字符串转换为int型 </span><br>String s = <span class="hljs-string">&quot;1234&quot;</span>;<br><span class="hljs-keyword">int</span> i = Integer.parseInt(s);<br><span class="hljs-keyword">int</span> i = Integer.parseInt(s,<span class="hljs-number">16</span>); <span class="hljs-comment">//16进制</span><br><br><br><span class="hljs-comment">//将int型转换为字符串</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">1234</span>;<br>String s = Integer.toString(i);<br></code></pre></td></tr></table></figure></li><li><p><code>Math</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//PI</span><br><span class="hljs-keyword">double</span> x = Math.PI<br>    <br><span class="hljs-comment">//接受一个double类型的弧度值,返回类型均为double</span><br>sin(<span class="hljs-keyword">double</span> a) <span class="hljs-comment">//返回弧度a的sin值</span><br>cos(<span class="hljs-keyword">double</span> a) <span class="hljs-comment">//返回弧度a的cos值</span><br>tan(<span class="hljs-keyword">double</span> a) <span class="hljs-comment">//返回弧度a的tan值</span><br>    <br><span class="hljs-comment">//反三角函数，返回类型均为double型。</span><br>asin(<span class="hljs-keyword">double</span> r) <span class="hljs-comment">//返回sin值为r的弧度</span><br>acos(<span class="hljs-keyword">double</span> r) <span class="hljs-comment">//返回cos值为r的弧度</span><br>atan(<span class="hljs-keyword">double</span> r) <span class="hljs-comment">//返回tan值为r的弧度</span><br><br><span class="hljs-comment">//返回类型均为double型</span><br>pow(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y) <span class="hljs-comment">//返回x^y。</span><br>exp(<span class="hljs-keyword">double</span> x)           <span class="hljs-comment">//返回e^x</span><br>log(<span class="hljs-keyword">double</span> x)           <span class="hljs-comment">//返回log_e(x)。</span><br>sqrt(<span class="hljs-keyword">double</span> x)          <span class="hljs-comment">//返回x的平方根。</span><br><br><span class="hljs-comment">//取整</span><br>ceil(<span class="hljs-keyword">double</span> a)  <span class="hljs-comment">//返回double</span><br>floor(<span class="hljs-keyword">double</span> a) <span class="hljs-comment">//返回double</span><br>rint(<span class="hljs-keyword">double</span> a)  <span class="hljs-comment">//返回四舍五入后的整数值，double</span><br>round(<span class="hljs-keyword">float</span> a)  <span class="hljs-comment">//返回四舍五入后的整数值, int</span><br>round(<span class="hljs-keyword">double</span> a) <span class="hljs-comment">//返回四舍五入后的整数值, long</span><br><br><span class="hljs-comment">//要求a、b类型相同，返回类型一致</span><br>max(a,b)  <span class="hljs-comment">//返回a和b的最大值</span><br>min(a,b)  <span class="hljs-comment">//返回a和b的最小值 </span><br><br><span class="hljs-comment">//随机数</span><br>random(); <span class="hljs-comment">//得到一个[0,1)之间的随机数，返回double</span><br>(<span class="hljs-keyword">int</span>)(Math.random()*<span class="hljs-number">60</span> + <span class="hljs-number">20</span>)<br>(<span class="hljs-keyword">int</span>)(Math.random()*<span class="hljs-number">60</span>)+ <span class="hljs-number">20</span><br><span class="hljs-comment">//使用随机函数获得20~80的随机整数</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="java-util"><a href="#java-util" class="headerlink" title="java.util"></a>java.util</h2><ul><li><p>日期时间类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Date</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Date</span><span class="hljs-params">(<span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> date)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Date</span><span class="hljs-params">(<span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> date, <span class="hljs-keyword">int</span> hours,<span class="hljs-keyword">int</span> minutes)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Date</span><span class="hljs-params">(<span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> date, <span class="hljs-keyword">int</span> hours, <span class="hljs-keyword">int</span> minutes, <span class="hljs-keyword">int</span> seconds)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//获取</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getYear</span><span class="hljs-params">()</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMonth</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDate</span><span class="hljs-params">()</span></span>;      <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDay</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHours</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMinutes</span><span class="hljs-params">()</span></span>;      <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSeconds</span><span class="hljs-params">()</span></span>;      <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">before</span><span class="hljs-params">(Date when)</span></span>;<br><br><span class="hljs-comment">//比较</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">before</span><span class="hljs-params">(Date when)</span>；</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">after</span><span class="hljs-params">(Date when)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span>;<br><br><span class="hljs-comment">//转换</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>vector&lt;E&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造</span><br>Vector();<br>Vector(<span class="hljs-keyword">int</span> capacity);<br>Vector(<span class="hljs-keyword">int</span> capacity, <span class="hljs-keyword">int</span> capacityIncrement);<br><span class="hljs-comment">//eg</span><br>Vector&lt;String&gt; vector1=<span class="hljs-keyword">new</span> Vector&lt;String&gt;(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">//修改</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertElementAt</span><span class="hljs-params">(E obj, <span class="hljs-keyword">int</span> index)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setElementAt</span><span class="hljs-params">(E obj, <span class="hljs-keyword">int</span> index)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeElementAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>;<br>clear()<br><br><span class="hljs-comment">//获取</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span></span>;<br><span class="hljs-function">E <span class="hljs-title">elementAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>Hashtable&lt;K,V&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Hashtable &lt;K,V&gt;();<br><span class="hljs-function">V <span class="hljs-title">put</span> <span class="hljs-params">(K key, V value)</span></span>;<br><span class="hljs-function">V <span class="hljs-title">get</span> <span class="hljs-params">(Object key)</span></span>; <span class="hljs-comment">//关键字匹配</span><br><span class="hljs-function">V <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span></span>; <br></code></pre></td></tr></table></figure><ul><li>覆盖<code>equals</code>方法和<code>hashCode</code>方法<ul><li>原因：关键字匹配时，系统会自动调用关键字的equals方法，如果结果为true且两个关键字的hashCode()方法的结果也相等，则匹配成功。如果没有在关键字类中覆盖equals方法和hashCode方法，则系统会去调用继承自Object类的equals方法和继承自Object类的hashCode方法。Object类的equals方法是在比较两个对象的地址。Object类的hashCode方法是计算对象的地址的散列值。所以这时就算两个关键字对象实体值（即对象内容）相同，也不会匹配。</li><li>要求<ul><li>值相同的两个关键字对象用equals方法比较后相等</li><li>值相同的两个关键字对象的hashCode方法结果相等</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> date;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>    A aobj=<span class="hljs-keyword">null</span>;<br>     <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> A) &#123;<br>aobj=(A)obj;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.date==aobj.date) <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>     &#125;<br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> date;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>Stack&lt;E&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Stack()     <br><span class="hljs-function">E <span class="hljs-title">push</span> <span class="hljs-params">(E item)</span></span><br><span class="hljs-function">E <span class="hljs-title">pop</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong><em>集合类</em></strong></p></li><li><p><code>Arrays</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用Arrays.sort来对数组排序</span><br>java.util.Arrays.sort(x);<br><br><span class="hljs-comment">//使用Arrays.binarySearch函数对数组进行二分查找</span><br><span class="hljs-comment">//如果没找到，则会输出负数</span><br>java.util.Arrays.binarySearch(x,<span class="hljs-number">1</span>));<br><br><span class="hljs-comment">//数组x中的4个元素都改为7</span><br>java.util.Arrays.fill(x,<span class="hljs-number">7</span>);<br></code></pre></td></tr></table></figure></li></ul><h2 id="java-io"><a href="#java-io" class="headerlink" title="java.io"></a>java.io</h2><ul><li><p>字节流</p><ul><li><p>InputStream和OutputStream是所有面向字节的输入输出流的超类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">( <span class="hljs-keyword">byte</span>[] b )</span> <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">( <span class="hljs-keyword">byte</span>[] b, <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len )</span> <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> b)</span> <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">( <span class="hljs-keyword">byte</span>[] b )</span> <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">( <span class="hljs-keyword">byte</span>[] b, <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len )</span> <span class="hljs-keyword">throws</span> IOException</span><br></code></pre></td></tr></table></figure></li><li><p>FileInputStream和FileOutputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">FileInputStream fs=<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>File file=<span class="hljs-keyword">new</span> File (<span class="hljs-string">&quot;a.txt&quot;</span>);<br>FileInputStream fs=<span class="hljs-keyword">new</span> FileInputStream(file);<br><br>FileOutputStream(File file) <br>FileOutputStream(File file, <span class="hljs-keyword">boolean</span> append) <br>FileOutputStream(FileDescriptor fdObj)     <br>FileOutputStream(String name) <br>FileOutputStream(String name, <span class="hljs-keyword">boolean</span> append)<br></code></pre></td></tr></table></figure></li><li><p>过滤流 </p><p>必须将过滤流和节点流连接。连接是通过在过滤流的构造方法中指定入口参数——某个节点流对象来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">FileInputStream in=<span class="hljs-keyword">new</span> FileInputStream(“text”);<br>BufferedInputStream bufin=<span class="hljs-keyword">new</span> BufferedInputStream(in);<br></code></pre></td></tr></table></figure><ul><li><p>BufferedInputStream和BufferedOutputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span></span>; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BufferedInputStream</span><span class="hljs-params">(InputStream in,<span class="hljs-keyword">int</span> size)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>ObjectInputStream和ObjectOutputStream</p></li></ul></li></ul></li><li><p>字符流</p><ul><li><p>Reader和Writer</p><p>是所有面向字符的输入输出流的超类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] cbuf)</span> <span class="hljs-keyword">throws</span> IOException </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] cbuf,<span class="hljs-keyword">int</span> off,<span class="hljs-keyword">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException  </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(String str)</span> <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] cbuf)</span> <span class="hljs-keyword">throws</span> IOException </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] cbuf,<span class="hljs-keyword">int</span> off,<span class="hljs-keyword">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException  </span><br></code></pre></td></tr></table></figure></li><li><p>FileReader和FileWriter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">File f=<span class="hljs-keyword">new</span> File(“d:\\t1.txt”); <br>FileReader f1=<span class="hljs-keyword">new</span> FileReader(f);<br>FileReader f2=<span class="hljs-keyword">new</span> FileReader(“d:\\t1.txt”);<br><br>File f=<span class="hljs-keyword">new</span> File(“d:\\t1.txt”); <br>FileWriter f1=<span class="hljs-keyword">new</span> FileWriter(f);   <br>FileWriter f2=<span class="hljs-keyword">new</span> FileWriter(“d:\\t1.txt”);<br></code></pre></td></tr></table></figure></li><li><p>InputStreamReader和OutputStreamReader</p><p>把字节流转换成字符流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InputStreamReader</span><span class="hljs-params">(InputStream in)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InputStreamReader</span><span class="hljs-params">(InputStream in,String enc)</span> </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OutputStreamWriter</span><span class="hljs-params">(OutputStream out)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OutputStreamWriter</span><span class="hljs-params">(OutputStream out,String enc)</span> </span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>输入汉字的时候，因为相当于读取了字符的高/低位字节，并未读取完整的汉字。因此需要将字节流转换为字符流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">InputStreamReader isr=<span class="hljs-keyword">new</span> InputStreamReader(System.in);<br><span class="hljs-keyword">try</span> &#123;<br>c=(<span class="hljs-keyword">char</span>)isr.read();<br>System.out.println(c);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>File</code></p><ul><li>在Java中目录和文件都用File类表示，File类建立了Java语言和磁盘文件的联系，File类不能于文件内容的访问。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造</span><br>File(String pathname)<br>File(File parent, String child) <br>File(String parent, String child)<br>File(URI uri)<br><br><span class="hljs-comment">/* pathname和child指定文件名；</span><br><span class="hljs-comment">parent指定目录名，目录名既可以是字符串，也可以是File对象；</span><br><span class="hljs-comment">uri是统一资源标识符（见java.net包）</span><br><span class="hljs-comment">要表示‘\’字符（反斜杠）要用转义字符‘\\’ */</span><br><br><span class="hljs-comment">//文件操作类方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">createNewFile</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">renameTo</span><span class="hljs-params">(File dest)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">delete</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//目录操作类方法</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">mkdir</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String[] <span class="hljs-title">list</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> File[] <span class="hljs-title">listFiles</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//获取文件属性</span></span><br><span class="hljs-function">...</span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-comment">//使用File类创建文件、目录</span></span><br><span class="hljs-function"><span class="hljs-keyword">import</span> java.io.File</span>; <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">creatFile</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建文件</span><br>            File f1=<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;H:\\a.txt&quot;</span>);<br>            <span class="hljs-keyword">boolean</span> success=f1.createNewFile();<br>            <span class="hljs-comment">//创建目录</span><br>            <span class="hljs-comment">//File f1=new File(&quot;H:\\a&quot;);</span><br>            <span class="hljs-comment">//boolean success=f1.mkdir();</span><br>            <span class="hljs-keyword">if</span>(success) &#123;<br>                     System.out.println(<span class="hljs-string">&quot;Creat Successfully&quot;</span>);&#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(f1.getPath());<br>            &#125;<br>          &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>                 System.out.println(e.toString());<br>          &#125;<br>&#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h2><ul><li><p>泛型的本质是参数化类型，编写的代码可以被很多不同类型的对象或数据所重用，也就是说所操作的数据类型被指定为一个参数。使得程序具有更好的可读性和安全性。</p></li><li><p><strong>访问 List<T> 与 ArrayList 的对比</strong></p><p><img src="https://s2.loli.net/2022/01/07/U5IOWlGEuj8fpSH.png" style="zoom:50%;" /></p></li></ul><h1 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h1><h2 id="Frame-JFrame"><a href="#Frame-JFrame" class="headerlink" title="Frame(JFrame)"></a>Frame(JFrame)</h2><ul><li>Frame类的对象开始是不可见的，要调用show()方法 (或setVisible(true)方法) 才能显示出来，也可以调用hide()方法将其隐藏。框架对象被创建后就可使用add()方法将其它组件加入到框架中。</li><li>Frame和Dialog是Window的子类，它们都是窗口类，默认的布局管理器都是 <strong>BorderLayout</strong> </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Frame()        <span class="hljs-comment">//创建一个不带标题的框架</span><br>Frame(String)  <span class="hljs-comment">//创建一个带标题的框架</span><br>    <br>show()                  <span class="hljs-comment">//显示框架</span><br>setVisible(<span class="hljs-keyword">boolean</span> b)   <span class="hljs-comment">//使框架可见/不可见</span><br>hide()                  <span class="hljs-comment">//隐藏框架</span><br>setTitle()              <span class="hljs-comment">//设置框架的标题</span><br>setSize(<span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> h)   <span class="hljs-comment">//调整框架的尺寸(宽/高为w/h)</span><br>setBounds(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> w,<span class="hljs-keyword">int</span> h)<br><span class="hljs-comment">//调整框架的位置及尺寸(左上角为(x,y), 宽、高为w、h)</span><br>add(Component ob)<br><span class="hljs-comment">//将其它组件ob加入到框架的中心位置 </span><br>add(String p, Component ob)   <br><span class="hljs-comment">//将组件ob加入到框架的p位置 (框架默认的布局方式是BorderLayout,  它将容器划分为东西南北中)</span><br></code></pre></td></tr></table></figure><h2 id="panel-Jpanel"><a href="#panel-Jpanel" class="headerlink" title="panel(Jpanel)"></a>panel(Jpanel)</h2><ul><li>面板panel(Jpanel)是能在屏幕上实际显示的组件，提供了容纳其他组件的功能，但本身必须放在Window,Frame,Dialog等容器中才能使用</li><li>所有面板的默认的布局管理器是<strong>FlowLayout</strong>,即按照从左至右、从上到下的方式布局</li><li>java.applet.Applet是java.awt.panel的子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">import</span> java.applet.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContainerApplet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Applet</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>          setLayout(<span class="hljs-keyword">new</span> GridLayout(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>));<br>          Panel Panel1=<span class="hljs-keyword">new</span> Panel();<br>          Panel Panel2=<span class="hljs-keyword">new</span> Panel();<br>          add(Panel1);<br>          add(Panel2);<br>          Panel1.add(<span class="hljs-keyword">new</span> Button(“Up”));<br>          Panel1.add(<span class="hljs-keyword">new</span> Button(“Down”));<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="button"><a href="#button" class="headerlink" title="button"></a>button</h2><p>流程：定义一个按钮对象；用new实例化按钮对象；（可以与上一步合并）；用add方法将按钮加入容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Button()             <span class="hljs-comment">//生成一个没有标记的按钮</span><br>Button(String label) <span class="hljs-comment">//生成一个带标记label的按钮</span><br><br>setLabel(String label) <span class="hljs-comment">//设置按钮标记 </span><br>getLabel()             <span class="hljs-comment">//获取按钮标记</span><br>setEnabled(<span class="hljs-keyword">boolean</span>)    <span class="hljs-comment">//能否点击</span><br>setActionCommand(String s)<br><span class="hljs-comment">//设置用户按下按钮时返回的信息</span><br>addActionListener(ActionListener l) <br><span class="hljs-comment">//将l指定为按钮的监听者</span><br>removeActionListener(ActionListener l) <br><span class="hljs-comment">//将l从按钮监听者中去掉</span><br></code></pre></td></tr></table></figure><h2 id="标签-Lable"><a href="#标签-Lable" class="headerlink" title="标签(Lable)"></a>标签(Lable)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">la1=<span class="hljs-keyword">new</span> Label();<br>la2=<span class="hljs-keyword">new</span> Label(<span class="hljs-string">&quot;Label2&quot;</span>);<br><br>getAlignment()       <span class="hljs-comment">//获取对齐方式</span><br>getText()            <span class="hljs-comment">//获取文本</span><br>setAlignment(<span class="hljs-keyword">int</span> aligmnent)  <span class="hljs-comment">//设置对齐方式 Label.CENTER</span><br>setText(String text)         <span class="hljs-comment">//设置文本</span><br>    <br><span class="hljs-comment">//JLabel中是调用</span><br>setHorizontalAlignment(SwingConstants.CENTER);<br></code></pre></td></tr></table></figure><h2 id="文本框-TextField"><a href="#文本框-TextField" class="headerlink" title="文本框(TextField)"></a>文本框(TextField)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">TextField()              <span class="hljs-comment">//创建一个空的文本框</span><br>TextField(Strint text)   <span class="hljs-comment">//创建一个带有初始文本的文本框</span><br>TextField(<span class="hljs-keyword">int</span> Columns)   <span class="hljs-comment">//创建一个指定列数的文本框    </span><br>TextField(String text, <span class="hljs-keyword">int</span> colulmns)<br><span class="hljs-comment">//创建一个指定列数和带有初始文本的文本框 </span><br><br>addActionListener(ActionListener l)<br><span class="hljs-comment">//将l指定为文本框的ActionEvent事件监听者 </span><br>removeActionListener(ActionListener l)<br><span class="hljs-comment">//将l从文本框的监听者中去掉</span><br>setEchoChar(String sc)   <span class="hljs-comment">//设置用户输入的回应字符&#x27;*&#x27;密码</span><br>getEchoChar()            <span class="hljs-comment">//获取回应字符 </span><br>setText(String s)        <span class="hljs-comment">//设置文本框中的字符串 </span><br>getText()                <span class="hljs-comment">//获取文本框中的字符串 </span><br></code></pre></td></tr></table></figure><h2 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h2><ul><li><p>边界布局 BorderLayout</p><ul><li><strong>BorderLayout是容器JFrame和JApplet的默认布局方式**</strong></li><li>将容器分成五个区域，NORTH(顶部)，SOUTH(底部)，WEST (左侧)，EAST(右侧)，CENTER(中间)，每个区域最多只能1个组件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">add(<span class="hljs-keyword">new</span> Button(<span class="hljs-string">&quot;South&quot;</span>), BorderLayout.SOUTH); <br>add(<span class="hljs-keyword">new</span> Button(<span class="hljs-string">&quot;South&quot;</span>),<span class="hljs-string">&quot;South&quot;</span>);<br>add(<span class="hljs-string">&quot;South&quot;</span>,<span class="hljs-keyword">new</span> Button(<span class="hljs-string">&quot;South&quot;</span>));<br><br>BorderLayout() <br><span class="hljs-comment">//构造一个组件之间没有间距的新边界布局。 </span><br>BorderLayout(<span class="hljs-keyword">int</span> hgap, <span class="hljs-keyword">int</span> vgap) <br><span class="hljs-comment">//用指定的组件之间的水平间距构造一个边界布局。</span><br></code></pre></td></tr></table></figure></li><li><p>顺序布局 FlowLayout</p><ul><li><strong>FlowLayout面板Panel和它的子类Applet的默认布局方式</strong></li><li>将组件从左到右依次排列，一行排满就转到下一行继续排列，直到所有的组件都排列完毕。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Frame f=<span class="hljs-keyword">new</span> Frame();<br>f.setLayout(<span class="hljs-keyword">new</span> FlowLayout());<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FlowLayout</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//创建一个新的FlowLayout，其默认值是居中对齐，默认组件彼此有5单位的水平与垂直间距。</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FlowLayout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> align)</span></span><br><span class="hljs-function"><span class="hljs-comment">//创建一个新的FlowLayout，此FlowLayout可以设置对齐（align）方式，对齐必须是LEFT、CENTER或RIGHT之一。默认组件彼此有5单位的水平与垂直间距。</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FlowLayout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> align,<span class="hljs-keyword">int</span> hgap,<span class="hljs-keyword">int</span> vgap)</span></span><br><span class="hljs-function"><span class="hljs-comment">//创建一个新的FlowLayout，可以自己设置对齐方式、水平间隔和垂直间隔。</span></span><br></code></pre></td></tr></table></figure></li><li><p>网格布局 GridLayout</p><ul><li>网格布局比顺序布局多了行和列的设置，也就是说要先设置网格布局共有几行几列。然后加进去的组件会先填完第一行格子，然后再从第二行开始填，依此类推，就像是一个个的格子一般。而且网格布局会将填进去的组件大小设为一样。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GridLayout</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GridLayout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rows,<span class="hljs-keyword">int</span> cols)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GridLayout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rows,<span class="hljs-keyword">int</span> cols,<span class="hljs-keyword">int</span> hgap,<span class="hljs-keyword">int</span> vgap)</span></span><br></code></pre></td></tr></table></figure></li></ul><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ul><li><p>事件源：事件源是一个事件的产生者。各种图形组件都可以作为事件源</p></li><li><p>事件对象</p><ul><li>图形组件产生的事件</li><li>一个事件对象包含了以下信息：id——事件的类型。如按键事件、单击鼠标事件等。target——发生事件的对象。when——指出事件发生的时间。x, y——发生事件的坐标。key——键盘事件中被按下的键。arg——一个与事件相关的参数。modifier——修饰键的状态(即Alt,Ctrl键的状态)</li><li>主要的事件对象<ul><li>ComponentEvent（ 组件事件：组件尺寸的变化，移动） </li><li>ContainerEvent（ 容器事件：组件增加，移动） </li><li>WindowEvent（ 窗口事件：关闭窗口，窗口闭合，图标化） </li><li>FocusEvent（ 焦点事件：焦点的获得和丢失） </li><li>KeyEvent（ 键盘事件：键按下、释放） </li><li><strong>MouseEvent</strong>（ 鼠标事件：鼠标单击，移动）</li><li>ActionEvent（动作事件：按钮按下，TextField中按Enter键） </li><li>TextEvent（文本事件：文本对象改变）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">KeyListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EventListener</span> </span><br><span class="hljs-class"></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">keyPressed</span><span class="hljs-params">(KeyEvent ev)</span></span>; …&#125;<br></code></pre></td></tr></table></figure></li><li><p>事件监听器</p><ul><li>事件监听器就是一个接收事件、解释事件并处理用户交互的方法。事件产生以后，不是由事件源或者其容器对象处理事件，而是将事件委托给事件监听器来处理。监听器包含事件处理程序。</li><li>事件源和监听器对象通过注册的方式建立关联。当事件源发生事件时，事件监听者就代替事件源对事件进行处理。</li><li>每类事件都有对应的事件监听器，监听器是接口，根据动作来定义方法。 </li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">事件监听器</th><th style="text-align:center">事件响应函数</th></tr></thead><tbody><tr><td style="text-align:center"><strong>MouseListener</strong></td><td style="text-align:center"><strong>mouseClicked/mouseEntered  /mouseExited/mousePressed/</strong></td></tr><tr><td style="text-align:center">MouseMotionListener</td><td style="text-align:center">mouseMoved/mouseDragged</td></tr><tr><td style="text-align:center">WindowListener</td><td style="text-align:center">windowOpened/windowClosing</td></tr><tr><td style="text-align:center">ActionListener</td><td style="text-align:center">actionPerformed</td></tr></tbody></table></div><ul><li><p><strong>事件的处理方法流程</strong></p><ul><li><strong>明确事件源是什么，也就是什么组件要被处理。</strong></li><li><strong>明确什么样的事件要被处理。</strong></li><li><strong>在事件监听器的相应事件响应函数中实现自己的功能。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">import</span> java.awt.event.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String []args)</span> </span>&#123;<br>        Frame f=<span class="hljs-keyword">new</span> Frame(<span class="hljs-string">&quot;我的第一个窗口&quot;</span>);<br>        f.setSize(<span class="hljs-number">400</span>,<span class="hljs-number">300</span>);<br>        f.setLayout(<span class="hljs-keyword">null</span>);<br>        f.addWindowListener(<span class="hljs-keyword">new</span> MyWindowAdapter()); <br>        f.setVisible(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//创建窗口后要调用setVisible(true)才能显示出来</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWindowAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WindowAdapter</span></span><br><span class="hljs-class"></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">windowClosing</span><span class="hljs-params">(WindowEvent e)</span></span><br><span class="hljs-function"></span>&#123;System.exit(<span class="hljs-number">0</span>);&#125;&#125;<br><br><span class="hljs-comment">//创建了一个匿名内部类对象</span><br><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">import</span> java.awt.event.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String []args)</span> </span>&#123;<br>        Frame f=<span class="hljs-keyword">new</span> Frame(<span class="hljs-string">&quot;我的第一个窗口&quot;</span>);<br>        f.setSize(<span class="hljs-number">400</span>,<span class="hljs-number">300</span>);<br>        f.setLayout(<span class="hljs-keyword">null</span>);<br>        f.addWindowListener(<span class="hljs-keyword">new</span> WindowAdapter() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">windowClosing</span><span class="hljs-params">(WindowEvent e)</span> </span>&#123;<br>                System.exit(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;);<br>        f.setVisible(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//创建窗口后要调用setVisible(true)才能显示出来</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//按钮上响应点击鼠标事件（MouseClicked）为例</span><br>JButton jButton1 = <span class="hljs-keyword">new</span> JButton();<br>jButton1.addMouseListener(<span class="hljs-keyword">new</span> MymouseAdapter());<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MymouseAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MouseAdapter</span> </span><br><span class="hljs-class"></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mouseClicked</span><span class="hljs-params">(MouseEvent e)</span> </span>&#123;……&#125;&#125;<br><span class="hljs-comment">//或者匿名内部类</span><br>frame.add(jButton1);<br><span class="hljs-comment">//元件要 add()</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="字体、颜色外观"><a href="#字体、颜色外观" class="headerlink" title="字体、颜色外观"></a>字体、颜色外观</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//颜色和字体setBackground, setForeground, setFont</span><br><span class="hljs-comment">//位置和大小setBounds, setLocation, setSize</span><br><span class="hljs-keyword">import</span> java.awt.*; <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">static</span> Font ff=<span class="hljs-keyword">new</span> Font(<span class="hljs-string">&quot;黑体&quot;</span>, Font.ITALIC, <span class="hljs-number">30</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span><br><span class="hljs-function">    </span>&#123;<br>        Frame f=<span class="hljs-keyword">new</span> Frame();<br>        f.setLayout(<span class="hljs-keyword">new</span> FlowLayout());<br>        Button b1=<span class="hljs-keyword">new</span> Button(<span class="hljs-string">&quot;B1&quot;</span>);<br>        Button b2=<span class="hljs-keyword">new</span> Button(<span class="hljs-string">&quot;B2&quot;</span>);<br>        b2.setBackground(Color.blue);<br>        b2.setForeground(<span class="hljs-keyword">new</span> Color(<span class="hljs-number">200</span>,<span class="hljs-number">100</span>,<span class="hljs-number">0</span>));<span class="hljs-comment">//红   </span><br>        b2.setFont(ff);<br>        b1.setBounds(<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">60</span>,<span class="hljs-number">20</span>);<br>   b2.setLocation(<span class="hljs-number">100</span>,<span class="hljs-number">40</span>);   <br>   b2.setSize(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>);<br>        f.add(b1);<br>        f.add(b2);<br>        f.setSize(<span class="hljs-number">180</span>,<span class="hljs-number">100</span>);<br>        f.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图形绘制"><a href="#图形绘制" class="headerlink" title="图形绘制"></a>图形绘制</h2><ul><li><p>要绘制图形，必须具备两个要素：画布和画笔</p></li><li><p>Swing中任何JComponent类的子类都可以充当画布的角色，任何java.awt.Component类的子类都可以作为画布</p></li><li><p>所有swing控件都有一个paint方法，负责在需要的时候对控件进行绘制，<strong>一定要在绘制的时候覆盖</strong> <code>public void paint (Graphics g)</code></p></li><li><p>paint方法中的参数g就是画笔，paint方法是自动调用的，当第一次显示组件或改变组件的大小需要重新画组件的界面时，该方法都会由系统自动调用</p></li><li><p>实际开发中，通常都是采用继承JComponent或JPanel类并重写paint的方式来获得画布和画笔的，然后加到顶层容器中；也可以直接重写窗口Frame类的paint方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JComponent</span> </span>&#123;    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">paint</span> <span class="hljs-params">(Graphics g)</span> </span>&#123;<br>    g.setColor(Color.BLACK);<br>    g.drawString(str,x,y);<br>    g.drawOval(x,y,w,h);<br>    g.fiilOval(x,y,w,h); <br>    g.drawRect(x,y,w,h);<br>    g.fillRect(x,y,w,h);<br>    g.drawLine(x1,y1,x2,y2);<br>    g.drawArc(x,y,w,h,startAngle,arcAngle);<br>    &#125;<br>&#125;        <br>MyComponent m=<span class="hljs-keyword">new</span> MyComponet();<br>add(m);<br></code></pre></td></tr></table></figure></li><li><p>Graphics对象的获取总共有两种方法</p><ul><li>通过paint方法接收的参数来获得对象，paint方法是由系统调用的，调用时系统会将需要的Graphics对象引用传给该方法。然后在paint方法中收到这个参数就可以在指定的画布上画画了</li><li>通过相应的getGraphics方法来获得Graphics对象，所有Component类子类对象都有这个方法，但对于控件一般不应该使用此方法获取画笔，而是通过第一种</li></ul></li><li><p>坐标系统：绘制图形采用的是笛卡尔坐标系统，该坐标都是以像素为单位。画布上左上角为该坐标的原点（0,0）位置，x轴向右延伸，y轴向下延伸</p></li><li><p>定位：在一个画布上定位某个图形时，是通过图形的最左上的定位进行的</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//按钮，一会画笑脸，一会画哭脸</span><br><span class="hljs-comment">//drawArc （x y 宽 高 起始角 转角）（逆时针，0向右）</span><br><span class="hljs-keyword">import</span> javax.swing.*;<br><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">import</span> java.awt.event.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmileSad</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Frame</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> smile;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">paint</span><span class="hljs-params">(Graphics g)</span> </span>&#123;<br>        g.setColor(Color.blue);<br>        g.drawOval(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">80</span>,<span class="hljs-number">100</span>);<br>        g.fillOval(<span class="hljs-number">70</span>,<span class="hljs-number">80</span>,<span class="hljs-number">14</span>,<span class="hljs-number">7</span>);<br>        g.fillOval(<span class="hljs-number">110</span>,<span class="hljs-number">80</span>,<span class="hljs-number">14</span>,<span class="hljs-number">7</span>);<br>        <span class="hljs-keyword">if</span> (smile) &#123;<br>            g.drawArc(<span class="hljs-number">70</span>,<span class="hljs-number">110</span>,<span class="hljs-number">40</span>,<span class="hljs-number">20</span>,<span class="hljs-number">180</span>,<span class="hljs-number">180</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            g.drawArc(<span class="hljs-number">70</span>,<span class="hljs-number">110</span>,<span class="hljs-number">40</span>,<span class="hljs-number">20</span>,<span class="hljs-number">0</span>,<span class="hljs-number">180</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SmileSad f=<span class="hljs-keyword">new</span> SmileSad();<br>        f.setLayout(<span class="hljs-keyword">null</span>);<br>        f.setTitle(<span class="hljs-string">&quot;SmileSad&quot;</span>);<br>        f.setSize(<span class="hljs-number">250</span>,<span class="hljs-number">200</span>);<br>        JButton btn = <span class="hljs-keyword">new</span> JButton(<span class="hljs-string">&quot;trans&quot;</span>);<br>        btn.setBounds(<span class="hljs-number">130</span>,<span class="hljs-number">130</span>,<span class="hljs-number">100</span>,<span class="hljs-number">20</span>);<br>        btn.addMouseListener(<span class="hljs-keyword">new</span> MouseAdapter() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mouseClicked</span><span class="hljs-params">(MouseEvent e)</span> </span>&#123;<br>                smile = !smile;<br>                f.repaint();<br>            &#125;<br>        &#125;);<br>        f.add(btn);<br>        f.setVisible(<span class="hljs-keyword">true</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//动画：1秒rect，1秒circle</span><br><span class="hljs-keyword">import</span> javax.swing.*;<br><span class="hljs-keyword">import</span> java.awt.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RectCircle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JFrame</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> b = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RectCircle</span><span class="hljs-params">()</span> </span>&#123;<br>        setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">200</span>);<br>        setTitle(<span class="hljs-string">&quot;RectCircle&quot;</span>);<br>        setVisible(<span class="hljs-keyword">true</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">paint</span><span class="hljs-params">(Graphics g)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.paint(g);<br>        g.setColor(Color.red);<br>        <span class="hljs-keyword">if</span> (b) g.drawRect(<span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">else</span> g.drawOval(<span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">150</span>, <span class="hljs-number">100</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                b = !b;<br>                repaint();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            System.out.println(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> RectCircle());<br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul><li>程序：一段静态的代码，应用程序执行的蓝本。</li><li>进程：程序的一次动态执行过程。</li><li>线程：程序内部的控制流，比进程更小的执行单位。一个进程在执行过程中，为了同时完成多个操作，可以产生多个线程，形成多条执行线索。</li><li>进程和线程的区别<ul><li>每个进程有一段专有内存空间。进程各自占有不同空间，内存消耗很大，会造成系统在不同程序之间切换时开销很大，进程之间通信速度很慢。</li><li>同一进程的各线程之间共享相同内存空间，利用共享内存来实现数据交换、实时通信及必要的同步工作。线程之间通信速度快，相互切换所占系统资源也小。</li></ul></li><li>线程自身不能够自动运行，必须栖身于某一进程中，由进程触发，每个Java应用程序运行时都对应一个进程——主线程</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li><p>声明一个<code>Thread</code>类的子类，并覆盖 <code>run()</code>方法</p><ul><li>步骤<ul><li>定义一个<code>Thread</code>类的扩展类</li><li>覆盖<code>public void run()</code>方法</li><li>创建对象(用构造方法)</li><li>调用该对象的<code>start()</code>方法，将该线程启动（注意不能直接调用<code>run()</code>方法）, <code>start()</code>方法引起<code>run</code>的调用</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编写一个简单的程序，要求它按两个不同的时间间隔（1秒和3秒）在屏幕上连续显示当前时间</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimePrinter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> pauseTime;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TimePrinter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, String n)</span> </span>&#123;<br>        pauseTime = x;<br>        name = n;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(name + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-keyword">new</span> Date(System.currentTimeMillis()));<br>                Thread.sleep(pauseTime);<br>            &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>                System.out.println(e);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        TimePrinter tp1 = <br>            <span class="hljs-keyword">new</span> TimePrinter(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;Fast Guy&quot;</span>);<br>        tp1.start();<br>        TimePrinter tp2 = <br>            <span class="hljs-keyword">new</span> TimePrinter(<span class="hljs-number">3000</span>, <span class="hljs-string">&quot;Slow Guy&quot;</span>);<br>        tp2.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//编写一个窗体，Applet窗体宽300，高100，布局管理器为null，窗体上有一个标签和一个按钮，标签的位置是（10,20），按钮的位置是（100,60），它们的宽度和高度都是80和20。 再编写一个线程，该线程可以让标签向右移动10次，每次移动10个单位，间隔1秒，通过按钮的动作事件启动上述线程。</span><br><span class="hljs-keyword">import</span> javax.swing.*;<br><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">import</span> java.awt.event.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">moveThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    JLabel lb;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">moveThread</span><span class="hljs-params">(JLabel lb)</span> </span>&#123;<span class="hljs-keyword">this</span>.lb=lb;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                lb.setBounds(lb.getX()+<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">80</span>,<span class="hljs-number">20</span>);<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span>(InterruptedException ie) &#123;ie.printStackTrace();&#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        JFrame f = <span class="hljs-keyword">new</span> JFrame();<br>        f.setSize(<span class="hljs-number">300</span>,<span class="hljs-number">100</span>);<br>        f.setLayout(<span class="hljs-keyword">null</span>);<br>        JLabel lb = <span class="hljs-keyword">new</span> JLabel(<span class="hljs-string">&quot;向右移标签&quot;</span>);<br>        lb.setBounds(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">80</span>,<span class="hljs-number">20</span>);<br>        f.add(lb);<br>        JButton btn = <span class="hljs-keyword">new</span> JButton(<span class="hljs-string">&quot;向右走&quot;</span>);<br>        btn.setBounds(<span class="hljs-number">100</span>,<span class="hljs-number">60</span>,<span class="hljs-number">80</span>,<span class="hljs-number">20</span>);<br>        f.add(btn);<br>        moveThread t =<span class="hljs-keyword">new</span> moveThread(lb);<br>        btn.addActionListener(<span class="hljs-keyword">new</span> ActionListener() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span> </span>&#123;t.start();&#125;<br>        &#125;);<br>        f.setVisible(<span class="hljs-keyword">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>声明一个实现 <code>Runnable</code> 接口的类，并实现<code>run()</code>方法</p><ul><li>在创建线程时还是用<code>Thread</code>类创建线程对象，把实现<code>Runnable</code>接口的类的对象作为<code>Thread</code>类的构造方法的参数,再调用<code>Thread</code>类对象的<code>start()</code>方法</li><li>步骤<ul><li>定义一个实现<code>Runnable</code>接口的类</li><li>实现<code>public void run()</code>方法(必须实现)</li><li>将该类的对象作为<code>Thread</code>类构造方法的参数，创建一个线程实例</li><li>调用该对象的<code>start()</code>方法启动线程</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编写一个简单的程序，要求它按两个不同的时间间隔（1秒和3秒）在屏幕上连续显示当前时间</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimePrinter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> pauseTime;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TimePrinter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, String n)</span> </span>&#123;<br>        pauseTime = x;<br>        name = n;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(name + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-keyword">new</span> Date(System.currentTimeMillis()));<br>                Thread.sleep(pauseTime);<br>            &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>                System.out.println(e);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> TimePrinter(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;Fast Guy&quot;</span>));<br>        t1.start();<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> TimePrinter(<span class="hljs-number">3000</span>, <span class="hljs-string">&quot;Slow Guy&quot;</span>));<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>比较</p><ul><li>实现Runnable接口的优势：符合OO设计的思想，便于用extends继承其它类。</li><li>采用继承Thread类方法的优点：程序代码更简单。</li><li>通过Thread实例的start()，一个Thread的实例只能产生一个线程</li><li>Runnable的实例是可运行的，但它自己并不能直接运行，它需要被Thread对象来包装才行运行 ，但同一实例(Runnable实例)可产生多个线程</li></ul></li></ul><h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造</span><br><span class="hljs-comment">//target实际执行线程体的目标对象，它必须实现接口Runnable ，任何实现接口Runnable的对象都可以作为一个线程的目标对象</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(Runnable target)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(String name)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//开始运行当前线程；</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//该方法用来定义线程体。一旦线程被启动执行，就开始执行</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//强制当前线程停止运行，并抛出ThreadDead错误；</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//撤消当前线程；</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAlive</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//测试当前线程是否在活动；</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">suspend</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//临时挂起当前线程；</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resume</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//恢复运行挂起的线程；</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Thread <span class="hljs-title">currentThread</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//返回当前活动线程的引用；</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//调用该方法将CPU让给具有与当前线程相同优先级的线程。如果没有同等优先级的线程是Runnable状态，yield()方法将什么也不做。</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">yield</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//sleep()</span></span><br><span class="hljs-function"><span class="hljs-comment">//该方法用来使一个线程暂停运行一段固定的时间。在线程睡眠时间内，将运行别的线程,线程将进入就绪(Runnable)状态</span></span><br><span class="hljs-function"><span class="hljs-comment">//需要捕获异常IOException</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span></span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function"><span class="hljs-comment">//使当前活动线程睡眠指定的时间millisme;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis,<span class="hljs-keyword">int</span> nanos)</span></span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function"><span class="hljs-comment">//使当前活动线程睡眠指定的时间millisme加上十万分之nanos秒；</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//join()方法使当前的线程等待，直到结束为止，线程恢复到运行状态。</span></span><br><span class="hljs-function"><span class="hljs-comment">//如当前线程发出调用t.join()，则当前线程将等待线程t结束后(最多等待设置的时间)再继续执行</span></span><br><span class="hljs-function"><span class="hljs-title">join</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span></span><br><span class="hljs-function"><span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis,<span class="hljs-keyword">long</span> nanos)</span> </span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-comment">//interrupt()</span></span><br><span class="hljs-function"><span class="hljs-comment">//如果t在调用sleep()、join()、wait()等方法被阻塞时，则该方法将中断t的阻塞状态，并将接收InterruptException。</span></span><br><span class="hljs-function">t.<span class="hljs-title">interrupt</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//优先级控制，优先级高的先被调度</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPriority</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newPriouity)</span>  </span><br><span class="hljs-function"><span class="hljs-comment">//设置线程的优先级，可以在MIN_PRIORITY=1、NORM_PRIORIITY=5和MAX_PRIORITY=10之间</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPriority</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//获得当前线程的优先级</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span><br><span class="hljs-function"><span class="hljs-comment">//设置线程名；</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//得到当前线程名；  </span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-comment">//常用主要方法</span></span><br><span class="hljs-function"><span class="hljs-comment">//启动和停止</span></span><br><span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//等待和通知</span></span><br><span class="hljs-function"><span class="hljs-title">wait</span><span class="hljs-params">()</span>, <span class="hljs-title">notify</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//睡眠</span></span><br><span class="hljs-function"><span class="hljs-title">sleep</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//挂起和恢复</span></span><br><span class="hljs-function"><span class="hljs-title">suspend</span><span class="hljs-params">()</span>, <span class="hljs-title">resume</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">//撤消线程</span></span><br><span class="hljs-function"><span class="hljs-title">destroy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">join</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">yield</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">isAlive</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">setPriority</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"> </span><br><span class="hljs-function"><span class="hljs-comment">//抛出异常</span></span><br><span class="hljs-function">sleep join wait</span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-comment">//静态方法：Thread类中的静态方法表示操作的线程是&quot;正在执行静态方法所在的代码块的线程&quot;，这样就能对CPU当前正在运行的线程进行操作。</span></span><br><span class="hljs-function">currentThread sleep yield interrupt</span><br></code></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li><p>创建状态：当一个线程处于创建状态时，它仅仅是一个空的线程对象，系统不为它分配资源。 </p></li><li><p>可运行状态：当一个线程处于可运行状态时，系统为这个线程分配了它需的系统资源，安排其运行并调用线程运行方法，这样就使得该线程处于可运行( Runnable )状态。这一状态并不是运行中状态（Running )，因为线程也许实际上并未真正运行。单处理器的计算机要在同一时刻运行所有的处于可运行状态的线程是不可能的，Java的运行系统必须实现调度来保证这些线程共享处理器。 </p></li><li><p>不可运行状态</p><p>当下面5种情况发生时，线程就进入不可运行状态:</p><ol><li>调用了<code>sleep()</code>方法；</li><li>调用了<code>suspend()</code>方法；</li><li>为等候一个条件变量，线程调用<code>wait()</code>方法；</li><li>输入输出流中发生线程阻塞。</li><li>线程试图调用另一个对象的同步方法，但那个对象处于对象锁定状态，暂时无法使用</li></ol><p>上面5种情况，要使线程返回可运行状态，各有特定的方法与之对应：<br>1) 如果线程处于睡眠状态中，<code>sleep()</code>方法中的参数为睡眠时间，当这个时间过去后，线程即为可运行的；<br>2) 如果一个线程被挂起，要使该线程重新处于可运行状态，需调用<code>resume()</code>方法；<br>3) 如果线程在等待条件变量，那么要停止等待的话，需要该条件变量的线程对象调用<code>notifyAll()</code>方法；<br>4) 如果在I/O流中发生线程阻塞，则特定的I/O完成后可结束这种不可运行状态。<br>5) 同步的方法完成，释放了同步锁</p></li><li><p>死亡状态</p><ul><li>自然撤消</li><li>调用<code>stop()</code>方法停止当前线程 </li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/08/tEvKjzdAL26nYqf.png" alt="image-20220108113753735" style="zoom: 33%;" /></p><h2 id="同步互斥"><a href="#同步互斥" class="headerlink" title="同步互斥"></a>同步互斥</h2><ul><li>把一个方法声明为<code>synchronized</code>有效地防止冲突.调用任何synchronized方法时，对象就会被锁定，不可调用那个对象的其他任何synchronized方法。　　　</li><li>wait:导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法，该方法是会释放锁的。</li><li>notify：唤醒正在等待对象监视器的单个线程。 如果任何线程正在等待这个对象，其中一个被选择被唤醒。</li><li>wait和notify（notifyAll）必须配合synchronized使用，而且wait必须在notify前用，wait后就会进入notify所在的线程，notify后唤醒wait所在的线程，但是wait所在的线程仍然没有获取锁，需要等待notify所在的线程释放锁。</li><li>不但可以把一个方法设定为synchronized，还可以把一段代码设定为同步的，这块代码称作“关键区域”或“同步块”</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//同步堆栈（线程安全堆栈）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncStack</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; <span class="hljs-comment">//堆栈指针初始值为0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> []buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">6</span>];<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span></span>&#123; <span class="hljs-comment">//加上互斥锁</span><br>        <span class="hljs-keyword">while</span>(index == buffer.length)&#123; <br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">this</span>.wait(); <span class="hljs-comment">//等待，直到有数据出栈</span><br>            &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;&#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.notify(); <span class="hljs-comment">//通知其它线程把数据出栈</span><br>        buffer[index] = c;<br>        index++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">char</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//加上互斥锁 </span><br>        <span class="hljs-keyword">while</span>(index ==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">this</span>.wait(); <span class="hljs-comment">//等待其它线程把数据入栈</span><br>            &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;&#125;<br>        &#125; <br>        <span class="hljs-keyword">this</span>.notify(); <span class="hljs-comment">//通知其它线程入栈 </span><br>        index--; <br>        <span class="hljs-keyword">return</span> buffer[index];<br>    &#125;<br>    <span class="hljs-comment">/***main***/</span><br>&#125; <br><br><span class="hljs-comment">//设计两个线程，其中一个线程IncThread，工作流程为循环10次，每次对共享变量J增加1（函数为inc()），另外一个线程DecThread，工作流程为循环10次，每次对共享变量J减少1(函数为dec())，在主程序中启动两个线程进行并发执行。在改写数据过程中利用同步机制保障数据的一致性。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">data</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span></span>&#123;j++;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dec</span><span class="hljs-params">()</span></span>&#123;j--;&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IncThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    data d;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IncThread</span><span class="hljs-params">(data dtemp)</span></span>&#123; d=dtemp;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) d.inc();&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    data d;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecThread</span><span class="hljs-params">(data dtemp)</span></span>&#123;d=dtemp;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) d.dec();&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span> </span>&#123;<br>        data d = <span class="hljs-keyword">new</span> data();<br>        IncThread Inc = <span class="hljs-keyword">new</span> IncThread(d);<br>        DecThread Dec = <span class="hljs-keyword">new</span> DecThread(d);<br>        Inc.start();<br>        Dec.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><ul><li><p>通过构造方法传递数据</p><p>在创建线程对象的同时传递数据，在线程运行之前这数据就已经到位了，不会造成数据在线程运行后才传入的现象。使用构造方法来传递数据虽然比较安全，但如果要传递的数据比较多时，就会造成很多不便。由于Java没有默认参数，要想实现类似默认参数的效果，就得使用重载，这样不但使构造方法本身过于复杂，又会使构造方法在数量上大增。</p></li><li><p>通过变量和方法传递数据</p><p>在类中定义一系列的public的方法或变量。然后在建立完对象后，通过对象实例逐个赋值。例如使用了一个setName方法来设置name变量</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">this</span>.name = <span class="hljs-string">&quot;unknown&quot;</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;hello &quot;</span> + name);&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        MyThread myt1 = <span class="hljs-keyword">new</span> MyThread();<br>        myt1.setName(<span class="hljs-string">&quot;001&quot;</span>);<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(myt1);<br>        t1.start();<br>        MyThread myt2 = <span class="hljs-keyword">new</span> MyThread(<span class="hljs-string">&quot;002&quot;</span>);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(myt2);<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>通过回调函数传递数据</p><p>上面讨论的两种向线程中传递数据的方法是最常用的。但这两种方法都是main方法中主动将数据传入线程类的。这对于线程来说，是被动接收这些数据的。然而，在有些应用中需要在线程运行的过程中动态地获取数据，如在下面代码的run方法中产生了3个随机数，然后通过Work类的process方法求这三个随机数的和，并通过Data类的value将结果返回。从这个例子可以看出，在返回value之前，必须要得到三个随机数。也就是说，这个value是无法事先就传入线程类的。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Work</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : nums) &#123;value += n;&#125;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> value;&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">demoThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Work work;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">demoThread</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">this</span>.work = <span class="hljs-keyword">new</span> Work();&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (count &lt;= <span class="hljs-number">5</span>) &#123;<br>                java.util.Random random = <span class="hljs-keyword">new</span> java.util.Random();<br>                <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>                nums[<span class="hljs-number">0</span>] = random.nextInt(<span class="hljs-number">10</span>);<br>                nums[<span class="hljs-number">1</span>] = random.nextInt(<span class="hljs-number">20</span>);<br>                work.process(nums);   <span class="hljs-comment">// 使用回调函数</span><br>                System.out.println(<span class="hljs-string">&quot;&lt;&quot;</span> + count + <span class="hljs-string">&quot;&gt; &quot;</span> + nums[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;+&quot;</span> + nums[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;==&quot;</span> + work.getValue());<br>                count++;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        Thread thread = <span class="hljs-keyword">new</span> demoThread();<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>建立数据源</li><li>加载驱动程序：Class类的forName方法，将驱动程序类加载到JVM中</li><li>获得连接对象：使用DriverManager类的静态方法getConnection来获得连接对象</li><li>创建语句对象：通过Connection对象的createStatement方法来创建语句对象，才可以执行SQL语句；</li><li>执行SQL语句：使用语句对象来执行SQL语句，有两种情况：<ul><li>一种是执行DELETE、UPDATE和INSERT之类的数据库操作语句（DML），这样的语句没有数据结果返回，使用Statement对象的executeUpdate方法执行；</li><li>另一种是执行SELECT这样的数据查询语句（DQL），这样的语句将从数据库中获得所需的数据，使用Statement对象的executeQuery 方法执行；</li></ul></li><li>关闭资源：当对数据库的操作结束后，应当将所有已经被打开的资源关闭，否则将会造成资源泄漏；Connection对象、Statement对象和ResultSet对象都有执行关闭的close方法；有可能抛出SQLException异常，必须捕捉；请注意关闭的顺序，最后打开的资源最先关闭，最先打开的资源最后关闭。</li></ul><p><img src="https://s2.loli.net/2022/01/08/rWvHKBC3d8VReYq.png" style="zoom: 50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.sql.*;    <span class="hljs-comment">//导入java.sql包</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCDemo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String strCon = <span class="hljs-string">&quot;jdbc:odbc:myODBC&quot;</span>;  <span class="hljs-comment">//连接字符串</span><br>    String strUser = <span class="hljs-string">&quot;sa&quot;</span>;               <span class="hljs-comment">//数据库用户名</span><br>    String strPwd = <span class="hljs-string">&quot;&quot;</span>;                  <span class="hljs-comment">//口令</span><br>    System.out.println(<span class="hljs-string">&quot;正在连接数据库...&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;  <span class="hljs-comment">//监控异常</span><br>      Class.forName(<span class="hljs-string">&quot;sun.jdbc.odbc.JdbcOdbcDriver&quot;</span>);  <span class="hljs-comment">//加载驱动程序</span><br>      Connection con = DriverManager.getConnection(strCon, strUser, strPwd);<br>      <span class="hljs-comment">//获得连接对象</span><br>      System.out.println(<span class="hljs-string">&quot;成功连接到数据库。&quot;</span>);<br>      Statement sta = con.createStatement();    <span class="hljs-comment">//创建语句对象</span><br>      <span class="hljs-comment">//执行SQL语句</span><br>      String strSql = <span class="hljs-string">&quot;DELETE FROM Friends WHERE [Name] = &#x27;郑六&#x27;&quot;</span>;<br>      <span class="hljs-keyword">int</span> count = sta.executeUpdate(strSql);<br>      System.out.println(<span class="hljs-string">&quot;成功删除&quot;</span> + count + <span class="hljs-string">&quot;行数据。&quot;</span>);<br>      sta.close();<br>      con.close();    <br>      <span class="hljs-comment">//关闭所有已经打开的资源</span><br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException cnfe) &#123; cnfe.printStackTrace(); &#125;<br>    <span class="hljs-keyword">catch</span> (SQLException sqle) &#123; sqle.printStackTrace(); &#125; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="操作结果集"><a href="#操作结果集" class="headerlink" title="操作结果集"></a>操作结果集</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>  String strCon = <span class="hljs-string">&quot;jdbc:odbc:MyODBC&quot;</span>;<br>  System.out.println(<span class="hljs-string">&quot;正在连接数据库...&quot;</span>);<br>  Class.forName(<span class="hljs-string">&quot;sun.jdbc.odbc.JdbcOdbcDriver&quot;</span>);<br>  Connection con;<br>  con = DriverManager.getConnection(strCon, <span class="hljs-string">&quot;sa&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>  System.out.println(<span class="hljs-string">&quot;成功连接到数据库。&quot;</span>);<br>  Statement sta = con.createStatement();<br>  ResultSet rs = sta.executeQuery(<span class="hljs-string">&quot;SELECT * FROM Friends&quot;</span>);<br>  System.out.println(<span class="hljs-string">&quot;查询到数据如下：&quot;</span>);<br>  <span class="hljs-keyword">while</span> (rs.next()) &#123;        <span class="hljs-comment">//循环将结果集游标往下移动，到达末尾返回false</span><br>    <span class="hljs-comment">//根据字段名称获得各个字段的值</span><br>    System.out.print(rs.getString(<span class="hljs-string">&quot;Name&quot;</span>) + <span class="hljs-string">&quot;\t&quot;</span>);     <span class="hljs-comment">//获得字符串</span><br>    System.out.print(rs.getString(<span class="hljs-string">&quot;Address&quot;</span>) + <span class="hljs-string">&quot;\t&quot;</span>);  <span class="hljs-comment">//获得字符串</span><br>    System.out.print(rs.getInt(<span class="hljs-string">&quot;Telephone&quot;</span>) + <span class="hljs-string">&quot;\t&quot;</span>);   <span class="hljs-comment">//获得整数</span><br>    System.out.print(rs.getDate(<span class="hljs-string">&quot;HireDate&quot;</span>) + <span class="hljs-string">&quot;\t&quot;</span>);   <span class="hljs-comment">//获得日期型数据</span><br>    System.out.println(rs.getFloat(<span class="hljs-string">&quot;Salary&quot;</span>));         <span class="hljs-comment">//获得浮点型数据</span><br>  &#125;<br>     rs.close();<br>    sta.close();<br>    con.close();<br>&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException cnfe) &#123; cnfe.printStackTrace(); &#125;<br>  <span class="hljs-keyword">catch</span> (SQLException sqle) &#123; sqle.printStackTrace(); &#125;<br></code></pre></td></tr></table></figure><h2 id="PreparedStatement接口"><a href="#PreparedStatement接口" class="headerlink" title="PreparedStatement接口"></a>PreparedStatement接口</h2><ul><li>如果要多次执行相似的SQL语句，可以使用PreparedStatemend（预编译语句对象）对象来执行；</li><li>通过Connection对象的prepareStatement方法来创建预编译语句对象；</li><li>PreparedStatement对象会将SQL语句预先编译，这样将会获得比Statement对象更高的执行效率</li><li>索引从1开始</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">String strCon = <span class="hljs-string">&quot;jdbc:odbc:MyODBC&quot;</span>;<br>System.out.println(<span class="hljs-string">&quot;正在连接数据库...&quot;</span>);<br>Class.forName(<span class="hljs-string">&quot;sun.jdbc.odbc.JdbcOdbcDriver&quot;</span>);<br>Connection con = DriverManager.getConnection(strCon, <span class="hljs-string">&quot;sa&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;成功连接到数据库。&quot;</span>);<br><br>PreparedStatement ps = con.prepareStatement(<span class="hljs-string">&quot;UPDATE Friends SET Address = ? WHERE Name = ?&quot;</span>);<br><span class="hljs-comment">//使用带参数的SQL语句创建PreparedStatement对象</span><br><span class="hljs-comment">//设置SQL语句中的参数值</span><br><br>ps.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;长沙&quot;</span>);<br>ps.setString(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;王五&quot;</span>);<br><span class="hljs-keyword">int</span> count = ps.executeUpdate();     <span class="hljs-comment">//执行命令</span><br>System.out.println(<span class="hljs-string">&quot;成功更新了&quot;</span> + count + <span class="hljs-string">&quot;行数据。&quot;</span>);   <br>ps.close();    <span class="hljs-comment">//关闭资源</span><br>con.close();<br></code></pre></td></tr></table></figure><h2 id="纯Java驱动连接MySQL"><a href="#纯Java驱动连接MySQL" class="headerlink" title="纯Java驱动连接MySQL"></a>纯Java驱动连接MySQL</h2><ul><li><p>使用纯Java驱动连接到MySQL 5.0数据库，加载驱动程序应改成如下语句<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></p></li><li><p>连接字符串应如下格式：<br><code>&quot;jdbc:mysql://服务器名或IP:3306/数据库名&quot;</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Connection con = <br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DriverManager</span>.</span></span>getConnection<br>(<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/test&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>); <br></code></pre></td></tr></table></figure></li></ul><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><ul><li>协议：网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。它的三要素是：语法、语义、时序。</li><li>TCP/IP四层：数据链路层 、网络层、传输层、应用层</li><li>套接口编程：利用传输层（TCP或UDP）实现网络进程通信的编程，这是所有应用开发的基础</li><li>Socket：传输层提供的网络进程通信接口; 进程之间的通信的抽象连接点; 用于表达两台机器间一个连接的终端</li><li>java.net包提供的类Socket类、ServerSocket类</li></ul><h2 id="基于TCP的Socket通讯实现"><a href="#基于TCP的Socket通讯实现" class="headerlink" title="基于TCP的Socket通讯实现"></a>基于TCP的Socket通讯实现</h2><ul><li><p>TCP是一种可靠的、基于连接的网络协议，当两个网络进程准备基于TCP通信时，都必须首先建立各自的一个套接口：服务器建立套接口后，侦听来自网络的客户连接请求；客户通过套接口，指定服务器的IP地址和端口号，便可与服务器进行通信</p></li><li><p><strong>具体实现过程</strong></p><ul><li>服务器：一直运行，不断监听客户端的连接<ul><li>创建ServerSocket对象，指定服务器监听的端口号；</li><li>调用以上建立服务器套接口对象的accept方法等待客户的连接；</li><li>一旦有客户送来正确请求，就连接到端口，accept方法返回一个新的套接口对象（Socket类对象）；</li><li>获取该返回对象绑定的输入输出流对象，实现和客户的通信</li></ul></li><li>客户：主动发起连接的一方<ul><li>创建一个Socket类对象，指定所要连接服务器的IP地址和端口（服务器接受连接，该对象就建立）；</li><li>获得该Socket对象绑定的输入输出流，实现和服务器的通信</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/08/rvZ7MAW61uXmf5K.png" style="zoom: 50%;" /></p></li></ul><h2 id="基于UDP的Socket通讯实现"><a href="#基于UDP的Socket通讯实现" class="headerlink" title="基于UDP的Socket通讯实现"></a>基于UDP的Socket通讯实现</h2><ul><li>通信前不需要预先建立连接，速度快，可靠性差；每次发送的数据独立路由，都需要加上对方的IP地址和端口．</li><li>支持UDP的两个主要类：DatagramSocket, DatagramPacket</li></ul><h1 id="考前教育"><a href="#考前教育" class="headerlink" title="考前教育"></a>考前教育</h1><h2 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h2><h3 id="某学长"><a href="#某学长" class="headerlink" title="某学长"></a>某学长</h3><p><a href="https://comydream.github.io/2019/01/04/java-review/">《Java语言及网络编程》复习笔记 | ComyDream Studio</a></p><h3 id="同班同学"><a href="#同班同学" class="headerlink" title="同班同学"></a>同班同学</h3><ul><li>程序填空，根据一段描述写代码，根据界面写代码</li><li>一段代码问你输出结果（主要考察参数传递，构造函数调用顺序，类型转换）</li><li>指出代码中的错误（权限修饰符，super关键字）</li><li><strong>简述内部类，匿名内部类设计的好处</strong>（内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据；内部类可以对同一个包中的其他类隐藏起来；使用匿名内部类定义回调函数，节省代码）</li><li>线程安全的栈或队列（synchronized关键字），见上</li><li>输入字符串进行截取，替换等操作（java.io和java.lang.String，另外凡涉及IO都应当进行异常处理）</li><li>按要求存放元素（java.util.Vector , java.util.List，Java.util.Map）</li></ul><h3 id="讲师xwp"><a href="#讲师xwp" class="headerlink" title="讲师xwp"></a>讲师xwp</h3><p><a href="https://wanpengxu.github.io/2022/01/09/JAVA-Open-EXAM-Study/">JAVA Open EXAM Study - 须臾所学之野 (wanpengxu.github.io)</a></p><h3 id="信安老师"><a href="#信安老师" class="headerlink" title="信安老师"></a>信安老师</h3><p>（强调）开发环境的配置，环境变量、系统变量有哪些，它的作⽤是什么。 开发流程要知道，哪些是⽤来做编译的，哪些是⽤来启动虚拟机的，源⽂件的后缀是什么（.java）中 间字节码的后缀（.class）编译过程中我们的邮件命名，编译完成后会出现⼏个class⽂件</p><p>贯穿试卷 （⽤户）标识符命名规则 基本数据类型（数据转换） 作⽤域，初始化（⾯向对象中，声明的位置不⼀样，由谁初始化也不⼀样，在成员变量⾥，由编译器 来初始化，在形参⾥⽤形参初始化，局部变量和布尔变量由⽤户⾃⼰初始化），初始化数组(基本类型 数组初始化是基本类型的值；对象类型在数组⾥初始化的值是null,需要初始化对象来调⽤。) 运算符要知道优先级 参数传递（重点）（⽅法定义⾥必考，要知道 穿传⼀个基本数据类型，它的结果是什么样的，传⼀个 引⽤类型结果是什么样的。引⽤类型传到⽅法⾥⾯它的引⽤值可能发⽣变化，它的对象引⽤，指向性 的对象和不指向性的对象它⾥⾯的变化情况是什么）</p><p>⼤部分题都在这章 访问权限修饰符和⾮访问权限修饰符在封装时的语法（必考） 访问权限修饰符类⼀级的、成员⼀级的访问权限是不⼀样的。 ⾮访问权限修饰符（final、statick)。 继承多态 单继承 可以实现多接⼝ 向上转型问题 ⽅法调⽤时多态的概念 多态有两种实现机制：覆盖和 重载 继承通过多态实现重载 运⾏时动态链遍机制 覆盖和重载语法规则 ⽅法头⽣成的时候覆盖和重载要求的是什么样 和他的输⼊参数有没有关系 与访 问权限修饰符的关系 对象初始化顺序，成员变量和构造⽅法、对静态变量和静态块、在初始化的过程的顺序（重点） super等关键字的含义是什么，构造⽅法使⽤的规则， 掌握接⼝与抽象类的语法 Lamb表达式不考 匿名内置类实现监听器</p><p>运⾏时出现的问题，异常出现的阶段，分类 异常处理的语法规则 异常出现时有两种处理⽅法</p><p>integer包装类的使⽤⽅法，基本数据类型、字符串之间转换⽤包装类实现 范型（有很少的选择题），注意如何使⽤，使⽤时的问题 I/o 选择题 scanner ⽤法</p><p>图形怎么往⽂件放，布局管理器怎么⽤，常⻅的布局管理器有哪些。 事件处理机制（编程）编写事件监听器，安放在事件源（图⽚ 上来完成某个⼯作</p><p>构造线程的⽅法：两种 定义 线程的6态，状态之间的转换，常⻅的函数⽅法怎么⽤ 线程的同步只⽤掌握synchronized互斥</p><h3 id="计科老师-同学"><a href="#计科老师-同学" class="headerlink" title="计科老师+同学"></a>计科老师+同学</h3><ul><li><strong>java源文件的组成</strong>：类或外部结构，例“class Student{}”；main()方法，也叫做程序的入口；编写的代码，是写在main方法中的。</li><li><p><strong>编译后出现几个字节码</strong>：一个源文件有几个类就能编译出几个class，内部内也会产生</p></li><li><p><strong>main方法的作用</strong></p><ul><li>public：为了保证JVM在任何情况下都可以访问到main方法，就用public修饰</li><li>静态的：可以让JVM调用main方法的时候更加方便，不需要通过对象调用。</li><li>没有返回值。Java不需要main方法向操作系统返回退出信息。如果main方法正常退出，那么Java应用层序的退出代码为0，表示成功的运行了程序。</li><li>main的名称：不能变，是为了JVM能够识别程序运行的起点，main方法可以被重载，重载的main方法不会被执行。main方法作为程序初始线程的起点，任何其他线程均由该线程启动。</li><li>String [] args：是main方法中唯一可以改变的地方。args是arguments的缩写，只是一个变量默认名，习惯性写作它，但是也可以改变的，只要符合命名规则随便你写成什么。其实它是程序运行传入的一个参数组。</li></ul></li><li><code>.java</code>文件可以没公共类，<code>main</code>可以不在公共类里，要有公共类也只能有一个公共类</li><li><p><strong>简单工厂（静态工厂方法）：写一个乐器类，有很多子类是具体乐器，见接口笔记</strong></p></li><li><p>抽象类和接口的使用，抽象类和抽象方法的关系，见笔记</p></li><li>一个复杂对象方法的构造调用顺序，见笔记</li><li>泛型约束容器的类型和与普通数组的区别，见笔记</li><li>util集合类vector，见笔记</li><li>几种基本的布局管理器，面板窗体默认布局管理(BorderLayout是容器JFrame和JApplet的默认布局方式,FlowLayout面板Panel和它的子类Applet的默认布局方式)，还有gridLayout见笔记</li><li>如何安排布局，前景色，背景色（布局f.setLayout(new xxxLayout());颜色和字体setBackground, setForeground, setFont，位置和大小setBounds, setLocation, setSize）</li><li>画图：画字符串\椭圆\弧\矩形，见笔记</li><li>常用组件按钮文本框标签，见笔记</li><li>事件处理，事件源监听器，见笔记</li><li>时间监听器的编写，能有编写处理函数addMouseListener mouseClicked MouseEvent就不要创建action的</li><li>加减乘除计算器</li><li><strong>窗体上的鼠标单击变笑脸哭脸</strong>，见笔记</li><li><strong>用线程调用控制动画一会画椭圆一会画矩形</strong>，见笔记</li><li>实现方法继承thread</li><li>接口runnable</li><li>基本方法，静态方法（currentThread() 、sleep() 、yield()、 interrupt()）</li></ul><h2 id="JavaEE程序设计"><a href="#JavaEE程序设计" class="headerlink" title="JavaEE程序设计"></a>JavaEE程序设计</h2><h3 id="来自老师"><a href="#来自老师" class="headerlink" title="来自老师"></a>来自老师</h3><p><strong>填空题 10个x2分=20</strong></p><p><strong>问答题 5个x6分=30（概念，有延伸、从实现、编译的角度融入自己的思考）</strong></p><p><strong>编程题有基础和高级</strong> </p><p><strong>基础题 2个x10分=20</strong> </p><ul><li><p>不得引入工具 例如队列不用queue </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueTest1</span> </span>&#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;  <br>        <span class="hljs-comment">//测试队列</span><br>        System.out.println(<span class="hljs-string">&quot;测试队列：&quot;</span>);<br>        Queue queue = <span class="hljs-keyword">new</span> Queue();  <br>        queue.in(<span class="hljs-number">1</span>);  <br>        queue.in(<span class="hljs-number">2</span>);  <br>        queue.in(<span class="hljs-number">3</span>);  <br>        System.out.println(queue.out()); <br>        System.out.println(queue.out()); <br>        queue.in(<span class="hljs-number">4</span>);  <br>        System.out.println(queue.out());  <br>        System.out.println(queue.out());  <br>        queue.in(<span class="hljs-number">5</span>);  <br>        System.out.println(queue.out()); <br>    &#125;  <br>&#125;  <br><br><span class="hljs-comment">//使用数组定义一个队列</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span> </span>&#123;  <br>    <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];  <br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">//数组下标</span><br>    <span class="hljs-comment">//入队</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">in</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m)</span></span>&#123;  a[i++] = m;&#125; <br>    <span class="hljs-comment">//出队</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">out</span><span class="hljs-params">()</span></span>&#123;  <br>       <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;  <br>       <span class="hljs-keyword">int</span> temp = a[<span class="hljs-number">1</span>];  <br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;  <br>         a[j-<span class="hljs-number">1</span>] = a[j];  <br>         index++;  <br>       &#125;  <br>       i = index;  <br>       <span class="hljs-keyword">return</span> temp;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>高级题</strong> </p><p>综合 建议写注释 不会也需要搭建整体的框架</p><ul><li><p>USB接口，引线数量做常量，功能数据传递和充电（接口里面写不写public final，数据都是常量）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">USB</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> lineNum = <span class="hljs-number">5</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trans</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">charge</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoteBook</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;computer running ...&quot;</span>);&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useUSB</span> <span class="hljs-params">(USB usb)</span> </span>&#123;<span class="hljs-keyword">if</span> (usb != <span class="hljs-keyword">null</span>) &#123;usb.open();&#125;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mouse</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">USB</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>  </span>&#123;System.out.println(<span class="hljs-string">&quot;mouse running ...&quot;</span>);&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span>  </span>&#123;System.out.println(<span class="hljs-string">&quot;mouseUSB open ...&quot;</span>);&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">trans</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;mouse trans &quot;</span> + lineNum + <span class="hljs-string">&quot; lines&quot;</span>);&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">charge</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;mouse charge&quot;</span>);&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Keyboard</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">USB</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>  </span>&#123;System.out.println(<span class="hljs-string">&quot;keyboard running ...&quot;</span>);&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span>  </span>&#123;System.out.println(<span class="hljs-string">&quot;keyboardUSB open ...&quot;</span>);&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">trans</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;keyboard trans &quot;</span>+ lineNum + <span class="hljs-string">&quot; lines&quot;</span>);&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">charge</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;keyboard connot charge&quot;</span>);&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Battery</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">USB</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>  </span>&#123;System.out.println(<span class="hljs-string">&quot;battery running ...&quot;</span>);&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span>  </span>&#123;System.out.println(<span class="hljs-string">&quot;battery open ...&quot;</span>);&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">trans</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;battery cannot trans&quot;</span>);&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">charge</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;battery charge&quot;</span>);&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">usbDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span> <span class="hljs-params">(String[] arg)</span> </span>&#123;<br>        NoteBook pc = <span class="hljs-keyword">new</span> NoteBook();<br>        pc.run();<br>        Mouse mouse = <span class="hljs-keyword">new</span> Mouse();<br>        pc.useUSB(mouse);<br>        mouse.run();<br>        mouse.trans();<br>        Keyboard keyboard = <span class="hljs-keyword">new</span> Keyboard();<br>        pc.useUSB(keyboard);<br>        keyboard.run();<br>        keyboard.trans();<br>        Battery battery = <span class="hljs-keyword">new</span> Battery();<br>        pc.useUSB(battery);<br>        battery.run();<br>        battery.trans();<br>        battery.charge();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//computer running ...</span><br><span class="hljs-comment">//mouseUSB open ...</span><br><span class="hljs-comment">//mouse running ...</span><br><span class="hljs-comment">//mouse trans 5 lines</span><br><span class="hljs-comment">//keyboardUSB open ...</span><br><span class="hljs-comment">//keyboard running ...</span><br><span class="hljs-comment">//keyboard trans 5 lines</span><br><span class="hljs-comment">//battery open ...</span><br><span class="hljs-comment">//battery running ...</span><br><span class="hljs-comment">//battery cannot trans</span><br><span class="hljs-comment">//battery charge</span><br></code></pre></td></tr></table></figure></li><li><p>抽象类和接口 抽象方法和非抽象方法</p></li><li><strong>参数传参和多线程一起 构造函数</strong></li><li>a继承b继承c， c调用a的函数</li><li>线程同步互斥（协作竞争）是什么，什么时候用</li><li>线程中断的执行方法，如何恢复 yield wait sleep join interrupt</li><li>socket 本机进程通信</li><li>捕获、抛出方式有哪些</li><li>什么是错误</li><li>数据库（url username password） 记得关闭</li><li>为什么要close？</li><li>==（地址）与equal（重写object）</li><li>文件管文件也管目录、绑定与关闭</li><li>I/O流必须会 字节 system.in 字符串 buffer stringbuffer 可变 string不可变</li><li><p>参数基于拷贝 简单类(一致) 复杂类(地址) 原因 （提高数据相应效率，有常量池，降低代价）</p></li><li><p>排序算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">selectSort</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sorting</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] list)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;list.length; i++)&#123;<br>            <span class="hljs-keyword">int</span> min = list[i];<br>            <span class="hljs-keyword">int</span> min_index = i;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>; j&lt;list.length; j++)&#123;<br>                <span class="hljs-keyword">if</span>(list[j] &lt; min)&#123;<br>                    min_index = j;<br>                    min = list[j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">int</span> temp = list[i];<br>            list[i] = list[min_index];<br>            list[min_index] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">bubbleSort</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sorting</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] list)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;list.length-<span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;list.length-<span class="hljs-number">1</span>-i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(list[j] &gt; list[j+<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-keyword">int</span> temp = list[j];<br>                    list[j] = list[j+<span class="hljs-number">1</span>];<br>                    list[j+<span class="hljs-number">1</span>] = temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] q, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) &#123;<span class="hljs-keyword">return</span>;&#125;<br>        <span class="hljs-keyword">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>            <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>            <span class="hljs-keyword">if</span> (i &lt; j) &#123;<span class="hljs-keyword">int</span> t = q[j]; q[j] = q[i]; q[i] = t;&#125;<br>        &#125;<br>        quickSort(q, l, j);<br>        quickSort(q, j + <span class="hljs-number">1</span>, r);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">sort</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">xxxxSort</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; buf.length; i++) &#123;<br>            buf[i] = sc.nextInt();<br>        &#125;<br>        sorting(buf);<br>        <span class="hljs-comment">//quickSort(q, 0, q.length-1);</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j : buf) &#123;System.out.print(j + <span class="hljs-string">&quot; &quot;</span>);&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>CUMT课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《编译技术-2021秋》结课考试小结</title>
    <link href="/2021/12/17/%E3%80%8A%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF-2021%E7%A7%8B%E3%80%8B%E7%BB%93%E8%AF%BE%E8%80%83%E8%AF%95%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/12/17/%E3%80%8A%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF-2021%E7%A7%8B%E3%80%8B%E7%BB%93%E8%AF%BE%E8%80%83%E8%AF%95%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>适用人群：中国矿业大学计算机科学与技术专业学生</p></blockquote><h1 id="2021秋期末真题"><a href="#2021秋期末真题" class="headerlink" title="2021秋期末真题"></a>2021秋期末真题</h1><blockquote><p>题干为个人回忆版本，并对覃航和王唯一提供的版本进行补充，已尽力与原题目描述保持一致。答案来自本人理解，不确保与老师理解完全一致。</p></blockquote><p>1、给出关于货币的自然语言描述：写正则表达式，画有限状态自动机，写代码。（难，考场上老师直接提醒了跳过去，先做后面的题）<br>2、最右推导，说明一个句型是该文法的句型；画出语法树；写出短语，直接短语，句柄。<br>3、LL（1），消除左递归，提取公共左因子，构造分析表。<br>4、LR（1），画出识别活前缀的DFA，构造分析表，说明为什么是LR（1）文法，写出句子的分析过程（考的分析失败！）。<br>5、while do - if then else - 布尔表达式和赋值语句，翻译成三地址代码。<br>6、给出文法和示例，构造翻译模式，写出递归下降子程序。（求嵌套深度，但不是括号的嵌套，L-属性文法。注意这里递归下降子程序是带语义动作的，以及不是所有的大写字母都是非终结符，要看具体问题描述。）</p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>给出关于货币的自然语言描述</p><ol><li>：写正则表达式，画有限状态自动机，写代码。（难，考场上老师直接提醒了跳过去，先做后面的题）</li></ol><blockquote><p>考动态规划-最大子段和。</p><ol><li>结合题目内容描述最大子段和算法即可。</li><li>$O(n)$</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>CUMT课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《算法导论-2021秋》课程小结</title>
    <link href="/2021/12/08/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-2021%E7%A7%8B%E3%80%8B%E7%BB%93%E8%AF%BE%E8%80%83%E8%AF%95%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/12/08/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-2021%E7%A7%8B%E3%80%8B%E7%BB%93%E8%AF%BE%E8%80%83%E8%AF%95%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>适用人群：中国矿业大学计算机科学与技术专业学生</p></blockquote><h1 id="2021秋期末真题"><a href="#2021秋期末真题" class="headerlink" title="2021秋期末真题"></a>2021秋期末真题</h1><blockquote><p>题干为个人回忆版本，同时，由黄凯同学提供第四题题干，并进行题干二次核对，已尽力与原题目描述保持一致。答案来自本人理解，不确保与老师理解完全一致。</p></blockquote><h2 id="第一题（10）"><a href="#第一题（10）" class="headerlink" title="第一题（10）"></a>第一题（10）</h2><p>给出了一个大整数乘法算法的描述，对于n位乘法，仅作3次n/2位的乘法和1次n位的加法即可</p><ol><li>根据题意写出递归公式（5）</li><li>求算法复杂度（5）</li></ol><blockquote><p>考概述-主定理法等。</p><script type="math/tex; mode=display">\begin{array}{X}T(n) =\left\{\begin{matrix}O(1)  & n=1\\3T(\frac{n}{2} ) + O(1) & n>1 \\\end{matrix}\right. \\\\O(n^{\log_32})\end{array}</script></blockquote><h2 id="第二题（10）"><a href="#第二题（10）" class="headerlink" title="第二题（10）"></a>第二题（10）</h2><p>现有程序设计比赛公示名单，已经按照学号非降序排列好了，现在插入学号为x的学生</p><ol><li>写出算法描述，如何找到x之前的学生的最大序号i和x之后的学生的最小序号j（5）</li><li>最坏情况下的算法复杂度（5）</li></ol><blockquote><p>考分治-二分搜索。</p><ol><li>结合题目内容描述二分搜索即可。（但我不是很理解为什么要说非降序排列，直接说升序排列不可以吗，难道有一个人学号出现多次，有重复元素吗，考试我是按照无重复元素写的），最后有<code>i = mid - 1</code>与<code>j = mid + 1</code></li><li>$O(\log n)$</li></ol></blockquote><h2 id="第三题（10）"><a href="#第三题（10）" class="headerlink" title="第三题（10）"></a>第三题（10）</h2><p>开了个小卖部，给出1-12月各月的盈利，含负数，负数就是亏损，求连续月份的最大盈利和</p><ol><li>写出算法描述（5）</li><li>最坏时间复杂度分析（5）</li></ol><blockquote><p>考动态规划-最大子段和。</p><ol><li>结合题目内容描述最大子段和算法即可。</li><li>$O(n)$</li></ol></blockquote><h2 id="第四题（20）"><a href="#第四题（20）" class="headerlink" title="第四题（20）"></a>第四题（20）</h2><p>体育馆预约，给出十个人预约的开始时间与结束时间，现在进行安排</p><ol><li>写出算法描述（10）</li><li>能安排多少人（5）</li><li>能安排哪些人（5）</li></ol><blockquote><p>考贪心-活动安排问题。</p><ol><li>结合题目内容描述活动安排算法即可。</li><li>算出来就出来了。</li><li>算出来就出来了。</li></ol></blockquote><h2 id="第五题（20）"><a href="#第五题（20）" class="headerlink" title="第五题（20）"></a>第五题（20）</h2><p>有五堆石子，数量已知</p><ol><li>只能取得两个相邻石子合并，这一次合并的代价是两堆石子数量之和，求合并成一堆最小代价（<a href="https://www.acwing.com/problem/content/284/">题目链接</a>）（10）</li><li>任意取得两个石子合并，这一次合并的代价是两堆石子数量之和，求合并成一堆的最小代价（10）</li></ol><blockquote><ol><li>考动态规划-石子合并。</li><li>考贪心-哈夫曼。</li><li>对于先入为主与考试时间分配策略问题，见感悟部分。</li></ol></blockquote><h2 id="第六题（15）"><a href="#第六题（15）" class="headerlink" title="第六题（15）"></a>第六题（15）</h2><p>打算法比赛，还有五个小时，还有五个题目没做，给出题目价值和预计AC题目时间，利用回溯法求最优解</p><ol><li>什么集合类型（5）</li><li>剪枝函数（5）</li><li>画树（5）</li></ol><blockquote><p>考回溯-01背包。</p><ol><li><p>子集树。</p></li><li><p>都是定义</p><p>分支剪枝：$cw&gt;c$</p><p>限界剪枝：$cp+cr \leq bestw$</p></li><li><p>都是定义，没啥说的。</p></li></ol></blockquote><h2 id="第七题（15）"><a href="#第七题（15）" class="headerlink" title="第七题（15）"></a>第七题（15）</h2><p>给出一个图，点是学生，线是学生存在闺蜜关系，求最大闺蜜团，要求利用分支限界法，利用优先队列。</p><p><img src="https://s2.loli.net/2021/12/10/rwO6NARU2zG5acW.png" style="zoom:50%;" /></p><ol><li>什么集合类型（5）</li><li>剪枝函数（5）</li><li>画树（5）</li></ol><blockquote><p>考分支限界-最大团问题。</p><ol><li><p>子集树（对于知识点记忆与考试时间分配策略问题，见感悟部分）</p></li><li><p>分支剪枝：存在当前加入的点与任意已成团的某个点在原图没有连线</p><p>限界剪枝：$num = c + r \leq best$</p><p>优先级：$num$</p></li><li><p>都是定义，没啥说的。（1,3,4,5）</p></li></ol></blockquote><h1 id="关于考试的感想"><a href="#关于考试的感想" class="headerlink" title="关于考试的感想"></a>关于考试的感想</h1><ol><li>考试整体时间感觉不是很充裕，如果每道题正常速度做完且不出错的话，应该只能预留出几分钟而已。</li><li>我的个人建议是，即便题干小问没有说明要你写出最后大题干计算得出答案，最好也要把大题干的实际问题答案给求出来，并且明示计算结果放在最后。</li><li>⚠<strong>关于第四大题</strong>：至于为什么第四题没有做，空白了，20分直接不要，是因为看到“合并石子”我就直接跳过了，其他的句子是<strong>一个字也没有多看</strong>，这是极为严重的错误。在我印象中很早就知道有合并石子这个题目，但是当时觉得很难，做不出来，后来学习算法之后也没有重新去学习该怎么做这个题（但是真的是很简单的…），因此条件反射看到“石子”我就认为自己不会做，导致直接跳题，甚至第二小问很简单的哈夫曼都没有注意到要去做。所以<strong>平时遇到不会的题目一定要及时去做，去分析相同点，多去遇见一些类似的题型，多刷题和总结，融会贯通。</strong></li><li>⚠<strong>关于第七大题</strong>：首先是复习不认真，算法知识点记得不牢固，子集树还是排列树纠结了很久（特别是前面一题已经考了子集树为什么还是考子集树，我觉得不应该…导致误判，至少有20分钟我在研究怎么画排列数，节点的字母写到UVW的时候开始怀疑自己是不是弄错了，然后醒悟过来了…我的节点优先级一直都没有变（因为如果按照排列树的话，$num$一直都等于原图节点数量，不像子集树一样会减小）然后是明知道画树已经非常麻烦了，又要重画，为什么不再重新看看第四大题，哪怕看一看题目都好，<strong>不要这么固执</strong>，可能也是时间已经很紧张了，心理作用，过分看重考试结果了，所以心态愈发不稳定。</li><li><strong>平时复习一定要全方位，第一是要课本知识记忆准确，第二是强调泛化能力，从课本脱离，应用到各个场景。</strong></li><li>这波是真的寄了，战前准备和战术上都极其失误，预估考试卷面70左右，平时分看老师了，学弟学妹们一定要好好学啊，血泪教训已经摆在这里了。</li></ol><h1 id="关于课程的感想"><a href="#关于课程的感想" class="headerlink" title="关于课程的感想"></a>关于课程的感想</h1><ol><li>上课的时候没有怎么认真听，注意力还是不够集中，其实认真听还是听得懂的，只是不能长期保持这种状态，老师教的还是不错的，就是不认真，课堂测验学压缩算法都是十分钟看ppt立马学会计算结果的，然后还算对了（所以感觉逼迫自己努力去学习的话，应该还是能学好的，也许不是自己学习能力的问题吧）基本上课程学会都是结课后看ppt，可能平时手机的影响确实是太大了…不够自律。上课时间还是要好好把握住的。</li><li>算法是计算机专业非常重要的一门课程，算法能力也体现一个计算机人的专业程度，程序设计竞赛考算法，面试需要算法，管饭碗的东西为什么不认真学呢。</li><li>也没有主动去多深入学习一下，特别是关于定理的证明，因为不考就不深入探究了，其实只是我们学校不考试，别的学校本科也会有考察的，可能研究生面试复试之类的也会考察。真要做只适应应试的做题家，肯定是走不远的。</li><li>算法虐我千百遍…哎…不会再爱了…挺不好受的，希望今后有空多看黑书，多看看MIT的算法导论课程，以及面试算法题，然后多加实践，多码代码，刷刷leetcode和acwing等面试相关算法题，加油。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>CUMT课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《实用优化算法-2021秋》课程小结</title>
    <link href="/2021/11/14/%E3%80%8A%E5%AE%9E%E7%94%A8%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95-2021%E7%A7%8B%E3%80%8B%E7%BB%93%E8%AF%BE%E8%80%83%E8%AF%95%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/11/14/%E3%80%8A%E5%AE%9E%E7%94%A8%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95-2021%E7%A7%8B%E3%80%8B%E7%BB%93%E8%AF%BE%E8%80%83%E8%AF%95%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="一维搜索"><a href="#一维搜索" class="headerlink" title="一维搜索"></a>一维搜索</h1><ul><li>黄金分割法（第一题考了这个，迭代两次就行，不过这次考的不是二次函数，加了一个cos函数，所以计算器计算的时候要注意设置为弧度制）</li><li>斐波那契法</li></ul><h1 id="无约束搜索"><a href="#无约束搜索" class="headerlink" title="无约束搜索"></a>无约束搜索</h1><ul><li>下降方向（第二题第一小问考了这个，给出函数，点，方向，确定是否为下降方向，就是定义）</li><li>最优性条件（第二题第二小问考了这个，直接函数求导为0求解就行，正定矩阵大于零，是极小点）</li><li>梯度下降法（第三题第一小问考了这个，迭代一次；第三题第二小问要求证明xk的坐标与k的关系式，应该是证明每次α的值都是一样的，推导一下就行，考试没想出来，应该是这里扣的三分）</li><li>牛顿法与阻尼牛顿法</li><li>共轭梯度法</li><li>拟牛顿法（第四题，DFP公式记牢）</li></ul><h1 id="有约束搜索"><a href="#有约束搜索" class="headerlink" title="有约束搜索"></a>有约束搜索</h1><ul><li>有效集、KKT点、λ、σ（第六题考了数形结合画图，求最小值点，对于最小值点求出该点的λ参数，注意比如1≤x≤5是两个条件，要转换成x≥1与-x+5≥0才行）</li><li>外罚函数法</li><li>内罚函数法/内点法/障碍函数法（第五题考了这个，障碍函数使用对数函数，不等式约束，最后好像求出了两个点，都计算一下取最小值）</li><li>增广拉格朗日/乘子法（第七题考了这个，等式约束）</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>最后老师发的练习题还是很管用的，好好做两遍，第一遍学算法步骤，第二遍验证计算能力，就差不多了</li><li>学的知识很多，考的内容还好，主要是计算要准确，考试给的数字不难，大多可以手算，很少用到计算器，但是不要不带计算器，第一题还是需要的，有一题画图，所以最好带上铅笔直尺</li><li>公式一定要记准确</li><li>有的算到最后和结论不一样就知道要再算一遍，比如拟牛顿法二次函数计算x2时g2肯定为0也就是结束计算，算出来g2不对就要返回去检查计算了</li><li>好多题做完第一遍后检查可以利用数形结合，基本上约束条件和函数比较好画，都是直线，椭圆，二次函数之类的，画个简单的图形判断最优解就知道自己算的对不对了，第一遍自己算错了三个，然后画图之后好像都改对了</li><li>考了97，平时分98，总评98。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CUMT课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《算法导论》笔记</title>
    <link href="/2021/10/26/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/10/26/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><p><strong>重要特性</strong>  输入、输出、确定性、有限性</p><p><strong>算法描述</strong>  自然语言、流程图、伪代码、程序代码</p><p><strong>算法的复杂性</strong>  时间复杂性、空间复杂性</p><p><strong>算法的渐进性态</strong></p><p>$O(g(n))$ 上界</p><p>$Ω(g(n))$ 下界</p><p>$Θ(g(n))$ 确界</p><p>$logn &lt; n &lt; nlogn &lt; n^2 &lt; n^3 &lt;2^n$</p><p><strong>NP完全理论</strong>  能在多项式时间内求解的判定性问题称为P问题，在多项式时间能验证猜测解的正确性为NP问题</p><h1 id="递归与分治"><a href="#递归与分治" class="headerlink" title="递归与分治"></a>递归与分治</h1><h2 id="递归概念"><a href="#递归概念" class="headerlink" title="递归概念"></a>递归概念</h2><p><strong>递归定义</strong>  用函数自身定义的函数 GNU is Not Unix</p><p><strong>递归函数两个要素</strong>  边界条件与递归方程</p><p><strong>满足条件</strong>  可转化（可以转化为一个或者多个子问题，子问题的求解方法与原问题完全相同，只在规模上不同）、调用次数有限、有结束递归的条件来终止递归，并不是所有递归都可以转换</p><p><strong>何时使用递归</strong>  定义是递归的（斐波那契），数据结构是递归的（链表），问题的求解方法是递归的（汉诺塔，数的排列）</p><p><strong>递归算法转化为非递归算法</strong></p><ol><li><p>直接转化法：直接用循环结构的算法替代递归算法，不需要使用栈</p></li><li><p>用栈模拟系统的运行过程，通过分析只保存必须保存的信息，从而用非递归算法替代递归算法，需要使用栈</p></li></ol><h2 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Template&lt;class type&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Perm</span><span class="hljs-params">(Type list[], <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//递归地产生所有前缀是list[0:k-1],且后缀是list[k:m]的全排列的所有</span><br><span class="hljs-keyword">if</span> (k==m) &#123; <span class="hljs-comment">//只剩下一个元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++) cout&lt;&lt;list[i];<br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">//还有多个元素，递归产生后缀是list[k:m] 的全排列</span><br><span class="hljs-keyword">for</span>(i=k;i&lt;=m;i++) &#123;<br><span class="hljs-built_in">Swap</span>(list[k],list[i]);<br>    <span class="hljs-built_in">Perm</span>(list,k+<span class="hljs-number">1</span>,m);<br>    <span class="hljs-built_in">Swap</span>(list[k],list[i]); <span class="hljs-comment">//记得还原</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h2><p>对于数据n，最大加数不大于m的划分个数记作q(n,m)</p><script type="math/tex; mode=display">q(n,m) = \left\{\begin{matrix}1  & n = 1,m = 1\\ q(n,n) &n<m \\ 1+q(n,n-1) &n = m \\ q(n,m-1)+q(n-m,m) &n>m>1\end{matrix}\right.</script><h2 id="分治概念"><a href="#分治概念" class="headerlink" title="分治概念"></a>分治概念</h2><p><strong>设计思想</strong>  将一个难以直接解决的大问题，分割成一些规模较小的子问题，这些子问题互相独立且与原问题相同，从而递归地解子问题，将各个子问题的解合并得到原问题的解</p><p><strong>适用问题</strong>  该问题可以分解为若干个规模较小的相同问题；该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题；该问题的规模缩小到一定的程度就可以容易地解决；利用该问题分解出的子问题的解可以合并为该问题的解</p><p><strong>求解过程</strong> 分解、求解、合并</p><p><strong>时间复杂性计算</strong>  扩展递归技术、递归树、主定理方法</p><p><strong><em>▲主定理方法</em></strong>  T(n)=aT(n/b)+f(n)，其中a≥1，b&gt;1为常数，该方程描述了算法的执行时间，算法将规模为n的问题分解成a个子问题，每个子问题的大小为n/b。比较两个式子大小即可</p><script type="math/tex; mode=display">T(n) = aT(\frac{n}{b} ) + f(n) =\left\{\begin{matrix}O(n^{log_{b}a } )  & n^{log_{b}a} > f(n)\\O(n^{log_{b} a }log_2 n) & n^{log_{b}a} = f(n) \\O(f(n)) & n^{log_{b}a} < f(n)\end{matrix}\right.</script><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p><strong>问题描述</strong>  给定已按升序排好序的n个元素a[1:n]，现要在这n个元素中找出一特定元素x</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BinarySearch</span><span class="hljs-params">(Type a[ ], <span class="hljs-keyword">const</span> Type &amp;x,<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> right=n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br><span class="hljs-keyword">int</span> middle=(left+right)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(x==a[middle])<br><span class="hljs-keyword">return</span> middle;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&gt;a[middle])<br>left=middle+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>right=middle<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释</strong></p><p>指针left在什么情况下会超过right?</p><p>Left指针向左移动, right指针向右移动，如果一直没有找到结果，那么这两个指针最终会重叠，指向同一个位置。 此时队列中只剩下一个元素。</p><p>此时，left=right； 因此middle=left=right；</p><p>如果这个元素满足x==a[middle]，程序结束 return middle；</p><p>否则如果x&gt;a[middle], left=middle+1后，left将位于right的右边；</p><p>否则如果x&lt;a[middle], right=middle-1后，right将位于left的左边</p><h2 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h2><p><strong>问题描述</strong>  XY是n位二进制整数，计算他们的乘积XY</p><script type="math/tex; mode=display">\begin{array}  {X}X=A2^{\frac{n}{2}}+B, Y=C2^{\frac{n}{2}}+D \\   XY = AC2^n+(AD+BC)2^{\frac{n}{2} }+BD  \\  =AC2^n+((A-B)(D-C)+AC+BD)2^{\frac{n}{2}}+BD \\  T(n) = O(n^{log3}) =\left\{\begin{matrix}O(1)  & n=1\\3T(\frac{n}{2} ) + O(n) & n>1 \\\end{matrix}\right.\end{array}</script><h2 id="Strassen乘法"><a href="#Strassen乘法" class="headerlink" title="Strassen乘法"></a>Strassen乘法</h2><p><strong>问题描述</strong>  计算两个矩阵相乘的结果，分块矩阵计算</p><script type="math/tex; mode=display">\begin{array}  {X}  T(n) = O(n^{3}) =\left\{\begin{matrix}O(1)  & n=1\\8T(\frac{n}{2} ) + O(n^2) & n>1 \\\end{matrix}\right.\end{array}</script><p><strong>解释</strong>  两个 n/2×n/2 的矩阵相加： 一行需要n/2次加法，共有n/2行，因此，两个矩阵相加的复杂度为 n/2×n/2=n^2/4，四次矩阵相加的复杂度为 O(n^2)</p><p><strong>改进算法</strong>  只需要七次乘法</p><h2 id="棋盘覆盖"><a href="#棋盘覆盖" class="headerlink" title="棋盘覆盖"></a>棋盘覆盖</h2><p><strong>问题描述</strong>  2^k阶的棋盘中只有一个方格残缺，要求用L型骨牌覆盖残缺棋盘上的所有方格且任何2个L型骨牌不得重叠覆盖，用递推求解时间复杂度</p><script type="math/tex; mode=display">\begin{array}  {X}  T(k) = O(4^{k}) =\left\{\begin{matrix}O(1)  & k=0\\4T(k-1 ) + O(1) & k>0 \\\end{matrix}\right.\end{array}</script><p><strong>解释</strong>  测试哪个子棋盘残缺以及形成3个残缺子棋盘需要O(1) ，覆盖4个残缺子棋盘（ 2^(k-1)阶）需四次递归调用，共需时间4T(k-1)</p><h2 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h2><p><strong>问题描述</strong> 数组排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">temlplate  &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">type</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(Type a[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function">  </span>&#123;   <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>eft &lt; right) <span class="hljs-comment">//至少有2个元素</span><br>       &#123;  <br>       <span class="hljs-keyword">int</span> i = (left + right ) /<span class="hljs-number">2</span>; <span class="hljs-comment">//取中点</span><br>       <span class="hljs-built_in">MergeSort</span>(a, <span class="hljs-number">1</span>eft, i)；<br>       <span class="hljs-built_in">MergeSort</span>(a, i+<span class="hljs-number">1</span>, right)；<br>       <span class="hljs-built_in">Merge</span>(a, b, <span class="hljs-number">1</span>eft, i, right)；<span class="hljs-comment">//从a合并到数组b</span><br>       <span class="hljs-built_in">copy</span>(a, b, left, right);<span class="hljs-comment">//复制回数组a</span><br>     &#125;<br> &#125;    <br></code></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{array}  {X}  T(n) = O(nlogn) =\left\{\begin{matrix}O(1)  & n=1\\2T(\frac{n}{2} ) + O(n) & n>1 \\\end{matrix}\right.\end{array}</script><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>问题描述</strong> 数组排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSoft</span><span class="hljs-params">(Type a[], <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(p&lt;r) &#123;<br>        <span class="hljs-keyword">int</span> q=<span class="hljs-built_in">Partition</span>(a, p, r)<br>        <span class="hljs-comment">//找到q的位置</span><br>        <span class="hljs-comment">//同时确保该位置右边的比基准元素大，左边的比基准元素小</span><br>        <span class="hljs-built_in">QuickSort</span>(a, p, q<span class="hljs-number">-1</span>); <span class="hljs-comment">//对左半段排序</span><br>        <span class="hljs-built_in">QuickSoft</span>(a, q+<span class="hljs-number">1</span>, r); <span class="hljs-comment">//对右半段排序</span><br>        &#125;<br>     &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(Type a[],<span class="hljs-keyword">int</span> p , <span class="hljs-keyword">int</span> r )</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = p; j = r+<span class="hljs-number">1</span>;<br>    type x = a[p];<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123; <br>         <span class="hljs-keyword">while</span>(a[++i] &lt; x &amp;&amp; i &lt; r);<br>         <span class="hljs-keyword">while</span>(a[--j] &gt; x);<br>         <span class="hljs-keyword">if</span> (i &gt;= j) <span class="hljs-keyword">break</span>;<br>         <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>    &#125;<br>    <span class="hljs-built_in">swap</span>(a[p], a[j]);<br>    <span class="hljs-keyword">return</span> j;<br>&#125;<br><br><span class="hljs-comment">//随机选择基准点的快速排序</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">randomizedQuickSoft</span><span class="hljs-params">(Type a[], <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p&lt;r) &#123;<br>        <span class="hljs-keyword">int</span> q=<span class="hljs-built_in">randomizedPartition</span>(a, p, r);<br>        <span class="hljs-built_in">randomizedQuickSort</span>(a, p, q<span class="hljs-number">-1</span>); <span class="hljs-comment">//对左半段排序</span><br>        <span class="hljs-built_in">randomizedQuickSoft</span>(a, q+<span class="hljs-number">1</span>, r); <span class="hljs-comment">//对右半段排序</span><br>        &#125;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">randomizedPartition</span><span class="hljs-params">(Type a[], <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-built_in">random</span>(p, r);<br>    <span class="hljs-built_in">swap</span>(a[i], a[p]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Partition</span> (a,p,r);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释</strong></p><ol><li>步骤<ul><li>分解：以a[p]为基准元素将a[p:r]划分成3段a[p:q-1],a[q]和a[q+1:r]，使a[p:q-1]中任意一个元素小于等于a[q]，而a[q+1:r]中任何一个元素大于等于a[q]，下标q在划分过程中确定</li><li>递归求解：通过递归调用快速排序算法分别对a[p:q-1]和a[q+1:r]进行排序</li><li>合并</li></ul></li><li>最坏情况，已经排好，O(n^2)</li><li>最好情况，每次划分大小都是n/2，O(nlogn)</li></ol><p><img src="https://i.loli.net/2021/10/26/Gm4dM5kU1rN2K9Y.jpg" style="zoom:67%;" /></p><h2 id="线性时间选择"><a href="#线性时间选择" class="headerlink" title="线性时间选择"></a>线性时间选择</h2><p><strong>问题描述</strong> </p><p>无序排列中求n个元素中第k小的元素（主要求中位数）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span><br><span class="hljs-function">Type <span class="hljs-title">RandomizedSelect</span> <span class="hljs-params">(a[], <span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p==r) <span class="hljs-keyword">return</span> a[p];<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-built_in">RandomizedPartition</span>(a, p, r), <span class="hljs-comment">//前面有</span><br>    j = i-p+l  <span class="hljs-comment">//统计前半部分元素个数j,  i为基准点</span><br>    <span class="hljs-keyword">if</span> ( k &lt;= j )<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">RandomizedSelect</span>(a, p, i, k);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">RandomizedSelect</span>(a, i+<span class="hljs-number">1</span>, r, k-j);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释</strong></p><p>根据随机产生的基准点，将元素分为2组，基准点包含在第1组中；如果k&lt;=j，则第k小元素落在a段，为a段的第k小元素；如果k&gt;j，则a段的所有元素都比第k小元素还要小，第k小元素落在b段，为b段中的第k-j小元素（-j的含义是去掉a段的元素总个数）</p><p>最坏情况，分成两个1和n-1的子问题，O(n^2)</p><p>最好情况，每次都产生n/2大小的子问题，O(n)</p><p><strong>基准点选择优化</strong></p><p>例如可以分成五个组，取每组中位数的中位数。设所有元素互不相同。在每一组中有2个元素小于本组的中位数，而n/5个中位数中又有(n-5)/10个小于基准x,因此，找出的基准x至少比3(n-5)/10个元素大。同理，基准x也至少比3(n-5)/10个元素小。当n≥75时，3(n-5)/10≥n/4所以按此基准划分所得的2个子数组的长度都至少缩短1/4。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Type <span class="hljs-title">Select</span><span class="hljs-params">(Type a[], <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (r-p&lt;<span class="hljs-number">75</span>) &#123;<br>        TO DO<span class="hljs-comment">//用某个简单排序算法对数组a[p:r]排序;</span><br>        <span class="hljs-keyword">return</span> a[p+k<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;=(r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">5</span>; i++ ) &#123;<br>        <span class="hljs-comment">//将a[p+5*i]至a[p+5*i+4]的第3小元素与a[p+i]交换位置;</span><br>        Type x = <span class="hljs-built_in">Select</span>(a, p, p+(r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">5</span>, (r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-built_in">Partition</span>(a,p,r, x),<br>        j=i-p+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (k&lt;=j) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Select</span>(a,p,i,k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">Select</span>(a,i+<span class="hljs-number">1</span>,r,k-j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>例题</strong></p><p>a=[2,6,9,1,4,10,20,6,22,11,10,9,4,3,7,16,11,8,2,5,4,1]</p><p>寻找第5小元素</p><p>(要求两个中位数选择较小的一个，支点放在第一个列表中)</p><p><strong>解答</strong></p><p>$n=22$，分组如下</p><p>[2,6,9,1,4] [10,20,6,22,11] [10,9,4,3,7] [16,11,8,2,5] [4,1]</p><p>中位数集合[4, 11, 7, 8, 4]，选择中位数的中位数为7作为支点</p><p>把支点放在第一个列表中</p><p>划分a[0:11]=[2, 6, 1, 4, 6, 4, 3, 2, 5, 4, 1, 7]<br>       a[12:21]=[9, 10, 20, 22, 11, 10, 9, 16, 11, 8] </p><p>对a[0:11]继续分组 [2,6,1,4,6],[4,3,2,5,4],[1]</p><p>中间元集合:[4,4,1]，中间元的中间元为4作为支点</p><p>把支点放在第一个列表中，划分：[2,1,4,4,3,2,4,1] [6,6,5]</p><p>对a[0:7]继续分组 [2,1,4,4,3],[2,4,1]</p><p>中间元集合:[3,2]，中间元的中间元为2作为支点</p><p>划分：[2,1,2,1] [4,4,3,4]</p><p>第一组小于5了</p><p>取第二组第5-4=1小的，也就是3</p></blockquote><h2 id="最接近点对"><a href="#最接近点对" class="headerlink" title="最接近点对"></a>最接近点对</h2><p><strong>一维情况</strong></p><p>1) 将S上的n个点分成大致相等的2个子集S1和S2<br>2) 分别求S1和S2中的最接近点对<br>3) 求一点在S1、另一点在S2中的最接近点对<br>4) 从上述三对点中找距离最近的一对</p><p><strong>二维情况</strong></p><ol><li>m为S中各点x间坐标的中位数，构造S1和S2    O(n)</li><li>递归求S1和S2的最小距离    2T(n/2)</li><li>求上述两个距离的最小值dm</li><li>设P1是S1中距垂直分割线l的距离在dm之内的所有点组成的集合；P2是S2中距分割线l的距离在d之内所有点组成的集合；将P1和P2中的点依其y坐标值排序；并设X和Y是相应的已排好序的点列    O(nlogn)</li><li>通过扫描X以及对于X中每个点检查Y中与其距离在dm之内的所有点(最多6个)可以完成合并；当X中的扫描指针逐次向上移动时，Y中的扫描指针可在宽为2dm的区间内移动；设dl是按这种扫描方式找到的点对间的最小距离；    O(n)</li><li>选择dm dl的最小值</li></ol><h2 id="循环赛日程表"><a href="#循环赛日程表" class="headerlink" title="循环赛日程表"></a>循环赛日程表</h2><p><strong>问题描述</strong>  设有n(n = 2^k)位选手参加网球循环赛，循环赛共进行n-1天，每位选手要与其他n-1位选手比赛一场，且每位选手每天必须比赛一场，不能轮空。</p><p><strong>发现规律</strong></p><p><img src="https://s2.loli.net/2021/12/07/y2EaPBCRoXkjQWO.png" alt="" style="zoom: 67%;" /></p><p><img src="https://s2.loli.net/2021/12/06/U93fnXqQmOthd68.png" style="zoom:50%;" /></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>基本思想</strong>  基本思想是在对一个多阶段决策的问题，按照某一顺序，根据每一步所选决策的不同，会引起状态的转移，最后会在变化的状态中获取到一个决策序列。</p><p><strong>基本要素</strong></p><ol><li>最优子结构性质（分析问题是否满足最优性原理（用反证法）：①先假设由问题的最优解导出的子问题的解不是最优的；②再证明在这个假设下可构造出比原问题最优解更好的解，从而导致矛盾）</li><li>子问题重叠性质（子问题不相互独立，重复出现，只在第一次遇到时加以求解，并把答案保存起来，以后再遇到时不必重新求解）</li></ol><p><strong>算法步骤</strong></p><ol><li>分析最优解的性质，并刻画其结构特征；</li><li>递归地定义最优值；</li><li>以自底向上或自顶向下的方式计算出最优值；</li><li>根据递归计算最优值时得到的信息，从子问题的最优解逐步构造出整个问题的最优解。</li></ol><h2 id="矩阵连乘"><a href="#矩阵连乘" class="headerlink" title="矩阵连乘"></a>矩阵连乘</h2><p><strong>问题描述</strong>  每计算出一个元素，需要q次乘法，最终得到的矩阵是p×r矩阵，有p×r个元素，因此，计算C需要的乘法次数为q×p×r。每次要选择较小的q×p×r。给定n个矩阵｛A1,A2,…,An｝，其中Ai与Ai+1是可乘的，且i=1,2⋯,n-1,如何确定计算矩阵连乘积的计算次序，使得计算矩阵连乘的数乘次数最少。</p><script type="math/tex; mode=display">m[i][j]=\left\{\begin{array}{cc}0 & i=j \\\min_{i\leq{k}<j} \{m[i][k]+m[k+1][j]+p_{i-1}p_kp_j\} & i<j\end{array}\right.</script><p><strong>解释</strong>  矩阵连乘积从Ai到Aj定义为A[i:j]，A[i:j]最少的乘法次数定义为m[i,j]，最优断开位置k记为𝑠[i,j]=k，T(n)=O(n^3)</p><blockquote><p><strong>例题</strong></p><p>计算矩阵连乘积A[1:6]的最少数乘次数，其中各矩阵的维数分别为p=[30,35,15,5,10,20,25]</p><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{matrix}𝑚[1][2]=𝑚[1][1]+𝑚[2][2]+p_0p_1p_2=15750\\𝑚[2][3]=𝑚[2][2]+𝑚[3][3]+p_1p_2p_3=2650\\...\\m[1][3]= \min \left\{\begin{matrix}m[1][1]+m[2][3]+p_0p_1p_3=7875▲\\m[1][2]+m[3][3]+p_0p_2p_3=18000\end{matrix}\right.\\s[1][3]=1\\...\\m[2][6]= \min \left\{\begin{matrix}  m[2][2]+m[3][6]+p_1p_2p_6=0+5375+35*15*25=18500\\m[2][3]+m[4][6]+p_1p_3p_6=2625+3500+35*5*25=10500▲\\m[2][4]+m[5][6]+p_1p_4p_6=4375+5000+35*10*25=18125\\m[2][5]+m[6][6]+p_1p_5p_6=7125+0+35*20*25=24625\end{matrix}\right.\\s[2][6]=3\\...\end{matrix}</script><div class="table-container"><table><thead><tr><th style="text-align:center">m</th><th style="text-align:center">A1</th><th style="text-align:center">A2</th><th style="text-align:center">A3</th><th style="text-align:center">A4</th><th style="text-align:center">A5</th><th style="text-align:center">A6</th></tr></thead><tbody><tr><td style="text-align:center">A1</td><td style="text-align:center">0</td><td style="text-align:center">15750</td><td style="text-align:center">7875</td><td style="text-align:center">9375</td><td style="text-align:center">11875</td><td style="text-align:center"><strong>15125</strong></td></tr><tr><td style="text-align:center">A2</td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">2625</td><td style="text-align:center">4375</td><td style="text-align:center">7125</td><td style="text-align:center">10500</td></tr><tr><td style="text-align:center">A3</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">750</td><td style="text-align:center">2500</td><td style="text-align:center">5375</td></tr><tr><td style="text-align:center">A4</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1000</td><td style="text-align:center">3500</td></tr><tr><td style="text-align:center">A5</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">5000</td></tr><tr><td style="text-align:center">A6</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">s</th><th style="text-align:center">A1</th><th style="text-align:center">A2</th><th style="text-align:center">A3</th><th style="text-align:center">A4</th><th style="text-align:center">A5</th><th style="text-align:center">A6</th></tr></thead><tbody><tr><td style="text-align:center">A1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center"><strong>1</strong></td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center"><strong>3</strong></td></tr><tr><td style="text-align:center">A2</td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">A3</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">A4</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">4</td><td style="text-align:center"><strong>5</strong></td></tr><tr><td style="text-align:center">A5</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">A6</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td></tr></tbody></table></div><p>从右上角的元素开始分割，从A3后面分为A[1,3]与A[4,6]，s[1,3]=1，从A1后面拆分，s[4,6]=5，从A5后面拆分，<strong>得到((A1(A2A3)((A4A5)A6)，次数最少是15125</strong></p></blockquote><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LCSLength</span></span><br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> *x, <span class="hljs-keyword">char</span> *y,<span class="hljs-keyword">int</span> c[][], <span class="hljs-keyword">int</span> b[][])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;m;i++) c[i][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;n;i++) c[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-comment">//m,n是X和Y的长度</span><br>            <span class="hljs-keyword">if</span> (x[i]==y[j]) &#123;<br>                c[i][j]=c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>                b[i][j]=<span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c[i<span class="hljs-number">-1</span>][j]&gt;=c[i][j<span class="hljs-number">-1</span>]) &#123;<br>                c[i][j]=c[i<span class="hljs-number">-1</span>][j];<br>                b[i][j]=<span class="hljs-number">2</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                c[i][j]=c[i][j<span class="hljs-number">-1</span>];<br>                b[i][j]=<span class="hljs-number">3</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LCS</span><span class="hljs-params">(i, j, X, b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span> || j==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (b[i,j]==<span class="hljs-string">&quot;1&quot;</span> ) &#123;<br>        <span class="hljs-built_in">LCS</span>(i<span class="hljs-number">-1</span>, j<span class="hljs-number">-1</span>, x, b);<br>        cout &lt;&lt;x[i];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b[i,j]==<span class="hljs-string">&quot;2&quot;</span> ) <br>       <span class="hljs-built_in">LCS</span>(i<span class="hljs-number">-1</span>, j, x, b);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">LCS</span>(i, j<span class="hljs-number">-1</span>, x, b);<br>&#125;   <span class="hljs-comment">//计算复杂性：O(m+n)</span><br><span class="hljs-comment">//LCS(i, j, X, b)实现根据b的内容打印出Xi与Yj的最长公共子序列。</span><br><span class="hljs-comment">//调用LCS(m,n,x,b) 可打印出序列X和Y的最长公共子序列。</span><br></code></pre></td></tr></table></figure><script type="math/tex; mode=display">c[i][j]=\left\{\begin{array}{cc}0 & i=0, j=0 \\c[i-1][j-1]+1 & i, j>0 ; x_{i}=y_{j} \\\max \{c[i-1][j], c[i][j-1]\} & i, j>0 ; x_{i} \neq y_{j}\end{array}\right.</script><p><strong>解释</strong>  c[i,j]记录序列Xi和Yj的最长公共子序列长度，b[i,j]可以记录是哪种类型。在c表中从最右下角的那个元素开始，看b表中对应位置的值，如果为1，则在c表中从当前位置往左上角走；如果为2，则在c表中从当前位置往正上方走；如果为3，则在c表中从当前位置沿水平方向往后退一位；依次类推，直到c表中箭头退到c[0，0]为止。</p><p><strong>补充</strong>  两个序列的最长公共子序列不唯一，不影响最长公共子序列的长度；但是可能会产生不一样的公共子序列，见例题</p><blockquote><p><strong>例题</strong></p><p>给定两个序列为X=ABCBDAB和Y=BDCABA，求最长公共子序列。</p><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{matrix}i=1,X_1=\{A\}\\j=1,Y_1=\{B\},𝑐[1][1]=\max⁡\{ 𝑐[0][1],𝑐[1][0]\}=0, b[1][1]=2 or 3\\j=2,Y_2=\{BD\},𝑐[1][2]=\max⁡\{ 𝑐[0][2],𝑐[1][1]\}=0, b[1][2]=2\\...\\j=4,Y_4=\{BDCA\},𝑐[1][4]=c[0][3]+1=1, b[1][4]=1\\...\\i=7,X_7=\{ABCBDAB\}\\j=6,Y_6=\{BDCABA\},\max⁡\{ 𝑐[6][6],𝑐[7][5]\}=4, b[7][6]=2 or 3\end{matrix}</script><p><img src="https://i.loli.net/2021/11/03/AiVcQH3dqO6XTpa.png" alt="c表与b表" style="zoom:50%;" /></p><p>斜线箭头尾部位置对应的元素为公共子序列元素（下标从1开始），也就是有BCBA（x[2346]与y[1356]）\BCAB（x[2367]与y[1345]）\BDAB（x[4567]与y[1245]）</p><p>PS: 对于C[1,1]=max{c[0,1],c[1,0]}={0,0}=0等情况，此时，b[1,1]=2或3都可以，不影响最终的结果。可能有多个答案。</p></blockquote><h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><p><strong>问题描述</strong> n个整数组成的序列，求该序列连续子段和的最大值（规定当所有<br>整数均为负整数时定义其最大子段和为0）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MaxSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> *a)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>, b=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (b&gt;<span class="hljs-number">0</span>) b+=a[i];<br>        <span class="hljs-keyword">else</span> b=a[i];<br>        <span class="hljs-keyword">if</span> (b&gt;sum) sum=b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><script type="math/tex; mode=display">b[j]= \min\{b[j-1]+a[j],a[j]\}(1\leq j \leq n)</script><p><strong>解释</strong> b[j]为以a[1,j]之间的任一位置开始，以a[j]为结束的最大子段和（必须要到j才行）。从i开始，到j-1结束的子段和的最大值&lt;=0，从i开始到j结束的子段和的最大值应该为a[j]自身。从i开始，到j-1结束的子段和的最大值大于0，此时，将a[j]加上（不是因为如果a[j]小于零就不加了，b[j]的定义就是要加到j），所得到的值应该是从i开始，到j结束的子段和的最大值。 O(n)</p><blockquote><p><strong>例题</strong></p><p>a[1:6]=[-2,11,-4,13,-5,-2]</p><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{matrix}j=1,𝑏[1]=\max\{𝑏[0]+𝑎[1],𝑎[1]\}=-2,i=1\\j=2,𝑏[2]=\max\{𝑏[1]+𝑎[2],𝑎[2]\}=11,i=2\\j=3,𝑏[3]=\max\{𝑏[2]+𝑎[3],𝑎[3]\}=11-4=7,i=2\\j=4,𝑏[4]=\max\{𝑏[3]+𝑎[4],𝑎[5]\}=7+13=20,i=2\\j=5,𝑏[5]=\max\{𝑏[4]+𝑎[5],𝑎[5]\}=20-5=15,i=2\\j=6,𝑏[6]=\max\{𝑏[5]+𝑎[6],𝑎[6]\}=15-2=13,i=2\end{matrix}</script><p>比较各个$b[i]$，其中最大的就是最大子段和，也就是$b[4]=20$,$i=2$开始，$j=4$结束，也就是$[11,-4,13]$</p></blockquote><h2 id="凸多边形最优三角剖分"><a href="#凸多边形最优三角剖分" class="headerlink" title="凸多边形最优三角剖分"></a>凸多边形最优三角剖分</h2><p><strong>问题描述</strong>  给定一个凸多边形以及定义在由多边形的边和弦组成的三角形上的权函数$w$。求一个三角剖分，使得剖分中诸三角形上的权之和为最小。 </p><script type="math/tex; mode=display">t[i][j]=\left\{\begin{array}{cc}0 & i=j \\\min_{i\leq{k}<j} \{t[i][k]+t[k+1][j]+w(v_{i-1}v_kv_j)\} & i<j\end{array}\right.</script><p><strong>解释</strong></p><p>定义$t[i][j]$为凸子多边形的最优剖分对应权函数值， $s[i][j]$记录了$v_{i-1}$和$ v_j$一起构成三角形的第3个顶点$k$的位置，据此，用$O(n)$时间就可以构造出<br>最优三角剖分中的所有三角形。</p><p>计算最优值与矩阵连乘积相似。计算凸$n+1$多边形的最优值为$ t[1][n]$</p><blockquote><p><strong>例题</strong></p><p>（好难算啊不会考吧）</p><p><img src="https://s2.loli.net/2021/12/07/isJWTNkCPd4ORfS.png" style="zoom:50%;" /></p><p><img src="https://s2.loli.net/2021/12/07/sTxqwMUX5JoyA3g.png" style="zoom:50%;" /></p><p><img src="https://s2.loli.net/2021/12/07/ViKmFwAuHB3PQ27.png" style="zoom:50%;" /></p><p><img src="https://s2.loli.net/2021/12/07/8d7TXheayMsRpr1.png" style="zoom:50%;" /></p><p><img src="https://s2.loli.net/2021/12/07/PUfmEldrnXp9W8B.png" style="zoom:50%;" /></p></blockquote><h2 id="图像压缩"><a href="#图像压缩" class="headerlink" title="图像压缩"></a>图像压缩</h2><p><strong>问题描述</strong>  数字化图像是的像素阵列。假定每个像素有一个0~255的灰度值，存储一个像素需8位。为了减少存储空间，采用变长模式，即不同像素用不同位数来存储。</p><ol><li>线性化：图片拉直，转换为$1×n^2$向量</li><li>分段：分成连续的$m$段，每段像素存储位数相同，每段最多含256个像素点</li><li>存放信息：第$i$段长度（8bit），第$i$段中像素存储位数（3bit）</li></ol><script type="math/tex; mode=display">\begin{matrix}s[i]=\min\limits_{1 \leq k \leq \min \{i,256\}}\{s[i-k]+k*bmax(i-k+1,i)  \}+11\\bmax(i,j)=\max\limits_{i\leq k \leq j}\{a[k]\}\end{matrix}</script><p><strong>解释</strong></p><p>假设$s[i]$是序列${p_1,p_2,…,p_i}$的最优解，$a[i]$是第i个像素点的位数。</p><ol><li>假设$p_i$自成一段，则$s[i]=s[i-1]$+保存$p_i$的代价</li><li>取$s[i]$为min时对应的元素个数为$k$，$s[i]=s[i-k]$+保存最后$k$个像素的代价</li><li>保存最后$k$个像素的代价=$k*max${$k$个灰度值二进制位数}+11</li></ol><blockquote><p><strong>例题</strong></p><p>求像素序列4，6，5，7，129，138，1的最优分段。</p><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{matrix}a=[3,3,3,3,8,8,1]\\s[0]=0\\s[1]=s[0]+1*\max \{3\} +11=14\\s[2]= \min \left\{\begin{matrix}s[0]+2* \max \{3,3\} + 11 = 17▲\\s[1] + 1*\max \{3\} +11 =28\end{matrix}\right.\\...\\s[7]= \min \left\{\begin{matrix}s[0]+7* \max \{3,3,3,3,8,8,1\} + 11 = 67\\s[1]+6* \max \{3,3,3,8,8,1\} + 11 = 73\\...\\s[4]+3* \max \{8,8,1\} + 11 = 58▲\\...\\s[6]+1* \max \{1\} + 11 = 62\end{matrix}\right.\end{matrix}</script><p>看s[7]=58，看58那一行是s[4]+3*max，前四个一起，后三个一起</p><p>看s[4]=23，看23那一行是s[0]+4*max，前四个就在一起，不再分</p><p>最后得到（4，6，5，7）（129，138，1）</p><p>ps每次计算比大小可以不加上11但是最后求$s$的时候别忘了加11</p></blockquote><h2 id="电路布线"><a href="#电路布线" class="headerlink" title="电路布线"></a>电路布线</h2><p><strong>问题描述</strong> 确定将哪些连线安排在第一层上，使得该层上有尽可能多的连线且不相交</p><script type="math/tex; mode=display">\begin{matrix} i=1, \qquad Size(i,j) = \left\{\begin{matrix}0 && j<\pi(1)\\1 && j \geq \pi (1)\end{matrix}\right.\\\\i>1,\qquad Size(i,j) = \left\{\begin{matrix}Size(i-1,j) && j<\pi(i)\\\max \{ Size(i-1,j),Size(i-1,\pi(i)-1)+1\} && j \geq \pi (i)\end{matrix}\right.\end{matrix}</script><p><strong>解释</strong>  MNS(i,j)表示上面序号小于i，连接到下面的序号都小于j的不相交的集合，最后要求MNS(n,n)。如果j<pi(i)，(i,pi(i)）不在MNS中，将i点删除没有影响。如果j>=pi(i)，如果（i,pi(i)）不在MNS中，将i点删除没有影响，就是size(i,j)=size(i-1,j)，如果（i,pi(i)）在MNS中，就是size(i,j)=size(i-1,pi(i)-1)+1</p><blockquote><p><strong>例题</strong></p><p>已知[(1 8)(2 7)(3 4)(4 2)(5 5)(6 1)(7 9)(8 3)(9 10)(10 6)]，求最大不相交情况</p><p><strong>解答</strong></p><p>i=1，pi(1)=8，j&gt;=<strong>8</strong>的size都为1</p><p>i=2，pi(2)=7，j&lt;<strong>7</strong>的size为size(<strong>1</strong>,j)，j&gt;=<strong>7</strong>的size为size(<strong>1</strong>,j)与size(<strong>1</strong>,<strong>6</strong>)+1=1的最大值</p><p>i=3，pi(3)=4，j&lt;<strong>4</strong>的size为size(<strong>2</strong>,j)，j&gt;=<strong>4</strong>的size为size(<strong>2</strong>,j)与size(<strong>2</strong>,<strong>3</strong>)+1=1的最大值</p><p>…</p><p><img src="https://s2.loli.net/2021/12/07/k9Gt8KfjJzgrnBc.png" style="zoom:50%;" /></p><p>最后size(10,10)=4，最多可以有四条不相交。</p><p>蓝色是算法选择的路径（向上优先，也可以用向左优先，答案都是四个，但值会有一点不同）。在斜角值改变时可以取得所求的子集。答案也就是[(3 4)(5 5)(7 9)(9 10)]，[(4  2)(5 5)(7 9)(9 10)]</p></blockquote><h2 id="流水作业调度"><a href="#流水作业调度" class="headerlink" title="流水作业调度"></a>流水作业调度</h2><p><strong>问题描述</strong>   n个作业要在两台机器M1和M2上进行加工。每个作业加工的顺序都是先在M1上加工，然后在M2加工。M1和M2加工作业i所需的时间分别为ai 和bi。确定n个作业的最优加工顺序，使得加工完成所需的时间最少。</p><p><strong>算法</strong></p><ol><li>N1集合存放ai&lt;bi的作业，N2存放ai≥bi的作业</li><li>N1中作业按照ai升序排序，N2中作业按照bi降序排序</li><li>N1连接N2，计算时间</li></ol><blockquote><p><strong>例题</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">任务</th><th style="text-align:center">J1</th><th style="text-align:center">J2</th><th style="text-align:center">J3</th><th style="text-align:center">J4</th><th style="text-align:center">J5</th><th style="text-align:center">J6</th></tr></thead><tbody><tr><td style="text-align:center">工序1</td><td style="text-align:center">30</td><td style="text-align:center">120</td><td style="text-align:center">50</td><td style="text-align:center">20</td><td style="text-align:center">90</td><td style="text-align:center">110</td></tr><tr><td style="text-align:center">工序2</td><td style="text-align:center">80</td><td style="text-align:center">100</td><td style="text-align:center">90</td><td style="text-align:center">60</td><td style="text-align:center">30</td><td style="text-align:center">10</td></tr></tbody></table></div><p><strong>解答</strong></p><ol><li><p>分集合  {1,3,4}{2,5,6}</p></li><li><p>排序  {4,1,3}{2,5,6}</p></li><li><p>合并与计算时间</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">任务</th><th style="text-align:center">J4</th><th style="text-align:center">J1</th><th style="text-align:center">J3</th><th style="text-align:center">J2</th><th style="text-align:center">J5</th><th style="text-align:center">J6</th></tr></thead><tbody><tr><td style="text-align:center">M1结束</td><td style="text-align:center">20</td><td style="text-align:center">50×</td><td style="text-align:center">100×</td><td style="text-align:center">220×</td><td style="text-align:center">310×</td><td style="text-align:center"><strong>420↓</strong></td></tr><tr><td style="text-align:center">M2开始</td><td style="text-align:center">20</td><td style="text-align:center">60</td><td style="text-align:center">140</td><td style="text-align:center">230</td><td style="text-align:center">330</td><td style="text-align:center">420</td></tr><tr><td style="text-align:center">M2结束</td><td style="text-align:center"><strong>80↗</strong></td><td style="text-align:center"><strong>160↗</strong></td><td style="text-align:center"><strong>250↗</strong></td><td style="text-align:center"><strong>350↗</strong></td><td style="text-align:center">380×</td><td style="text-align:center"><strong>430</strong></td></tr></tbody></table></div><p>ps：第k个任务M2开始的时间要取第k个任务M1结束的时间和第k-1个任务M2结束的时间的较大值。</p></blockquote><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><p><strong>问题描述</strong>  给定n种物品和一个背包。物品i的重量是wi，其价值为vi，背包的容量为c。问如何选择装入背包中的物品使得装入物品的总价值最大？</p><script type="math/tex; mode=display">\begin{matrix} m(i,j) = \left\{\begin{matrix}m(i+1,j) && 0 \leq j<w_i\\ \max \{ m(i+1,j),m(i+1,j-w_i)+v_i\} && j \geq w_i\end{matrix}\right.\\\\m(n,j) = \left\{\begin{matrix}0 && 0 \leq j<w_n\\ v_n && j \geq w_n\end{matrix}\right.\end{matrix}</script><p><strong>解释</strong>  m[i,j]表示可选择物品i, i+1, …, n时，背包容量为j装入的最大价值</p><blockquote><p><strong>例题</strong></p><p>n=5,c=10,W={2,2,6,5,4},V={6,3,5,4,6}</p><p><strong>解答</strong></p><p>i=5时，j<4时，装不进去，为0，j>=4时，能把w5=4装进去，为v5=6</p><p>i=4时，若j<5，则w4=5无法放入，m(4,j)=m(5,j)，j>=5时，比较m(5,j)与m(5,j-5)+4的最大值（可以看作先直接把m(5,j)往上复制一行，j&gt;=5时再比较更新即可，后面同理）</p><p>i=3时，若j<6，则w4=6无法放入，m(3,j)=m(4,j)，j>=6时，比较m(4,j)与m(4,j-6)+5的最大值</p><p>… 最后结果如下图</p><p><img src="https://i.loli.net/2021/11/13/Gn7oYtlkrdaIzhC.png" style="zoom:50%;" />当</p><p>从m(1,10)开始看起，m(1,10)!=m(2,10),说明1肯定被放入了背包中。1的重量为2，剩下的容量为10-2=8；</p><p>从m(2,8)开始看起，m(2,8)!=m(3,8),说明2肯定被放入了背包中。2的重量为2，剩下的容量为8-2=6；</p><p>从m(3,6)开始看起，m(3,6)=m(4,6),说明3肯定没有放入背包中。继续m(4,6)=m(5,6),说明4肯定没有放入背包中。</p><p>当i=5时，看剩余的容量，如果满足5号物品的重量，则5肯定放入。否则，5无法放入。此例，容量为6，5号物品重量为4，5号物品放入。</p><p>最后得到放入的五件物品状态为<strong>(1,1,0,0,1)</strong></p></blockquote><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><strong>思想</strong>  在贪婪算法中采用逐步构造最优解的方法。在每个阶段，都作出一个看上去最优的决策。它并不一定对所有问题都成功，因为不从整体最优加以考虑，贪心解法可能不是全局最优解，但是对某些问题特别简单、有效。</p><p><strong>基本要素</strong></p><ol><li><strong>最优子结构性质</strong>  问题的最优解包含其子问题的最优解</li><li><strong>贪心选择性质</strong>  问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到，当前的选择和子问题的解无关，只和以往做出的选择有关</li></ol><h2 id="活动安排"><a href="#活动安排" class="headerlink" title="活动安排"></a>活动安排</h2><p><strong>问题描述</strong>  在活动集合中选择最大的相容活动子集合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Type&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GreedySelector</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,Type s[],Type f[],<span class="hljs-keyword">bool</span> A[] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">//s存开始时间，f存结束时间，且按结束时间非减续排列；</span></span></span><br><span class="hljs-params"><span class="hljs-function">    A[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>; <span class="hljs-comment">//排在第1个的活动最先结束，直接放入A；</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-comment">//从第2个活动开始检测</span></span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-keyword">if</span> (s[i]&gt;=f[j]) &#123; A[i]=<span class="hljs-literal">true</span>; j=i; &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-comment">//如果相容，放入A</span></span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-keyword">else</span> A[i]=<span class="hljs-literal">false</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure><p><strong>证明贪心选择性质</strong></p><ol><li>假设问题有一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始，做了贪心选择后，原问题简化为规模更小的类似子问题。</li><li>运用数学归纳法证明，每一步贪心选择→问题的整体最优解</li></ol><blockquote><p><strong>例题</strong></p><div class="table-container"><table><thead><tr><th></th><th style="text-align:center">1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>start</td><td style="text-align:center">5</td><td>0</td><td>3</td><td>5</td><td>3</td><td>1</td><td style="text-align:center">8</td><td style="text-align:center">6</td><td style="text-align:center">8</td><td>12</td><td>2</td></tr><tr><td>stop</td><td style="text-align:center">9</td><td>6</td><td>5</td><td>7</td><td>8</td><td>4</td><td style="text-align:center">11</td><td style="text-align:center">10</td><td style="text-align:center">12</td><td>14</td><td>13</td></tr></tbody></table></div><p><strong>解答</strong></p><p>待安排的11个活动按结束时间的非减序排列</p><div class="table-container"><table><thead><tr><th></th><th style="text-align:center">6</th><th>3</th><th>2</th><th>4</th><th>5</th><th>1</th><th style="text-align:center">8</th><th style="text-align:center">7</th><th style="text-align:center">9</th><th>11</th><th>10</th></tr></thead><tbody><tr><td>start</td><td style="text-align:center"><strong>1</strong></td><td>3</td><td>0</td><td><strong>5</strong></td><td>3</td><td>5</td><td style="text-align:center">6</td><td style="text-align:center"><strong>8</strong></td><td style="text-align:center">8</td><td>2</td><td><strong>12</strong></td></tr><tr><td>stop</td><td style="text-align:center"><strong>4</strong></td><td>5</td><td>6</td><td><strong>7</strong></td><td>8</td><td>9</td><td style="text-align:center">10</td><td style="text-align:center"><strong>11</strong></td><td style="text-align:center">12</td><td>13</td><td><strong>14</strong></td></tr></tbody></table></div><p>最后为(6,4,7,10)</p></blockquote><h2 id="0-1背包-1"><a href="#0-1背包-1" class="headerlink" title="0-1背包"></a>0-1背包</h2><p><strong>几种贪心策略</strong>（但是都不能保证得到最优解）</p><ol><li>选择可以装入背包的价值最大的物品</li><li>选择可装入背包的重量最小的物品</li><li>选择可装入背包的vi/wi最大的物品（一般用来做回溯法或者分支限界的限界函数）</li></ol><h2 id="最优装载"><a href="#最优装载" class="headerlink" title="最优装载"></a>最优装载</h2><p><strong>策略</strong>  重量最轻的先装  T(n)=O(nlogn)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Loading</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x[], Type w[], Type c, <span class="hljs-keyword">int</span> n )</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> *t = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [n+<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">Sort</span>(w, t, n) ; <span class="hljs-comment">//按货箱重量排序/</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; = n; i ++)<br>    x[i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;= n &amp;&amp; w[t[i]] &lt;= c; i++) &#123;<br>        [t[i]] = <span class="hljs-number">1</span>;<br>        c-= w[t[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>例题</strong></p><p>(100,200,50,90,150,50,20,80), c=400</p><p><strong>解答</strong></p><p>所考察货箱的次序为73684152，考察到5时装不下了</p><p>(<strong>100</strong>,200,<strong>50</strong>,<strong>90</strong>,150,<strong>50</strong>,<strong>20</strong>,<strong>80</strong>) 装了390</p><p>(1,0,1,1,0,1,1,1)</p></blockquote><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p><strong>前缀码</strong>  对每一个字符规定一个0,1串作为其代码，并要求任一字符的代码都不是其它字符代码的前缀，这种编码称为前缀码。</p><p><strong>问题描述</strong>  找到使平均码长达到最小的前缀码编码方案</p><p><strong>策略</strong>  频率小的字符，深度大。队列Q以f(c)为键值存放二叉树各结点，通过贪心选择，将最小频率的两个二叉树合并，然后将新树（频率为上述两个二叉树频率之和）插入Q中。   T(n)=O(nlogn)</p><p><strong>证明贪心选择性质</strong></p><p>设x和y是字符集C中具有最小频率的两个字符，证明存在C的最优前缀码，使x和y具有最长、相同的码长且仅最后一位编码不同。设二叉树T表示C的任意一个最优前缀码方案。只要证明可以对T做适当修改后，得到一棵新的二叉树T’， 新树中，x和y是最深叶子且为兄弟。同时，新树也是C的最优前缀码方案。</p><p><strong>证明最优子结构性质</strong></p><p>设T表示C的一个最优前缀码方案。x和y是树T中的叶子节点且为兄弟。z是它们的父亲。若将z看做是具有频率f(z)=f(x)+f(y)的字符，则证明树T’=T-{x,y}表示字符集C’=C-{x,y} U {z}的一个最优前缀码即可。</p><blockquote><p><strong>例题</strong></p><p>设在1000个字母的文章中各字母出现的频率为a:83, b:14,  c:28,  d:38,  e:131,  f:29,  g:20,  h:53……，求最优编码。</p><p><strong>解答</strong></p><p><img src="https://i.loli.net/2021/11/14/5kI9jcio2xabpgC.png" style="zoom: 67%;" /></p><p>ps:注意兄弟节点左小右大（按题目规定）</p></blockquote><h2 id="单源最短路径-dijksta"><a href="#单源最短路径-dijksta" class="headerlink" title="单源最短路径(dijksta)"></a>单源最短路径(dijksta)</h2><p><a href="https://www.bilibili.com/video/BV1q4411M7r9">dijksta视频演示</a></p><blockquote><p><strong>例题</strong></p><p><img src="https://i.loli.net/2021/11/14/VuRe1vE9fZ6tKcS.png"  style="zoom: 33%;" /></p><p><strong>解答</strong></p><p><img src="https://i.loli.net/2021/11/16/81LgIlVw5zusOx9.png" style="zoom:25%;" /></p><p><img src="https://i.loli.net/2021/11/14/RuqJGtPOHmzlV6n.png" style="zoom: 25%;" /></p></blockquote><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>特点</strong>  深度优先搜索策略、算法框架是解空间（子集树与排列树）、在搜索的时候要避免遗漏，同时要高效。（具有限界函数的深度优先生成法称为回溯法）</p><p><strong>解空间</strong>  子集树（0-1，装载，子集和）与排列树（旅行商，m着色，n后）</p><p><strong>基本元素</strong>  活结点（自身已生成但其儿子还没有全部生成），拓展结点（正在产生儿子的结点），死结点（不满足约束或者所有儿子已经产生的结点）</p><p><strong>剪枝</strong>  用约束函数在扩展结点处剪去不满足约束的子树（左剪枝），用限界函数剪去得不到最优解的子树（右剪枝）</p><p><strong>终止条件</strong>  找到所有的解，解空间中没有活结点为止</p><h2 id="装载问题"><a href="#装载问题" class="headerlink" title="装载问题"></a>装载问题</h2><p><strong>问题描述</strong>   n个集装箱要装到2艘载重量分别为c1,c2的货轮，其中集装箱 i的重量为wi。要求找到装载方案将这n个货箱装上这2艘轮船</p><p><strong>解释</strong>  若装载问题有解, 采用如下策略可得一个最优装载方案：将第一艘轮船尽可能装满，将剩余的货箱装到第二艘轮船上。将第一艘船尽可能装满类似0-1背包问题</p><blockquote><p><strong>例题</strong></p><p>n=4,c1=12,W={8,6,2,3}</p><p><strong>解答</strong></p><p><img src="https://i.loli.net/2021/11/14/zurCOpm69MXy3Hk.png"  style="zoom: 67%;" /></p></blockquote><h2 id="0-1背包-2"><a href="#0-1背包-2" class="headerlink" title="0-1背包"></a>0-1背包</h2><p><strong>解释</strong>  子集树。只要左儿子节点是一个可行结点，搜索就进入左子树（不超过背包重量）（约束剪枝）。在右子树中有可能包含最优解是才进入右子树搜索，否则将右子树剪去（利用单价贪心求解价值上限）（限界剪枝）。$cw$是背包当前重量，$M-cw$是背包剩余的空间，$cp$是当前总收益，$rp$是贪心算法剩余的物品收益，$bestw$记录当前最优价值，也就是判断$bp=cp+rp&gt;bestw$是右节点的限界函数。（此外，回溯法解0-1背包的前置条件是物品已按$p_i/w_i$非增次序排序）</p><blockquote><p><strong>例题</strong></p><p>M=110</p><p>w=(1,11,21,23,33,43,45,55)，v=(11,21,31,33,43,53,55,65)</p><p><strong>解答</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th></tr></thead><tbody><tr><td style="text-align:center">w</td><td style="text-align:center">1</td><td style="text-align:center">11</td><td style="text-align:center">21</td><td style="text-align:center">23</td><td style="text-align:center">33</td><td style="text-align:center">43</td><td style="text-align:center">45</td><td style="text-align:center">55</td></tr><tr><td style="text-align:center">v</td><td style="text-align:center">11</td><td style="text-align:center">21</td><td style="text-align:center">31</td><td style="text-align:center">33</td><td style="text-align:center">43</td><td style="text-align:center">53</td><td style="text-align:center">55</td><td style="text-align:center">65</td></tr><tr><td style="text-align:center">v/w</td><td style="text-align:center">11</td><td style="text-align:center">1.9</td><td style="text-align:center">1.48</td><td style="text-align:center">1.43</td><td style="text-align:center">1.3</td><td style="text-align:center">1.23</td><td style="text-align:center">1.22</td><td style="text-align:center">1.18</td></tr></tbody></table></div><p><img src="https://i.loli.net/2021/11/14/7TLS4elkFUYRHOu.png" style="zoom:50%;" /></p><p>最优解为<strong>(1,1,1,0,1,1,0,0)</strong></p></blockquote><h2 id="n后问题"><a href="#n后问题" class="headerlink" title="n后问题"></a>n后问题</h2><p><strong>问题描述</strong>   皇后问题要求在一个n×n的棋盘上放置n个皇后，使得它们彼此不受”攻击”。n皇后问题要求寻找在棋盘上放置这n个皇后的方案，使得它们中任何两个都不在同一行、同一列或同一斜线上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nQueen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    Queen X；<br>    <span class="hljs-comment">//初始化X    </span><br>    X.n=n；<span class="hljs-comment">//皇后个数</span><br>    X.sum=<span class="hljs-number">0</span>；<br>    <span class="hljs-keyword">int</span>*p=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [n+<span class="hljs-number">1</span>]；<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>；i&lt;=n；i++) p[i]= <span class="hljs-number">0</span>；<br>    X.x=p；<br>    X.<span class="hljs-built_in">Backtrack</span>(<span class="hljs-number">1</span>)；<br>    <span class="hljs-keyword">delete</span> [] p；<br>    returnX. sum;<br>&#125;<br><br><span class="hljs-keyword">bool</span> Queen:: <span class="hljs-built_in">Place</span>(<span class="hljs-keyword">int</span> k) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; k; j++)<br>      <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">abs</span>(k-j) == <span class="hljs-built_in">abs</span>(x[j] - x[k])) <br>        ||(x[j] == x[k] ))<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br> <br><span class="hljs-keyword">void</span> Queen:: <span class="hljs-built_in">Backtrack</span>(<span class="hljs-keyword">int</span> t) &#123;<br>    <span class="hljs-keyword">if</span> (t &gt; n) <br>        sum++;<br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>         x[t] = i;<br>         <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Place</span>(t)) <br>             <span class="hljs-built_in">Backtrack</span>(t+<span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释</strong>  (x1, …, xn) , x[i]表示皇后i放在棋盘的第i行的第x[i]列，解空间是排列树。abs(i-j)≠abs(x[i] – x[j]))是约束函数（不在同一列已经实现）。如下图是4皇后的一个解。</p><p><img src="https://i.loli.net/2021/11/14/8KqMfCEVO9LyBxs.png" style="zoom: 67%;" /></p><h2 id="m着色"><a href="#m着色" class="headerlink" title="m着色"></a>m着色</h2><p><strong>解释</strong>  n元组(x0,x1,…,xn-1)表示图G的m-着色判定问题的解。对所有i和j，若邻接矩阵a[i，j]=1，则xi≠xj（约束条件）</p><blockquote><p><strong>例题</strong></p><p>使用回溯算法来求解图的m(m=3)着色问题的如下图实例。<br>(1) 给出解向量的形式，指出解空间树的类型。<br>(2) 描述搜索过程。<br>(3) 画出找到一个解所生成的部分搜索树，并给出这个解。</p><p><img src="https://i.loli.net/2021/11/14/uSJZqLQAlK3TedO.png" style="zoom: 67%;" /></p><p><strong>解答</strong></p><p>X=(x0,x1,x2,x3,x4)</p><p><img src="https://i.loli.net/2021/11/14/usNAxhWT4jkSvbQ.png" style="zoom: 67%;" /></p><p><strong>X=(1,2,3,2,1)</strong></p></blockquote><h2 id="旅行售货员"><a href="#旅行售货员" class="headerlink" title="旅行售货员"></a>旅行售货员</h2><h2 id="子集和"><a href="#子集和" class="headerlink" title="子集和"></a>子集和</h2><p><strong>问题描述</strong>  给出n个正实数集合与正整数M，找到元素之和为M的子集</p><blockquote><p><strong>例题</strong></p><p>设有n=6个正数的集合{5,10,12,13,15,18}和整数M=30，求W的所有元素之和为M的子集</p><p><strong>解答</strong></p><p><img src="https://i.loli.net/2021/11/14/ioq9NwWbhaYLnpT.png" style="zoom: 50%;" /></p><p>最后一步，5，6两个物品全要为31，所以不要前四个物品的右子树肯定不需要考虑了。</p></blockquote><h1 id="分支限界"><a href="#分支限界" class="headerlink" title="分支限界"></a>分支限界</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p><strong>解空间</strong>  子集树（单源最短路径问题）与排列树（售货商）</p><p><strong>搜索方式</strong>  广度优先或最小耗费优先</p><p><strong>适用问题</strong>  存在性问题（找出满足约束条件的一个解）与最优化问题（在满足约束条件的解中找出在某种意义下的最优解） </p><p><strong>活结点表（其实叫队列更好一点）</strong></p><ul><li>每一个活结点只有一次机会成为扩展结点</li><li>活结点一旦成为扩展结点，一次性产生其所有儿子结点（导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中）</li><li>从活结点表中取出下一结点成为当前扩展结点，并重复结点扩展过程</li><li>直到找到所需的解或活结点表为空时为止</li></ul><p><strong>选择扩展结点的两种常用方法</strong>  队列式（先进先出）、优先队列式（按照耗费/收益优先级选取下一个结点作为当前拓展结点）</p><h2 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h2><p>子集树</p><p>剪枝的原则：在扩展顶点i时，如果从当前扩展结点i到j有边可达，且从源出发途经i再到j的所对应路径长度小于当前最优路径长度，则将该顶点作为活结点插入到活结点优先队列中</p><blockquote><p><strong>例题</strong></p><p><img src="https://i.loli.net/2021/11/16/wrZ41YiqExp6QSc.png" style="zoom: 67%;" /></p><p><strong>解答</strong></p><ol><li><p>队列法</p><p><img src="https://i.loli.net/2021/11/16/bjfoQFy5YwlKaDS.png" style="zoom:50%;" /></p></li><li><p>优先队列法（dist短的优先）</p></li></ol><p>结果</p><p><strong>dist=(10,30,60,16,50)</strong></p><p><strong>prev=(0,0,5,1,2)</strong></p></blockquote><h2 id="装载问题-1"><a href="#装载问题-1" class="headerlink" title="装载问题"></a>装载问题</h2><p>子集树</p><p>约束函数：已装容量与c1容量</p><p>限界函数：un=已经装载的重量ew+剩余重量r</p><blockquote><p><strong>例题</strong></p><p>n=4,c_1=12,W={8,6,3,2}</p><p><strong>解答</strong></p><p>优先队列法（un大的先拓展）</p><p>叶子结点成为扩展结点，得到一个最优解</p><p><img src="https://i.loli.net/2021/11/16/X4e2TVIv6z8GZsO.png" style="zoom:67%;" />1q</p><p>解为(1,0,1,0)</p></blockquote><h2 id="0-1背包-3"><a href="#0-1背包-3" class="headerlink" title="0-1背包"></a>0-1背包</h2><blockquote><p><strong>例题</strong></p><p>n=3, w=[20,15,15], v=[45,25,25], c= 30</p><p><strong>解答</strong></p><ol><li><p>队列法</p><p><img src="https://i.loli.net/2021/11/14/o8DeUcu1SzGlpP6.png" style="zoom:50%;" /></p></li><li><p>优先队列法（价值大的先拓展）</p><p><img src="https://i.loli.net/2021/11/16/okxtwCMfvdA1SsO.png" style="zoom:50%;" /></p></li></ol><p>取(0,1,1)</p></blockquote><h2 id="最大团"><a href="#最大团" class="headerlink" title="最大团"></a>最大团</h2><p>完全子图（图中所有点任意连线都在原图中）</p><p>团（最大完全子图）</p><p>空子图（图中所有点任意连线不在原图中）</p><p>最大独立集（最大空子图）</p><p>补图（原图的完全图-原图，点不变）</p><p>有：若U是G的一个最大团，则U是G的补图G‘的一个最大独立集</p><p><img src="https://i.loli.net/2021/11/16/PK1ROEXvV3mJlcY.png" style="zoom:50%;" /></p><p>约束条件：是否是团（该顶点与当前团中其它顶点之间是否有边相连）</p><p>限界函数：当前团尺寸cn+剩余顶点数目r≤当前已求出最大尺寸bestn</p><p>优先级：un=cn+r</p><p>终止条件：遇到子集树中的一个叶结点（即n+1层结点）成为当前扩展结点</p><blockquote><p><strong>例题</strong></p><p><img src="https://i.loli.net/2021/11/16/ZKs1IP4xDRMmgbO.png" alt=""></p><p><strong>解答</strong></p><p>优先队列法（un大的先拓展）</p><p><img src="https://i.loli.net/2021/11/16/PMr6sCnxNp7hkGo.png" style="zoom: 67%;" /></p><p>一个可行结果为(1，1，1，0)</p></blockquote><h2 id="回溯与分支限界对比"><a href="#回溯与分支限界对比" class="headerlink" title="回溯与分支限界对比"></a>回溯与分支限界对比</h2><p><img src="https://i.loli.net/2021/11/16/QEZtAoMVafKiuY4.png" alt="回溯与分支限界对比" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>CUMT课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>分治</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心</tag>
      
      <tag>回溯</tag>
      
      <tag>分支限界</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/10/26/hello-world/"/>
    <url>/2021/10/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
