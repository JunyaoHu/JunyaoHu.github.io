<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>会议期刊介绍</title>
    <link href="/2021/12/30/%E4%BC%9A%E8%AE%AE%E6%9C%9F%E5%88%8A%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/12/30/%E4%BC%9A%E8%AE%AE%E6%9C%9F%E5%88%8A%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="衡量标准"><a href="#衡量标准" class="headerlink" title="衡量标准"></a>衡量标准</h1><p><a href="http://www.sztspi.com/archives/30937.html">摘录原文</a></p><h2 id="SCI（科学引文索引）"><a href="#SCI（科学引文索引）" class="headerlink" title="SCI（科学引文索引）"></a>SCI（科学引文索引）</h2><p>Science Citation Index，简称 SCI，由美国科学信息研究所（Institute for Scientific Information, 简称 ISI）在美国费城创办的引文数据库，创始人为情报专家尤金·加菲尔德。目前SCI由信息提供商汤森路透公司（Thomson Reuters）负责运营。</p><p>世界著名的三大科学统计与科学评价检索系统——<strong>SCI（科学引文索引）、EI（工程索引）、ISTP（科技会议录索引）</strong>中，SCI 最为重要。被SCI收录的学术期刊称为SCI期刊，收录于SCI期刊的科技论文称为SCI论文。它以布拉德福(S. C. Bradford)文献离散律理论、以加菲尔德(E. Garfield)引文分析理论为主要基础，通过论文的被引用频次等的统计，对学术期刊和科研成果进行多方位的评价研究，从而评判一个国家或地区、科研单位、高校、期刊、个人的科研产出绩效，来反映其在国际上的学术水平。</p><p>加菲尔德(E. Garfield)引文分析理论是怎么来的？要说清楚这个事情，先要了解文献与文献之间的关系。首先要知道，几乎没有一篇文章是独立存在的，里面有一部分重要的内容就是“参考文献（References）”，这让科学研究以“站在巨人的肩膀上”快速方展。所以文章与文章之间就有了错综复杂相互引用的关系，就好像Facebook上的人际关系网一样，文章之间也有引用关系网，总结起来有四种关系：<strong>你引用我（Cited）、你被我引用（Citing）、咱俩互不引用但说的事儿相关（Relavant）、完全没关系</strong></p><p>然后加菲尔德(E. Garfield)就这些关系提出了一种新的研究理论，利用文章间的引用关系可以对一个Idea做三个维度的扩展研究。</p><p>比如你先找到了一篇你认为非常感兴趣的文章A，发现A引用B，B又引用了C … 这个维度就是“越查越深（早）”(也就是这篇文章的引文)；如果发现从A被B引用，B又被C引用…这个维度就是“越查越新”（施引）；如果发现A与B、C都没有互引但很相关，这个维度就是“越查越广”。这三个维度很好地保证了科研的完整性，所以基于这个理论，加菲尔德(E. Garfield)搞了个机构叫ISI（美国科学信息研究所），把论文的引用关系梳理清楚，大大地提高了科研人员的研究效率。</p><p>这就不得不说大名鼎鼎的数据库就叫“<strong>Web of Science</strong>”，里面按学科和类型分了好几个库，期刊方面有：<strong>理工科的叫SCI（Science Citation Index，科学引文索引）</strong>，社会科学的叫SSCI（Social Sciences Citation Index，社会科学引文索引），艺术人文的叫AHCI（Arts &amp; Humanities Citation Index，艺术与人文引文索引）</p><h2 id="影响因子IF"><a href="#影响因子IF" class="headerlink" title="影响因子IF"></a>影响因子IF</h2><p>ISI（美国科学信息研究所）在早期把这些引用关系进行了排名，基于“谁被引用得多，谁的质量就高”这种想法，创立了一个概念叫“影响因子”。</p><p>具体来说，影响因子（Impact Factor，IF）是汤森路透（Thomson Reuters）出品的期刊引证报告（Journal Citation Reports，JCR）中的一项数据。</p><p>影响因子=前两年所发论文在第三年被引用次数/该期刊前两年发表论文总数。</p><p>影响因子实质上是期刊论文的平均被引率，用来衡量期刊的质量（是衡量期刊的，也就是你论文发表的位置的）和影响力。影响因子的高低，不仅取决于期刊论文被引用次数的多少，也取决于期刊所发表论文的数量。影响因子一般取值范围为1~5，呈动态变化。</p><p>然后把引用量最高的期刊分不同学科做了一个排行榜，这就形成了“核心期刊”的概念，你经常听到的“SCI核心期刊”就是在Web of Science中，理工科领域被引用次数最多的一些期刊（注意是期刊不是文章）。</p><p>总结一下：</p><p>1）文献与文献之间存在相互引用的关系；</p><p>2）Web of Science基于这种关系做了一个数据库，可以从深、新、广三个维度查文献，SCI是其中一个理工科集合；</p><p>3）在这个数据库里按引用量做了一个排行榜，产生了“核心期刊”的概念，这个概念被中国学术界广泛和过度的运用。</p><p>最后再提醒一点，Web of Science数据库最大地价值是用三个维度查找相关文献来做科研，而不是查“核心期刊”。</p><p>本来影响因子只是评价期刊的一个指标，后来南京大学有一个老师就在国内大力推崇这种评价体系，导致后来发SCI期刊文章成了评职称的重要甚至唯一指标，用着用着被妖魔化了，出了好多技巧专门研究怎么发SCI论文，有相当一部分违背了科学研究的本意。现在国外早已不再使用SCI为单一指标来评价学术，还会考虑比如社交媒体的影响力。</p><h2 id="期刊分区"><a href="#期刊分区" class="headerlink" title="期刊分区"></a>期刊分区</h2><p>分区（Quartile）是指将SCI期刊领域和学术影响力分类。主流参考的SCI分区依据主要有汤森路透JCR以及中科院JCR分区表。</p><p>汤森路透JCR分区将把某一个学科的所有期刊都按照上一年的影响因子降序排列，然后平均4等分(各25%)，分为Q1（1%-25%），Q2（26%-50%），Q3（51%-75%），Q4（76%-100%）。</p><p>中科院JCR分区表根据该SCI期刊的三年平均IF，先将SCI期刊按照所属领域分为14个大类和176个小类，再将同一学科所有期刊按照该年的IF降序排列，分为一区（1%-5%），二区（6%-20%），三区（21%-50%），四区（51%-100%）。中科院一区的也是Top期刊，一般而言，发表在一区和二区的SCI论文，通常被认为是该学科领域的比较重要的成果。</p><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>中国采用的核心有多种，其中最受认可的是三大核心：<strong>北京大学图书馆“中文核心期刊”、南京大学“中文社会科学引文索引（CSSCI）来源期刊”、中国科学技术信息研究所“中国科技论文统计源期刊”（又称“中国科技核心期刊”</strong>）。</p><p>其中以中文核期刊和科技核心期刊认可度最高，晋升职称常说的核心也指的是这两种，如果一个期刊同时被这两家机构评为核心就称为双核心。CSSCI每两年评选一次，而北大核心每四年评选一次。</p><h1 id="期刊会议"><a href="#期刊会议" class="headerlink" title="期刊会议"></a>期刊会议</h1><p><a href="https://www.ccf.org.cn/c/2019-04-25/663625.shtml">中国计算机学会推荐国际学术会议和期刊目录</a></p><h2 id="人工智能的顶刊-顶会"><a href="#人工智能的顶刊-顶会" class="headerlink" title="人工智能的顶刊/顶会"></a>人工智能的顶刊/顶会</h2><p>查阅期刊IF：<a href="https://www.letpub.com.cn/index.php?page=journalapp">https://www.letpub.com.cn/index.php?page=journalapp</a></p><p>中国计算机学会推荐国际学术刊物(人工智能)（A）</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">全称</th><th style="text-align:center">出版社</th><th>地址</th></tr></thead><tbody><tr><td style="text-align:center">AI</td><td style="text-align:center">Artificial Intelligence</td><td style="text-align:center">Elsevier</td><td><a href="http://dblp.uni-trier.de/db/journals/ai/">http://dblp.uni-trier.de/db/journals/ai/</a></td></tr><tr><td style="text-align:center">TPAMI</td><td style="text-align:center">IEEE Trans on Pattern Analysis and Machine Intelligence</td><td style="text-align:center">IEEE</td><td><a href="http://dblp.uni-trier.de/db/journals/pami/">http://dblp.uni-trier.de/db/journals/pami/</a></td></tr><tr><td style="text-align:center">IJCV</td><td style="text-align:center">International Journal of Computer Vision</td><td style="text-align:center">Springer</td><td><a href="http://dblp.uni-trier.de/db/journals/ijcv/">http://dblp.uni-trier.de/db/journals/ijcv/</a></td></tr><tr><td style="text-align:center">JMLR</td><td style="text-align:center">International Journal of Computer Vision</td><td style="text-align:center">MIT Press</td><td><a href="http://dblp.uni-trier.de/db/journals/ijcv/">http://dblp.uni-trier.de/db/journals/ijcv/</a></td></tr></tbody></table></div><p>中国计算机学会推荐国际学术会议(人工智能)（A）</p><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">全称</th><th style="text-align:center">出版社</th><th>地址</th></tr></thead><tbody><tr><td style="text-align:center">AAAI</td><td style="text-align:center">AAAI Conference on Artificial Intelligence</td><td style="text-align:center">AAAI</td><td><a href="http://dblp.uni-trier.de/db/conf/aaai/">http://dblp.uni-trier.de/db/conf/aaai/</a></td></tr><tr><td style="text-align:center">NeurIPS</td><td style="text-align:center">Annual Conference on Neural Information Processing Systems</td><td style="text-align:center">MIT Press</td><td><a href="http://dblp.uni-trier.de/db/conf/nips/">http://dblp.uni-trier.de/db/conf/nips/</a></td></tr><tr><td style="text-align:center">ACL</td><td style="text-align:center">Annual Meeting of the Association for Computational Linguistics</td><td style="text-align:center">ACL</td><td><a href="http://dblp.uni-trier.de/db/conf/acl/">http://dblp.uni-trier.de/db/conf/acl/</a></td></tr><tr><td style="text-align:center">CVPR</td><td style="text-align:center">EEE Conference on Computer Vision and Pattern Recognition</td><td style="text-align:center">IEEE</td><td><a href="http://dblp.uni-trier.de/db/conf/cvpr/">http://dblp.uni-trier.de/db/conf/cvpr/</a></td></tr><tr><td style="text-align:center">ICCV</td><td style="text-align:center">International Conference on Computer Vision</td><td style="text-align:center">IEEE</td><td><a href="http://dblp.uni-trier.de/db/conf/iccv/">http://dblp.uni-trier.de/db/conf/iccv/</a></td></tr><tr><td style="text-align:center">ICML</td><td style="text-align:center">International Conference on Machine Learning</td><td style="text-align:center">ACM</td><td><a href="http://dblp.uni-trier.de/db/conf/icml/">http://dblp.uni-trier.de/db/conf/icml/</a></td></tr><tr><td style="text-align:center">IJCAI</td><td style="text-align:center">International Joint Conference on Artificial Intelligence</td><td style="text-align:center">Morgan Kaufmann</td><td><a href="http://dblp.uni-trier.de/db/conf/ijcai/">http://dblp.uni-trier.de/db/conf/ijcai/</a></td></tr></tbody></table></div><h2 id="计算机技术核心期刊大全（中国）"><a href="#计算机技术核心期刊大全（中国）" class="headerlink" title="计算机技术核心期刊大全（中国）"></a>计算机技术核心期刊大全（中国）</h2><ul><li><p>计算机学报<br>简介：《计算机学报》是中国计算机领域的权威学术刊物。 其宗旨是报道我国计算机科学和技术领域最高水平的科研成果。 《计算机学报》创立于1978年，以中文编辑形式与读者见面，同时以英文摘要形式向国际各大检索系统提供基本内容介绍。 本刊是中国计算机领域的代表性学术刊物，作为科学研究档案，代表了计算机领域各研究阶段的水平。</p><p>收录：北京大学《中文核心期刊总览》EI 工程索引(美)(2018)CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>计算机学报<br>简介：《计算机学报》是中国计算机领域的权威学术刊物。 其宗旨是报道我国计算机科学和技术领域最高水平的科研成果。 《计算机学报》创立于1978年，以中文编辑形式与读者见面，同时以英文摘要形式向国际各大检索系统提供基本内容介绍。 本刊是中国计算机领域的代表性学术刊物，作为科学研究档案，代表了计算机领域各研究阶段的水平。</p><p>收录：北京大学《中文核心期刊总览》EI 工程索引(美)(2018)CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>自动化学报<br>简介：《自动化学报》 (月刊)创刊于1963年，是中国自动化学会、中国科学院自动化研究所共同主办的高级学术期刊。 刊载自动化科学和技术领域的高水平理论性和应用性的科研成果。 内容如下：1)自动控制2 )系统理论和系统工程3 )自动化工过程技术和应用4 )自动化系统计算机辅助技术5 )机器人6 )人工智能和智能控制7 )模式识别和图像处理8 )信息处理和信息服务9 )基于网络的自动化等。</p><p>收录：北京大学《中文核心期刊总览》EI 工程索引(美)(2018)CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>简介：《计算机研究与发展》 (月刊)创刊于1958年，中国科学医院计算技术研究所，中国计算机学会主办。 刊载内容： 计算机科学技术领域高水平的学术论文，最新科研成果和重大应用成果。 刊载内容：评估、计算机基础理论、软件技术、信息安全、计算机网络、图形图像、体系结构、人工智能、计算机应用、数据库技术、存储技术和计算机相关领域。</p><p>收录：北京大学《中文核心期刊总览》EI 工程索引(美)(2018)CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>控制与决策<br>简介：《控制与决策》创刊于1986年，由教育部主管、东北大学主办。本刊是自动控制与管理决策领域的学术性期刊，主要刊登自动控制理论及其应用，系统理论与系统工程，决策理论与决策方法，自动化技术及其应用，人工智能与智能控制，机器人，以及自动控制与决策领域的其他重要课题。主要栏目有：综述与评论、论文与报告、短文、信息与动态等。</p><p>收录：北京大学《中文核心期刊总览》EI 工程索引(美)(2018)CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>中国图象图形学报<br>简介：《中国图象图形学报》是由中国科学院遥感与数字地球研究所、中国图象图形学会、北京应用物理与计算数学研究所共同创办，是集计算机图像图形高科技理论、技术方法与应用研究成果产业化于一体的综合性学术期刊。主要刊登图像图形科学及其密切相关领域的基础研究和应用研究方面，并具有创新性的、高水平科研学术论文，论文形式主要有综述、技术报告，项目进展、学术动态、新技术评论、新产品介绍和产业化研究等。内容涉及图像分析和识别、图像理解和计算机视觉、计算机图形学、虚拟现实和增强现实、系统仿真、动漫等众多领域，同时还根据各时期的研究热点和前沿课题开设相应的主 题专栏。读者对象不从事国防、军事、航空、航天、通信、电子、汽车、农业、气象、环保、遥感、测绘、油田、建筑、交通、金融、电信、教育、医疗、影视、艺术等科技人员、企业主管及高等院校的研究生，大学生。</p><p>收录：北京大学《中文核心期刊总览》CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>计算机辅助设计与图形学学报<br>简介：创刊于1989年，是我国CAD和计算机图形学领域第一个公开出版的学术刊物，原为季刊，1996年起改为双月刊，从2000年起改为月刊。该刊以快速传播CAD与计算机图形学领域的知识与经验为目的，刊登有创新的学术论文，报导最新科研成果和学术动态，及时反映该领域发展水平与发展方向。读者对象为从事CAD和计算机图形及其他有关学科的科研、工程技术人员及高等院校师生。</p><p>收录：北京大学《中文核心期刊总览》EI 工程索引(美)(2018)CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>计算机应用研究</p><p>简介：《计算机应用研究》创刊于1984年，是由国家科技部所属四川省计算机研究院主办，北京、天津、山东、吉林、云南、贵州、安徽、河南、广西、甘肃、内蒙古等十余省市计算中心协办的计算技术类学术刊物。主要刊载内容包括本学科领域高水平的学术论文、本学科最新科研成果和重大应用成果。栏目内容涉及计算机学科新理论、计算机基础理论、算法理论研究、算法设计与分析、系统软件与软件工程技术、模式识别与人工智能、体系结构、先进计算、并行处理、数据库技术、计算机网络与通信技术、信息安全技术、计算机图像图形学及其最新热点应用技术。</p><p>收录：北京大学《中文核心期刊总览》CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>计算机科学<br>简介：《计算机科学》（Computer Science）创刊于1974年1月（月刊），由重庆西南信息有限公司（原科技部西南信息中心）主管主办，曾用刊名计算机应用与应用数学，是中国计算机学会（CCF）会刊。主要报道国内外计算机科学与技术的发展动态、涉及面广的方法论与技术、反映新苗头且能起承先启后作用的研究成果。</p><p>收录：北京大学《中文核心期刊总览》CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>计算机应用<br>简介：《计算机应用》创刊于1981年，是中国计算机学会会刊。本刊旨在介绍计算机应用技术，推动经济发展和科技进步，促进计算机应用创新的开发。 多年来，中国计算机学会一直关注着国内计算机各应用领域的专家。读者对象：计算机应用工程技术人员、大专院校师生、企事业单位管理干部、科研院所从事计算机开发应用人员、计算机公司职员等必备的工具，是启迪思维、开拓进取、更新知识、开发应用的良师益友。</p><p>收录：北京大学《中文核心期刊总览》CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>计算机工程<br>简介：《计算机工程》创刊于1975年，是中国电子科技集团公司第三十二研究所（华东计算技术研究所）和上海市计算机学会主办的学术性刊物，刊登内容： 热点与综述、人工智能与模式识别、先进计算与数据处理、网络空间安全、移动互联与通信技术、体系结构与软件技术、图形图像处理、开发研究与工程应用等。</p><p>收录：北京大学《中文核心期刊总览》CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>控制理论与应用<br>简介：《控制理论与应用》1984年创刊，是教育部主管、由华南理工大学和中科院数学与系统科学研究院联合主办的全国学术刊物。主要报道在控制理论与应用方面的高水平学术论文，特别是系统控制、最优化和自动化领域中的新兴问题、原创方法及尖端技术，为控制领域的科学家和工程师们提供一个交流最新成果的平台。主要报道系统控制科学中具有新观念、新思想的理论研究成果及其在各个领域中, 特别是高科技领域中的应用研究成果和在国民经济有关领域技术开发、技术改造中的应用成果. 内容包括: 1） 系统建模、辨识与估计; 2) 数据驱动建模与控制；3)过程控制; 4)智能控制; 5)网络控制; 6) 非线性系统控制; 7) 随机系统控制; 8) 预测控制; 9) 多智能体系统及分布式控制; 10）鲁棒与自适应控制；11) 系统优化理论与算法; 12) 混杂系统与离散事件系统; 13）工程控制系统；14）航空与航天控制系统；15）新兴战略产业中的控制系统；16）博弈论与社会网络；17）微纳与量子系统；18）模式识别与机器学习；19）智能机器人；20) 先进控制理论在实际系统中的应用; 21）系统控制科学中的其它重要问题。《控制理论与应用》的读者对象是从事控制理论与应用研究的科技人员、高校师生及其他有关人员。设置的栏目主要有: 综述与评论,长论文,论文, 短文, 书刊评介, 读者来信, 国内外学术活动信息等。</p><p>收录：北京大学《中文核心期刊总览》EI 工程索引(美)(2018)CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>模式识别与人工智能<br>简介：《模式识别与人工智能》 (双月刊)创刊于1989年，是中国自动化学会、国家智能计算机研发中心和中国科学院合肥智能机械研究所共同主办、科学</p><p>出版社出版的学术期刊。 本刊主要发表模式识别、人工智能、智能系统等研究成果和进展，旨在推动信息科学技术的发展。</p><p>收录：北京大学《中文核心期刊总览》CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>遥感技术与应用<br>简介：《遥感技术与应用》是综合性学术刊物，主要刊登国内外遥感理论、技术及应用研究领域的学术论文与综述，优先报道国内外遥感研究与应用的新技术、新理论、新方法和新成果，推动高新技术在地球科学研究及社会发展中的应用，重点介绍国家自然科学基金项目、交流国家攀登计划、攻关计划工作等科研成果。针对目前遥感领域的热点问题和发展动态，经第六届编委会讨论决定，将栏目细化调整为微波遥感、光学遥感、数据处理、模型与反演、遥感应用、专家述评、GIS、深空探测、重大项目、综述等。</p><p>收录：中国科技论文统计源期刊（CSTPCD核心库）以及中国科学引文数据库来源期刊（CSCD核心库），清华大学中国学术期刊综合评价数据库统计源期刊，被中文科技期刊数据库全文收录</p></li><li><p>国土资源遥感<br>简介：《国土资源遥感》是由中国地质调查局主管，中国自然资源航空物探遥感中心主办的技术性刊物（季刊，国内外公开发行），创刊于1989年。主要刊登实用性强的遥感、GIS及GPS（3S）技术理论及其应用论文，宣传3S技术在国土资源调查与开发、国土整治的规划与管理，环境和灾害监测，水文地质、工程地质勘查，建设工程选址、选线及城市规划等领域应用的新方法和重要成果，以从事国土资源遥感及其相关研究领域的研究人员、应用人员及大专院校有关师生为读者对象。</p><p>收录：中文核心期刊、中国科学引文数据库（CSCD）核心期刊、中国科技核心期刊、俄罗斯《文摘杂志》（AJ）收录期刊、美国化学文摘（CA2008)收录期刊、美国《乌利希期刊指南》(Ulrichsweb) 中国科技论文统计源期刊、中国学术期刊综合评价数据库统计源期刊、中国期刊全文数据库全文收录期刊</p></li><li><p>计算机科学与探索<br>简介：《计算机科学与探索》是由中国电子科技集团公司主管、华北计算技术研究所主办的国内外公开发行的高级学术期刊。报道计算机(硬件、软件)各学科具有创新性、前沿性、开拓性、探索性的科研成果。 内容包括高性能计算机、体系结构、并行处理、计算机科学更新理论、算法设计与分析、人工智能和模式识别、系统软件、软件工程、数据库、计算机网络、信息安全包括图形学和计算机辅助设计、虚拟现实、多媒体技术和交叉学科的相互渗透和新理论的推导等。</p><p>收录：北大中文核心期刊，中国科学引文数据库（CSCD）核心期刊，中国科技论文统计源期刊（中国科技核心期刊），中国学术期刊综合评价数据库（CAJCED）统计源期刊，中国科技论文与引文数据库（CSTPCD）统计源期刊，中文科技期刊数据库（VIP）收录期刊，并被 “英国《科学文摘》（SA/INSPEC）”“美国《剑桥科学文摘》（CSA）”“美国《乌利希期刊指南》（Ulrich’s PD）”“《日本科学技术振兴机构中国文献数据库》（JST）”“波兰《哥白尼索引》（IC）”收录，</p></li><li><p>信息与控制<br>简介：《信息与控制》是经中华人民共和国新闻出版总署批准，由中国科学院主管，中国科学院沈阳自动化研究所、中国自动化学会共同主办的科技类核心期刊，主要刊载信息与控制科学领域基础研究和应用基础研究方面具有创新性的、高水平的、有重要意义的研究成果，由科学出版社出版。重点关注控制科学与技术、与控制理论相关的应用信息技术在机械制造、能源电力、冶金化工、资源环境、航空工业以及国防工业等国家重要高科技和经济领域中的应用研究成果。主要内容包括：1）控制理论与控制工程；2）智能信息处理；3）人工智能与模式识别；4）先进控制与优化技术；5）企业信息管理与信息系统；6）工业控制网络与系统；7）人机系统等。</p><p>收录：北京大学《中文核心期刊总览》CSCD 中国科学引文数据库（2017-2018年度）（含扩展版）统计源核心期刊（中国科技论文核心期刊）</p></li><li><p>智能系统学报<br>简介：《智能系统学报》是由中国人工智能学会和哈尔滨工程大学联合主办，是中国人工智能学会会刊。主要刊登神经网络与神经计算、智能信息处理、自然语言理解、智能系统工程、机器翻译、复杂系统、机器学习、知识工程与分布式智能、机器人、智能制造、粗糙集与软计算、免疫系统、机器感知与虚拟现实、智能控制与智能管理、可拓工程、人工智能基础等内容。</p><p>收录：美国《剑桥科学文摘》、英国《科学文摘》、中文核心期刊、中国科学引文数据库（CSCD）来源期刊、中国科技核心期刊等重要数据库收录。</p></li><li><p>计算机应用与软件<br>简介：《计算机应用与软件》创刊于1984年，由上海市计算技术研究所和上海计算机软件技术开发中心共同主办。注重刊登反映计算机应用和软件技术开发应用方面的新理论、新方法、新技术以及创新应用的文章。主要栏目包括：最新技术动态、综合评述、软件技术与研究、数据工程、应用技术与研究、网络与通信、多媒体技术应用、人工智能与识别、图像处理与应用、嵌入式软件与应用、算法、安全技术、信息技术交流及其他相关内容。主要面向从事计算机应用和软件技术开发的科研人员、工程技术人员、高校师生等。</p><p>收录：《中国科技论文统计源期刊（中国科技核心期刊）》、《中国学术期刊综合评价数据库来源期刊》、《万方数据—数字化期刊群全文收录期刊》、《中文科技期刊数据库（全文版）收录期刊》、《中国科学引文数据库来源期刊（2015-2016）》、美国《剑桥科学文摘》收录期刊、美国《乌利希国际期刊指南》等数据库收录。</p></li><li><p>计算机工程与科学<br>简介：《计算机工程与科学》隶属于中国人民解放军国防科技大学计算机学院，是计算机类综合性学术刊物,1973年创刊,是中国计算机学会会刊，由国防科技大学计算机学院主办。注重刊登计算机学科在理论、工程与应用等方面的研究论文、技术报告和科研成果，主要涉及计算机体系结构、并行处理、超级计算、人工智能、软件工程、计算机仿真、多媒体与可视化、数据库、计算机网络与分布式处理、计算机安全与保密、中文信息处理、微机开发与应用及其他相关内容。</p><p>收录：中文核心期刊、中国科学引文数据库扩展库来源期刊(CSCD扩展库来源期刊)、中国科技信息研究所中国科技论文统计分析源期刊（科技核心期刊）、中国学术期刊（光盘版）全文入编期刊、万方数据库全文入编期刊、英国《科学文摘》（INSPEC）、美国《史蒂芬斯全文数据库》（EBSCO host）、美国《乌利希期刊指南（网络版）》；《计算机工程与科学》在美国《科学引文索引（扩展库）》（SCIE）</p></li><li><p>控制工程<br>简介：《控制工程》是教育部科技司主管、东北大学主办的学术类期刊。常设栏目： 工业过程管理与决策系统、决策与控制一体化系统、工业过程及控制系统、运动体控制系统、安全监控系统、建模与仿真系统、工业互联网系统、人工智能驱动的自动化等。主要读者对象为从事于自动化工程技术的高等院校教师、研究生，科研院所的研究人员，工矿企业的工程技术人员等。</p><p>收录：中文核心期刊，中国科技核心期刊，中国科学引文数据库核心期刊（CSCD），中国科技论文统计用刊，中国科学文献数据用刊，中国学术期刊综合评价数据库来源期刊。从2002年开始，被俄罗斯《文摘杂志》（AJ），美国《剑桥科学文摘》(CSA), 英国《科学文摘》（SA）等著名国际检索机构全文检索。</p></li></ul><p><a href="https://blog.csdn.net/qq_43060870/article/details/112448649">下载顶刊的期刊的那点事</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《Java网络编程》《JavaEE程序设计》笔记</title>
    <link href="/2021/12/30/%E3%80%8AJava%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B%E3%80%8AJavaEE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/12/30/%E3%80%8AJava%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%8B%E3%80%8AJavaEE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java语言基础"><a href="#Java语言基础" class="headerlink" title="Java语言基础"></a>Java语言基础</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li><p>标识符规则</p><ul><li>由字母、 数字、下划线、 $组成。不能由数字开头。</li><li>不能含有其他任何字符（包括空格）</li><li>不能是Java中的保留字(关键字)。</li><li>大小写敏感，长度无限制。</li></ul></li><li><p>变量类型</p><ul><li>8种基本数据类型（byte1, short2, int4, long8, float4, double8, char2, boolean）</li><li>构造数据类型（类）</li></ul></li><li><p>常量类型</p><ul><li>数值常量</li><li>符号常量：<code>final int a = 10;</code>，值一旦确定不可更改，类静态成员常量只能在定义时初始化</li><li>注意事项<ul><li>一个整型常量在机器中默认以int类型存储</li><li>一个实型常量在机器中默认以double类型存储</li><li>十进制表示法小数点的两侧都必须有数字</li><li>科学表示法尾数必须有，但小数部分可无，阶码必须是整数</li><li>不可将布尔类型看做整型值。</li></ul></li></ul></li></ul><h2 id="运算符及表达式"><a href="#运算符及表达式" class="headerlink" title="运算符及表达式"></a>运算符及表达式</h2><ul><li><p>自增自减</p><ul><li>只能用于变量，而不能用于常量或表达式</li><li><code>a = 5; a--+10;</code>表达式的值为15，a变为4</li></ul></li><li><p>除法</p><ul><li>整数相除，截尾法取整</li><li>浮点数相除，是通常意义的除法</li></ul></li><li><p>除余</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">5</span>%<span class="hljs-number">2</span>=<span class="hljs-number">1</span><br><span class="hljs-number">5.2</span>%<span class="hljs-number">2</span>=<span class="hljs-number">1.2</span><br><span class="hljs-number">5.2</span>%<span class="hljs-number">2.2</span>=<span class="hljs-number">0.8</span> <br><span class="hljs-number">10</span>%-<span class="hljs-number">4</span>=<span class="hljs-number">2</span><br>-<span class="hljs-number">10</span>%-<span class="hljs-number">4</span>=-<span class="hljs-number">2</span> <br></code></pre></td></tr></table></figure></li><li><p>如果整数相除或取模，第二个操作数为0，编译无错，运行会出错。如果浮点数相除，第二个操作数为0，结果为Infinity，0.0/0除外是NaN。如果浮点数取模，第二个操作数为0，结果为NaN</p></li><li><p>字符串连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//A的ASCII码是65，a的ASCII码是97(65+32)</span><br><span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>        <span class="hljs-comment">//98</span><br><span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-number">2</span>+<span class="hljs-number">2.5</span>    <span class="hljs-comment">//69.5</span><br><span class="hljs-string">&quot;&quot;</span>+<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>     <span class="hljs-comment">//a1</span><br><span class="hljs-string">&quot;abc&quot;</span>+<span class="hljs-number">1</span>+<span class="hljs-number">2.3</span>  <span class="hljs-comment">//abc12.2</span><br><span class="hljs-number">1</span>+<span class="hljs-number">2.3</span>+<span class="hljs-string">&quot;abc&quot;</span>  <span class="hljs-comment">//3.3abc</span><br><span class="hljs-number">1</span>+<span class="hljs-string">&quot;abc&quot;</span> +<span class="hljs-number">2.3</span> <span class="hljs-comment">//1abc2.3</span><br></code></pre></td></tr></table></figure></li><li><p>对象运算符用来确定一对象是否是某一指定类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Test t1 = <span class="hljs-keyword">new</span> Test();<br><span class="hljs-keyword">if</span>(t1 <span class="hljs-keyword">instanceof</span> Test) System.out.println(<span class="hljs-string">&quot;Yes&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>逻辑运算符，&amp;和|没有短路逻辑，&amp;&amp;和||有</p></li><li><p>移位之前先把移的位数与被移位的位数求余数，然后移动这个位数</p></li><li><p>优先级</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">优先级</th><th style="text-align:center">运算符</th><th style="text-align:center">类型</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">()</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">+、-  、++、—、 !、~</td><td style="text-align:center">单目运算符</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">*、/、%</td><td style="text-align:center">算术运算符</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">+、-</td><td style="text-align:center">算术运算符</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">&lt;&lt;、&gt;&gt;  、&gt;&gt;&gt;</td><td style="text-align:center">移位运算符</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">&lt;、&lt;=、&gt;、&gt;=</td><td style="text-align:center">关系运算符</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">==、!=</td><td style="text-align:center">关系运算符</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">逻辑运算符</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">&#124;&#124;</td><td style="text-align:center">逻辑运算符</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">?:</td><td style="text-align:center">条件运算符</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">=、+=、-=、*=、/=、%=、^=</td><td style="text-align:center">赋值运算符</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">&amp;=、&#124;=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=</td><td style="text-align:center">赋值运算符</td></tr></tbody></table></div><ul><li><p>一个实型常量在机器中默认以double类型存储。实型常量后加后缀F或f在机器中以float类型存储。</p></li><li><p>数据类型转换</p><ul><li><p>自动转换，自动把精度较低的类型转换为另一种精度较高的类型，如果byte、short、char在一起运算时，会先将这些值转换为int型。再进行运算，结果为int型。</p></li><li><p>手动强制转换</p><ul><li>强制类型转换可能造成信息的丢失</li><li>布尔型与其它基本类型之间不能转换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> i; <span class="hljs-keyword">byte</span> b,c;<br>b=(<span class="hljs-keyword">byte</span>)<span class="hljs-number">345</span>;      <span class="hljs-comment">//上机测试知b得到89(345%256)  </span><br>c=(<span class="hljs-keyword">byte</span>)<span class="hljs-number">356</span>;      <span class="hljs-comment">//上机测试知c得到100(356%256)</span><br>i=(<span class="hljs-keyword">int</span>)(<span class="hljs-number">3.8</span>+<span class="hljs-number">6</span>);   <span class="hljs-comment">//截尾法</span><br></code></pre></td></tr></table></figure><ul><li>TIPS<ul><li><strong>在运算过程中，运算的结果至少是int型</strong>，即如果参与运算的两个数级别比int型低或是int型，则结果为int型</li><li>参与运算的数据如果有一个级别比int型高，则运算结果的类型与类型级别高的数相同</li><li>参与运算的两个数据如果类型不一样，会先把低级的数据转换成高级的类型的数据后再作运算，结果是高级的类型</li></ul></li></ul></li><li><p>隐含强制转换</p><ul><li>把int类型的常量赋给byte、short变量时不需要强制类型转换</li><li>把int类型的变量赋给byte、short类型的变量时必须强制转换，否则会出错</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">float</span> x=<span class="hljs-number">3.3f</span>;<br><span class="hljs-keyword">double</span> y=<span class="hljs-number">2.9</span>;<br><span class="hljs-keyword">byte</span> a=<span class="hljs-number">5</span>;<br>x+(<span class="hljs-keyword">int</span>)y/<span class="hljs-number">3</span>*a;    <span class="hljs-comment">//float</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><ul><li><p>标准输入输出</p><ul><li><p><code>System.out</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println();<br>System.out.print();<br></code></pre></td></tr></table></figure><ul><li><code>System.in</code>读一个字节，<strong>需要捕获异常</strong><code>IOException</code></li><li><code>int read()</code>从流中读取一个字节并将该字节作为整数返回,若没有数据则返回-1 </li><li><code>int read(byte b[])</code> 从流中读取多个字节放到b中, 返回实际读取到的字节数 </li><li><code>int read(byte b[],int off,int len)</code> 从流中读取最多len字节的数据, 放到数组b的下标off开始的单元中，返回读取到的字节数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ReadChar.java </span><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadChar</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">char</span> ch=(<span class="hljs-keyword">char</span>)System.in.read();<br>            System.out.println(ch);    <br>        &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>e.printStackTrace();<br>&#125;<br>   &#125; <br>&#125;<br><br><span class="hljs-comment">//ReadString.java</span><br><span class="hljs-keyword">import</span> java.io.*;    <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadString</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> c;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br>                c = (<span class="hljs-keyword">char</span>)System.in.read();<br>                System.out.print(c);<br>            &#125; <span class="hljs-keyword">while</span>(c!=<span class="hljs-string">&#x27;\n&#x27;</span>);<br>        &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//ReadStringOrInt.java </span><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadStringOrInt</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br><span class="hljs-keyword">byte</span> buf[]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">20</span>];  <br>String str;<br>        <span class="hljs-keyword">int</span> anInt;         <br>    <span class="hljs-keyword">try</span> &#123;    <br>System.in.read(buf);  <br>str=<span class="hljs-keyword">new</span> String(buf);<br>anInt=Integer<br>                .parseInt(str.trim()); <br>            <span class="hljs-comment">//trim必须</span><br>        &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            e.printStackTrace(); <br>&#125; <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>Scanner</code></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Scanner sc = new Scanner(System.in)<span class="hljs-comment">;</span><br><span class="hljs-attribute">i</span> = sc.nextInt()<span class="hljs-comment">;</span><br><span class="hljs-attribute">i</span> = sc.next()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>选择、循环、跳转等语句没啥说的跟其他语言差不多</p><ul><li><code>for</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//一种特殊的for循环</span><br><span class="hljs-keyword">int</span>[] scores = &#123;<span class="hljs-number">89</span>, <span class="hljs-number">72</span>, <span class="hljs-number">64</span>, <span class="hljs-number">58</span>, <span class="hljs-number">93</span>&#125;;<br><span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> sco: scores ) &#123;<br>    System.out.println(sco);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>switch</code></p><p>注意<code>break</code></p></li></ul></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><p>声明\创建数组空间\初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] list1; list1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">int</span>[] list2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">int</span>[] a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>]; b[<span class="hljs-number">0</span>]=<span class="hljs-number">8</span>; b[<span class="hljs-number">1</span>]=<span class="hljs-number">9</span>;<br><span class="hljs-keyword">int</span>[] c; c = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">int</span>[] d = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-comment">//WRONG</span><br><span class="hljs-comment">//int[] a; a = &#123;1,2,3,4&#125;; </span><br><span class="hljs-comment">//int a[5]; </span><br><br><span class="hljs-keyword">int</span>[][] a; a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<br><span class="hljs-keyword">int</span>[][] b; b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>][];<br><span class="hljs-keyword">int</span>[][] c = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];<br><span class="hljs-keyword">int</span>[][] d =&#123;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;&#125;;<br><span class="hljs-keyword">int</span>[][] e = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;&#125;;<br><br><span class="hljs-keyword">int</span>[][] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>][];<br>f[<span class="hljs-number">0</span>]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>];<br>f[<span class="hljs-number">1</span>]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">//不规则数组</span><br></code></pre></td></tr></table></figure><p>ps: 如果括号写在后面会提示是C样式的定义，建议统一写在前面，但是写在前面还是写在后面都是没有影响的</p></li></ul><h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//类首说明</span><br>[修饰符] <span class="hljs-class"><span class="hljs-keyword">class</span> 类名 [<span class="hljs-keyword">extends</span>] [<span class="hljs-keyword">implements</span>]</span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-comment">//类体</span><br>[成员变量说明]<br>[构造方法说明]<br>[静态初始化说明]<br>[成员方法说明]<br>&#125;；<br></code></pre></td></tr></table></figure><h2 id="类首说明"><a href="#类首说明" class="headerlink" title="类首说明"></a>类首说明</h2><ul><li>修饰符<ul><li>访问权限修饰符<code>缺省/public</code></li><li>抽象类<code>abstract</code></li><li>最终类<code>final</code></li></ul></li><li><code>extends</code>Java中一个类最多能继承一个类（单继承）</li><li><code>implements</code>接口名可以有多个</li></ul><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><ul><li>访问权限修饰符<code>public&gt;protected&gt;缺省&gt;private</code></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">同一个类</th><th style="text-align:center">不同包的子类</th><th style="text-align:center">同一个包中</th><th style="text-align:center">不同包中的非子类</th></tr></thead><tbody><tr><td style="text-align:center">缺省friendly</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">public</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table></div><p>tips</p><ul><li>具有继承关系的子类可以继承父类的一些成员变量，即可以<strong>不创建对象</strong>就可以直接访问。如果是同一个包的子类可以继承到缺省/public/protected修饰的变量，如果是不同的包的子类就只能继承到public/protected的；</li><li>如果是其他类，不管是一个包还是不在一个包，都要创建该类的对象才能引用</li><li>如果是main方法，不管是本类还是非本类，要访问实例变量都要创建对象，可以引申到其他所有的类方法中</li><li>私有成员只能在本类中访问，如果在main方法中访问私有成员，必须创建对象</li><li><p>如果是创建对象，不同包的子类中定义的父类的对象只能调用public，不同包的子类中定义的子类的对象可以调用public、protected</p></li><li><p><code>static</code></p><p>static修饰的成员变量称为类变量（静态变量）；不用static修饰的成员变量又叫对象变量（实例变量）。可以通过类来访问静态成员变量，也可以通过该类的对象访问静态成员变量。</p></li><li><p><code>final</code></p><p>无论是实例变量，还是类变量，都可以被说明成常量。final修饰符和static修饰符并不冲突</p><ul><li>类常量，一定要在定义时就给定初始值，声明赋值不分开</li><li>对象常量，一个final成员变量，没有static修饰，不同的对象可以有不同的值。一定要给初始值，但可有两种方法：（1）在定义变量时赋初始值（声明赋值可分开）（2）在每一个构造函数中进行赋值</li></ul></li><li><p><code>transient</code>和<code>volatile</code></p></li><li><p>成员变量的使用</p><ul><li>类内部：只用变量名即可访问（类内的静态方法例如main访问对象变量例外）</li><li>类外部：对象变量要构造对象、类变量2种都行（static）</li></ul></li></ul><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><ul><li><p>成员方法首部声明</p><p><code>[方法修饰] 返回类型 方法名（[形参]）[throws异常]</code></p><ul><li>访问修饰符： 缺省/public/protected/private</li><li>非访问修饰符：static/abstract/final/native/synchronized</li></ul></li><li><p>成员方法调用</p><ul><li>内部调用：直接</li><li>外部调用：类方法（static）、对象方法<ul><li>在类方法中不能直接引用对象变量。在<strong>类方法（static）中不能使用super、this关键字</strong>。类方法不能直接调用类中的对象方法。</li><li>对象方法可以引用对象变量，也可以引用类变量。对象方法中可以使用supper、this关键字。对象方法中可以调用类方法。</li></ul></li></ul></li><li>方法的重载<ul><li>或者参数个数不同，或者参数类型不同，或者参数类型顺序不同</li></ul></li></ul><h2 id="构造方法、对象创建"><a href="#构造方法、对象创建" class="headerlink" title="构造方法、对象创建"></a>构造方法、对象创建</h2><ul><li><p>对象成员变量初始化</p><ol><li>自动初始化</li><li>通过一个成员方法显示地初始化为其他值</li><li>定义构造方法时初始化</li></ol></li><li><p>构造方法</p><p><code>[修饰符] 方法名（[形参]）[throws异常] &#123;方法体&#125;</code></p><ul><li>编译器内部机理<ol><li>为对象分配内存空间(堆)；</li><li>按缺省值初始化对象中的实例变量的值；</li><li>调用对象的构造方法(可以在构造方法中初始化其他的值)。</li></ol></li><li>构造方法重载</li></ul></li><li><p>对象创建</p><ul><li>对象的声名</li><li>对象的实例化</li><li>对象的初始化</li></ul><p>ps：对象是引用型变量，new以类为模板，开辟空间并执行相应的构造方法，完成对象的实例化和初始化，并返回该对象的一个引用（即该对象所在的内存首地址)</p></li><li><p>对象的成员变量及方法的访问</p></li><li><p>this</p><ul><li>在方法及构造方法中，可以使用this来访问对象的属性和方法。构造方法中，用this调用另一构造方法。</li><li>通过this不仅可以引用该类中定义的变量和方法，还可以引用该类的父类中定义的成员变量和方法。</li><li>在所有的非static方法中，都隐含了一个参数this。<strong>而static方法中，不能使用this。</strong></li></ul></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><code>class 新的子类名 extends 继承的父类名(必须有且只能一个)</code></p><ul><li><p>Object类是Java中所有类的直接父类或间接父类。 </p></li><li><p>子类特性：子类拥有其父类的<strong>所有</strong>属性和方法。但父类中说明为private的属性和方法，子类不可直接访问。子类可以对父类的方法覆盖或重载。</p></li><li><p>属性的继承、隐藏和添加</p><ul><li>子类可以继承父类的所有属性（只要该属性没有private修饰）</li><li>子类重新定义一个与父类那里继承来的成员变量完全相同的变量，就称作属性的隐藏。</li><li>在定义子类时，加上的新的属性变量，就可以使子类比父类多一些属性</li></ul></li><li><p>方法的继承、覆盖、重载和添加</p><ul><li><p>父类的非私有方法也可以被子类自动继承</p></li><li><p>覆盖：在子类中定义的方法和父类中的方法的首部是一样的，包括方法名、参数列表、返回类型和异常抛出。但方法体的实现改变了。</p><p>ps：覆盖的方法的首部必须要和被覆盖的方法的首部完全匹配、返回值类型一致，才能达到覆盖的效果。覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</p></li><li><p>重载：方法名相同，但参数列表不同（实际是相当于在子类中新加了一个方法）</p><p>ps：在使用重载时只能通过不同的参数表样式。不能通过访问权限、返回类型、抛出的异常进行重载。被重载的方法不能为private，否则在其子类中只是新定义了一个方法。</p></li><li><p>添加</p></li><li><p>ps：在继承机制中，不允许在子类中降低成员(包括变量和方法)的访问权限（访问权限大小关系是private&lt;缺省&lt;protected&lt;public）。即如果一个方法在父类中是protected的，那么在子类中要重载或覆盖该方法时，就不能把该方法改成是缺省或private，否则会出现编译错误。</p></li></ul></li><li><p><strong>向上转型和向下转型</strong></p><ul><li><p>向上转型</p><ul><li><p>用父类的引用变量去引用子类的实例，这是允许的。当向上转型之后，父类引用变量可以访问子类中属于父类的属性和方法，但是不能访问子类独有的属性和方法。</p></li><li><p>向上转型，在运行时，会遗忘子类对象中与父类对象中不同的方法。也会覆盖与父类中相同的方法（重写）。</p></li><li><p><strong>向上转型之后的方法调用问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Show</span><span class="hljs-params">(D obj)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;(A-D)&quot;</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Show</span><span class="hljs-params">(A obj)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;(A-A)&quot;</span>); &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Show</span><span class="hljs-params">(B obj)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;(B-B)&quot;</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Show</span><span class="hljs-params">(A obj)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;(B-A)&quot;</span>); &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Show</span><span class="hljs-params">(B obj)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;(C-B)&quot;</span>); &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Show</span><span class="hljs-params">(D obj)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;(D-D)&quot;</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Show</span><span class="hljs-params">(B obj)</span> </span>&#123; <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;(D-B)&quot;</span>); &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mainTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>       A a1 = <span class="hljs-keyword">new</span> A();<br>       A a2 = <span class="hljs-keyword">new</span> B();<br>       B b = <span class="hljs-keyword">new</span> B();<br>       C c = <span class="hljs-keyword">new</span> C();<br>       D d = <span class="hljs-keyword">new</span> D();<br>       System.out.println(a1.Show(b)); <span class="hljs-comment">//(A-A)</span><br>       System.out.println(a1.Show(c)); <span class="hljs-comment">//(A-A)</span><br>       System.out.println(a1.Show(d)); <span class="hljs-comment">//(A-D)</span><br>       System.out.println(a2.Show(b)); <span class="hljs-comment">//(B-A)</span><br>       System.out.println(a2.Show(c)); <span class="hljs-comment">//(B-A)</span><br>       System.out.println(a2.Show(d)); <span class="hljs-comment">//(A-D)</span><br>       System.out.println(b.Show(b));  <span class="hljs-comment">//(B-B)</span><br>       System.out.println(b.Show(c));  <span class="hljs-comment">//(B-B)</span><br>       System.out.println(b.Show(d));  <span class="hljs-comment">//(A-D)</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//先改写类方法，再直接判断</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li>向下转型<ul><li>并不是所有的对象都可以向下转型，<strong>只有当这个对象原本就是子类对象通过向上转型得到的时候才能够成功转型</strong></li></ul></li></ul><ul><li><p>super</p><ul><li><p>使用情况：子类隐藏了超类中的变量或方法，而在程序中又要使用超类中被隐藏的变量或方法时使用。或者在子类的构造方法中引用超类的构造方法时使用。</p></li><li><p><strong>构造方法是不能继承的</strong>，因为继承意味着与父类的构造方法同名，但显然子类的构造方法不可能与父类的构造方法同名。但是子类的构造方法一定会调用父类的构造方法，以此类推，将继承阶层串联起来，使每个父类的构造方法皆被调用。（构造方法不能继承并不意味着子类不能调用父类的构造方法，且可以显式调用，放在第一句）</p></li><li><p>注意事项</p><ul><li>通过super不仅可以访问直接父类中定义的属性和方法，还可以访问间接父类中定义的属性和方法。</li><li>由于它指的是父类对象，所以super不能在static环境中使用，包括类变量、类方法和static语句块。</li><li>使用super不能访问本类定义的属性和方法</li><li>在构造方法中使用super时，super语句必须放在第一句 </li><li>在子类的构造方法中，super可以不明确使用，也可以明确使用。</li><li>建议：在写多个继承关系的类时，尽量在子类的构造方法中明确使用super调用父类的构造方法，<strong>继承默认调用super（）</strong></li></ul></li><li><p>构造方法的调用顺序</p><ul><li>首先调用父类的构造方法。这个步骤会反复递归，使继承阶层的<strong>根源最先</strong>被构建，然后是次一层的子类，直至最末一层子类为止；</li><li>根据各个成员的<strong>声明顺序</strong>，执行成员变量的初始化赋值；</li><li>执行该构造方法中的各语句。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;base&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Base</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Base(): &quot;</span> + name);<br>        tellName();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tellName</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Base tell name: &quot;</span> + name);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name = <span class="hljs-string">&quot;derived&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Derived</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Derived():&quot;</span>+ name);<br>        tellName();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tellName</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Derived tell name: &quot;</span> + name);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">new</span> Derived();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*输出</span><br><span class="hljs-comment">Base(): base</span><br><span class="hljs-comment">Derived tell name: null</span><br><span class="hljs-comment">Derived():derived</span><br><span class="hljs-comment">Derived tell name: derived</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>父类对象与子类对象的转换</p><ul><li>原则<ul><li>子类对象转为父类对象时，可以是显示的或隐式的，子类对象直接向父类对象赋值；</li><li>父类对象不能被任意的转换成某一子类的对象，只有父类对象指向的实际是一个子类对象，那么这个父类对象可以转换成子类对象，但此时必须用强制类型转换。</li><li>如果一个方法的形式参数定义的是父类对象，那么调用这个方法时，可以使用子类对象作为实际参数。</li></ul></li></ul></li><li><p><strong>抽象类与抽象方法</strong></p><ul><li>抽象类不能创建任何对象，抽象类必须产生其子类，由子类创建对象。</li><li>抽象类中可以包含抽象方法，也可以不包含抽象方法，但如果类中的某一方法是抽象的，整个类就必须被说明成抽象的。 </li><li>抽象方法在子类中必须被实现，否则子类仍是抽象的。</li><li>抽象类不是可有可无的</li></ul></li><li><p>final类和final方法</p><ul><li>如果一个类被final修饰符所修饰和限定，说明这个类不能被继承，即不可能有子类，就不能重载或覆盖它的任何方法</li><li>所有已被private修饰符限定为私有的方法，以及所有包含在final类中的方法，都被默认为是final的。因为这些方法不可能被子类所继承，所以不可能被重载，自然都是最终的方法。</li></ul></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><code>[修饰符] interface 接口名 [extends] [接口列表] &#123;接口体&#125;</code></p><ul><li><p>接口定义了一些没有实现的方法和静态常量集，使程序设计和实现相互分离，同时弥补Java只支持单重继承的不足，也可以约束实现接口的类。</p></li><li><p>Java接口反映了对象较高层次的抽象，为描述相互似乎没有关系的对象的共性提供了一种有效的手段。 </p></li><li><p>和类的区别</p><ul><li>类只能单继承，而接口可以多继承。</li><li>类中的方法可以是具体的，也可以抽象的。 接口中的方法都是抽象的。</li><li>接口中的方法要用类来实现，一个类可以实现多个接口。</li></ul></li><li><p><strong>和抽象类的区别</strong></p><ul><li>接口要被子类实现，抽象类要被子类继承</li><li>接口中变量全为公共静态常量，抽象类中可以有普通变量</li><li>接口中都是方法的声明，抽象类中可以有方法的实现</li><li>接口不可以有构造函数，抽象类可以有</li><li>接口可以多实现，抽象类必须单继承</li><li>接口方法都是抽象方法，抽象类可以有非抽象方法</li><li>接口优先于抽象类</li></ul></li><li><p>首部修饰符：不使用修饰符（同包访问），或者public（任意访问）</p></li><li><p>接口体：接口的成员：成员变量和方法</p><ul><li>成员变量：隐含public、static、final的静态最终变量（常量）</li><li>方法：隐含public和abstract的抽象方法（不能使用static、native、synchronized、final）</li></ul></li><li><p>对接口的引用</p></li><li><p>使用接口实现多重继承</p></li><li><p>多态性建立的基础</p><ul><li>继承</li><li>向上转型</li><li>动态绑定：能在运行期间判断参数的实际类型，并分别调用适当的方法体，从而实现了多态性。在Java中所有非final和非static的方法都会自动地进行动态绑定。</li></ul></li><li><p>简单工厂模式（静态工厂方法模式）</p><ul><li>角色：工厂角色（能根据业务动态选择生产哪些产品）、抽象产品角色（产品有哪些特点，能做什么）、具体产品角色（产品怎么做）</li><li><strong>简单工厂乐器类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Playable</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wind</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Playable</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">&quot;管乐器~~吹&quot;</span>);&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Percussion</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Playable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">&quot;打击乐器~~打&quot;</span>);&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stringed</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Playable</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">&quot;弦乐器~~弹&quot;</span>);&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstrumentFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Playable <span class="hljs-title">createInstrument</span><span class="hljs-params">(String insName)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;wind&quot;</span>.equals(insName)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Wind();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;percussion&quot;</span>.equals(insName))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Percussion();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;stringed&quot;</span>.equals(insName)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Stringed();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleFactoryMain</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Playable aWind = InstrumentFactory.createInstrument(<span class="hljs-string">&quot;wind&quot;</span>);<br>        Playable aPercussion = InstrumentFactory.createInstrument(<span class="hljs-string">&quot;percussion&quot;</span>);<br>        Playable aStringed = InstrumentFactory.createInstrument(<span class="hljs-string">&quot;stringed&quot;</span>);<br>        <span class="hljs-keyword">if</span> (aWind != <span class="hljs-keyword">null</span>) aWind.play();<br>        <span class="hljs-keyword">if</span> (aPercussion != <span class="hljs-keyword">null</span>) aPercussion.play();<br>        <span class="hljs-keyword">if</span> (aStringed != <span class="hljs-keyword">null</span>) aStringed.play();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ul><li><p>作用</p><ul><li>包能够让程序员将类组织成单元，通过文件夹或目录来组织文件和应用程序；</li><li>包减少了名称冲突带来的问题，可以防止同名的类发生冲突；</li><li>包能够更大面积的保护类、变量和方法，而不是分别对每个类进行保护；</li><li>包可以用于标示类。</li></ul></li><li><p>创建：说明语句必须放在整个.java文件的第一行。可以在不同的文件中使用相同的包说明语句，这样就可以将不同文件中的类都包含到相同的程序包中。</p></li><li><p>包的引用</p><ul><li><p>使用全名引用</p><ul><li>同包的类相互引用时：在使用的属性或方法名前加上类名作为前缀即可</li><li>不同包中的类相互引用时：在类名的前面再加上包名，类的全名</li></ul></li><li><p>使用import</p><p>import可以加载整个包中的文件或包中的某一个文件。</p></li></ul></li></ul><h2 id="Java变量及其传递"><a href="#Java变量及其传递" class="headerlink" title="Java变量及其传递"></a>Java变量及其传递</h2><ul><li><p>成员变量与局部变量区别</p><ul><li>从语法形式上看：成员变量是属于类或接口的，而局部变量是在方法中定义的变量或方法的参变量；成员变量可以被public，private，static等修饰，而局部变量则不能被访问控制符及static修饰；成员变量及局部变量都可以被final修饰。</li><li>从变量在内存中的存储方式看：成员变量是对象的一部分，而对象是存在于堆中的，而局部变量是存在于栈中的。</li><li>从变量在内存中的存在时间上看：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而产生，随着方法调用结束而自动消失。</li><li>成员变量如果没有赋初值，则会自动以该类型的默认值（0,false,null等）赋值；而局部变量则不会自动赋值，必须显示地赋值后才能使用。 </li></ul></li><li><p>变量的传递</p><ul><li><p>Java中方法参数传递方式是按值传递。如果参数是基本类型，传递的是基本类型的字面量值的拷贝。如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。</p></li><li><p><a href="https://www.zhihu.com/question/31203609">其他知乎解答</a></p></li><li><p>对于基本类型的变量形参修改了并不能反映到函数外面的实参</p></li><li>对于引用类型的变量，在形参中修改了对象实体值可以反映到实参，在形参中修改了对象引用值，不能反映到实参</li><li>String和StringBuffer的其他区别：<ol><li>StirngBuffer是可以变话的，如果改变了StringBuffer变量的长度或内容，不会改变对这个对象的引用。</li><li>String是固定的，如果改变了String变量的长度或内容，就会新建一个String对象，原来的String变量会指向新的String对象。</li></ol></li></ul></li><li><p>引用型变量的比较</p><ul><li><p>问题引入：<code>==</code>和<code>!=</code>用来比较引用型变量时,只能判断运算符两边引用的是不是同一个对象,即对象的地址值（或对象引用值）是不是相同，需要用<code>equals()</code>方法比较两个对象的内容(对象实体值)是否相同。</p></li><li><p>ps：Java为节省内存空间、提高运行效率，编译时将String Pool中所有相同的字符串合并，只占用一个空间。导致引用变量a和b指向同一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">String a=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;hello&quot;</span>);<br>String b=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;hello&quot;</span>);<br>System.out.println(a==b);        <span class="hljs-comment">//false</span><br>System.out.println(a.equals(b)); <span class="hljs-comment">//true</span><br>String c=<span class="hljs-string">&quot;hello&quot;</span>;<br>String d=<span class="hljs-string">&quot;hello&quot;</span>;<br>System.out.println(c==d);        <span class="hljs-comment">//true</span><br>System.out.println(c.equals(d)); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure></li><li><p>自己定义的类如果要支持equals方法必须重写从Object类继承来的equals方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Object类中的equals方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>==obj);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li>内部类不能与外部类同名（否则，编译器无法区分内部类与外部类），如果内部类还有内部类，内部类的内部类不能与它的任何一层外部类同名。 </li><li>创建<ul><li>创建非静态内部类的对象时一定要确保已经有一个外部类对象<ul><li>利用外部类的方法创建并返回，因为方法是由外部类对象调用的，那创建该内部类对象时，一定已经拥有了所属的外部类对象了</li><li>创建内部类还可以在除外部类中的其它类中，但是要确保该类具有访问内部类的权限，并且已经创建了一个外部类对象。</li></ul></li><li>内部类的修饰符</li><li>静态内部类<ul><li>实例化static内部类时，在new前面不需要用对象变量</li><li>static内部类中不能访问其外部类的非static属性及方法，即只能访问static成员</li><li>方法中的内部类，可以访问其外部类的成员；若是static方法中的内部类，可以访问外部类的static成员。</li><li>方法中的内部类，不能访问该方法的局部变量，除非是final的局部变量。</li></ul></li></ul></li><li>使用<ul><li>内部类中访问外部类的成员<ul><li>内部类中是可以直接访问外部类的其他属性与方法的，即使它们是private的。</li><li>如果内部类中有与外部类同名的属性与方法，可以使用<code>outerClass.this.x</code>或<code>this.x</code>的格式来表达外部类的引用，从而区分外部类和内部类的同名的属性与方法。</li></ul></li><li>方法和作用域中的内部类</li></ul></li><li>匿名内部类<ul><li>这种类不取名字，而直接用其父类的名字或者它所实现的接口的名字</li><li>类的定义与创建该类的一个对象同时进行，即类的定义前面有一个new，没有类的首部，对象的创建和类体共同构成一个匿名类表达式，后面以“;”结束；</li><li>类中不能定义构造方法，因为它没有名字。</li></ul></li></ul><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>Java把程序运行过程中可能遇到的问题分为两类，一类是致命性的，即程序遇到了非常严重的不正常状态，不能简单地恢复执行，这就是错误(对应Error类)，如程序运行过程中内存耗尽。另一类是非致命性的，通过某种处理后程序还能继续运行，这就是异常(对应Exception类)。</li><li>按异常在编译时是否被检测来分，Exception类子类有两种：运行时异常和非运行时异常（一般异常）<ul><li>运行时异常：RuntimeException类及其所有子类。运行时异常是程序员编写程序不正确所导致的异常，理论上，程序员经过检查和测试可以查出这类错误。如除数为零等，错误的强制类型转换、数组越界访问、空引用。</li><li>非运行时异常（一般异常）：指可以由编译器在编译时检测到的、可能会发生在方法执行过程中的异常，如找不到指定的文件等，这不是程序本身的错误，如果这些异常情况没有发生，程序本身仍然是完好的</li></ul></li><li>处理异常的三种方法<ul><li>用户可以用try-catch-finally语句进行捕获和处理</li><li>如果不想捕获和处理异常，可以通过throws语句声明要抛出的异常</li><li>用户可以定义自己的异常类,并用throw语句来抛出。</li></ul></li></ul><h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//访问文本文件text.txt，并将其在屏幕上打印出来。</span><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TryCatchFinally</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            FileInputStream in = <br>                <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;text.txt&quot;</span>);<br>            <span class="hljs-keyword">int</span> s;<br>            <span class="hljs-keyword">while</span>((s=in.read())!=-<span class="hljs-number">1</span>) <br>                System.out.print(s);<br>            in.close();<br>        &#125; <span class="hljs-keyword">catch</span>(FileNotFoundException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;捕获异常：&quot;</span>+e);<br>        &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>System.out.println(<span class="hljs-string">&quot;捕获异常：&quot;</span>+e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;finally块总是执行！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当产生的异常找到了第一个与之相匹配的参数时，就执行包含这一参数的catch语句中的Java代码，执行完catch语句后，程序恢复执行，但不会回到异常发生处继续执行，而是执行try-catch结构后面的代码。</li><li>可以用一个catch块来处理多个异常类型，此时catch的参数应该是这多个异常的父类。</li><li>有多个catch块时，要细心安排catch块的顺序。将子类的catch块放在前面，父类的catch块放在后面。</li><li>执行过程<ul><li>try块中的语句没有产生异常。在这种情况下，Java首先执行try块中的所有的语句，然后执行finally子句中的代码，最后执行try…catch..finally块后面的语句；</li><li>try块中的语句产生了异常，而且此异常在方法内被捕获。在这种情况下，Java首先执行try块中的语句，直到产生异常处，然后跳过此try块中剩下的语句，执行捕获此异常的catch子句的处理代码；然后执行finally子句中的代码</li><li>如果在catch子句又重新抛出了异常。也会执行finally，然后将这个异常抛出给方法的调用者；</li><li>try块中产生了异常，而此异常在方法内没有被捕获。在这种情况下，Java将执行try块中的代码直到产生异常，然后跳过try块中的代码而转去执行finally子句中的代码，最后将异常抛出给方法的调用者。</li></ul></li></ul><h2 id="throws抛出异常"><a href="#throws抛出异常" class="headerlink" title="throws抛出异常"></a>throws抛出异常</h2><p>不捕获异常，而是将异常交由上一层处理，在其他地方捕获异常。如果使用后者，那么应该（在某些情况下）向编译器表明：此方法可能会抛出异常，但方法本身不会捕获它。可以在方法头中用<code>throws</code>子句来实现此功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.调用的方法抛出了异常 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    ……<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInput</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>……<br>    System.in.read();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 2.检测到了错误并使用throw语句抛出异常</span><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    ……<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInput</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>……<br>IOException ae = <br>            <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">&quot;buffer is full&quot;</span>);<br><span class="hljs-keyword">throw</span> ae; <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="throw抛出异常"><a href="#throw抛出异常" class="headerlink" title="throw抛出异常"></a>throw抛出异常</h2><ul><li>一般这种抛出异常的语句应该在满足一定条件执行，例如把throw语句if分支中</li><li>含有<code>throw</code>语句的方法，应该在方法头定义中用<code>throws</code>语句声明所有可能抛出的异常</li><li>抛出异常三步：确定异常类；创建异常类的实例；抛出异常。</li></ul><h1 id="类库"><a href="#类库" class="headerlink" title="类库"></a>类库</h1><h2 id="java-lang"><a href="#java-lang" class="headerlink" title="java.lang"></a>java.lang</h2><ul><li><p><code>String</code></p><ul><li><p>可创建一个对象，用于代表一个字符串(不变的字符串)，并定义了类似查找，比较和连接字符的操作。所有字符串常量都是String对象，存储在String Pool（字符串池）中，字符串池是常量池的一部分。</p></li><li><p>String类对象一旦创建，其内容不可更改。String类的所有方法都不会改变String类对象内容，要改变String类对象的值就必须创建一个新的String对象。</p></li><li>String是类，在比较字符串内容时，不能用==，而应该用<code>equals</code>方法。String类覆盖了Object类的equals方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//求字串，前闭后开</span><br>String a=<span class="hljs-string">&quot;hello&quot;</span>;<br>String b=a.substring(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>); <span class="hljs-comment">// 得到hell</span><br><br><span class="hljs-comment">//长度</span><br>String c=<span class="hljs-string">&quot;hello你好&quot;</span>;<br><span class="hljs-keyword">int</span> d=c.length();          <span class="hljs-comment">// 得到7</span><br><br><span class="hljs-comment">//得到字符串中指定下标的字符。</span><br>String a=”hello”; <span class="hljs-keyword">char</span> b;<br>b=a.charAt(<span class="hljs-number">0</span>);             <span class="hljs-comment">// 得到下标为0的字符h</span><br><br><span class="hljs-comment">//字符数组转换为String</span><br><span class="hljs-keyword">char</span>[] a=&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>&#125;;<br>String b=<span class="hljs-keyword">new</span> String(a);<br><br><span class="hljs-comment">//String转换为字符数组</span><br>String a=<span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-keyword">char</span>[] b=a.toCharArray();<br><br><span class="hljs-comment">//字节数组转换为String</span><br><span class="hljs-keyword">byte</span>[] a=&#123;<span class="hljs-number">65</span>,<span class="hljs-number">66</span>,<span class="hljs-number">67</span>,<span class="hljs-number">68</span>&#125;;<br>String b=<span class="hljs-keyword">new</span> String(a);    <span class="hljs-comment">// 得到ABCD</span><br><br><span class="hljs-comment">//大小写转换</span><br>String s1=<span class="hljs-string">&quot;Hello&quot;</span>;<br>String s2=s1.toUpperCase(); <span class="hljs-comment">// 得到HELLO</span><br>String s3=s1.toLowerCase(); <span class="hljs-comment">// 得到hello</span><br><br><span class="hljs-comment">//其他数据类型to字符串</span><br>String out2 = String.valueOf(<span class="hljs-number">100</span>);<br>String out3 = <span class="hljs-string">&quot;&quot;</span>+<span class="hljs-number">100</span>;<br>String out1 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">100</span>).toString();<br></code></pre></td></tr></table></figure></li><li><p><code>StringBuffer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//三种创建方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuffer</span><span class="hljs-params">()</span>；</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuffer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span>；</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuffer</span><span class="hljs-params">(String str)</span>；</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//更新</span></span><br><span class="hljs-function">StringBuffer s</span>=<span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;hello&quot;</span>);<br>s.append(<span class="hljs-string">&quot;java&quot;</span>);   <span class="hljs-comment">// s变为hellojava</span><br>s.insert(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;sun&quot;</span>);  <span class="hljs-comment">// s变为hellosunjava</span><br>s.setCharAt(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;H&#x27;</span>); <span class="hljs-comment">// s变为Hellosunjava</span><br>s.delete(<span class="hljs-number">5</span>,<span class="hljs-number">8</span>);      <span class="hljs-comment">// s变为Hellojava</span><br><br><span class="hljs-comment">//StringBuffer对象和String对象的转换</span><br>StringBuffer s = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;hello&quot;</span>);<br>String a = s.toString();<br></code></pre></td></tr></table></figure></li><li><p>数据类型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将字符串转换为int型 </span><br>String s = <span class="hljs-string">&quot;1234&quot;</span>;<br><span class="hljs-keyword">int</span> i = Integer.parseInt(s);<br><span class="hljs-keyword">int</span> i = Integer.parseInt(s,<span class="hljs-number">16</span>); <span class="hljs-comment">//16进制</span><br><br><br><span class="hljs-comment">//将int型转换为字符串</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">1234</span>;<br>String s = Integer.toString(i);<br></code></pre></td></tr></table></figure></li><li><p><code>Math</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//PI</span><br><span class="hljs-keyword">double</span> x = Math.PI<br>    <br><span class="hljs-comment">//接受一个double类型的弧度值,返回类型均为double</span><br>sin(<span class="hljs-keyword">double</span> a) <span class="hljs-comment">//返回弧度a的sin值</span><br>cos(<span class="hljs-keyword">double</span> a) <span class="hljs-comment">//返回弧度a的cos值</span><br>tan(<span class="hljs-keyword">double</span> a) <span class="hljs-comment">//返回弧度a的tan值</span><br>    <br><span class="hljs-comment">//反三角函数，返回类型均为double型。</span><br>asin(<span class="hljs-keyword">double</span> r) <span class="hljs-comment">//返回sin值为r的弧度</span><br>acos(<span class="hljs-keyword">double</span> r) <span class="hljs-comment">//返回cos值为r的弧度</span><br>atan(<span class="hljs-keyword">double</span> r) <span class="hljs-comment">//返回tan值为r的弧度</span><br><br><span class="hljs-comment">//返回类型均为double型</span><br>pow(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y) <span class="hljs-comment">//返回x^y。</span><br>exp(<span class="hljs-keyword">double</span> x)           <span class="hljs-comment">//返回e^x</span><br>log(<span class="hljs-keyword">double</span> x)           <span class="hljs-comment">//返回log_e(x)。</span><br>sqrt(<span class="hljs-keyword">double</span> x)          <span class="hljs-comment">//返回x的平方根。</span><br><br><span class="hljs-comment">//取整</span><br>ceil(<span class="hljs-keyword">double</span> a)  <span class="hljs-comment">//返回double</span><br>floor(<span class="hljs-keyword">double</span> a) <span class="hljs-comment">//返回double</span><br>rint(<span class="hljs-keyword">double</span> a)  <span class="hljs-comment">//返回四舍五入后的整数值，double</span><br>round(<span class="hljs-keyword">float</span> a)  <span class="hljs-comment">//返回四舍五入后的整数值, int</span><br>round(<span class="hljs-keyword">double</span> a) <span class="hljs-comment">//返回四舍五入后的整数值, long</span><br><br><span class="hljs-comment">//要求a、b类型相同，返回类型一致</span><br>max(a,b)  <span class="hljs-comment">//返回a和b的最大值</span><br>min(a,b)  <span class="hljs-comment">//返回a和b的最小值 </span><br><br><span class="hljs-comment">//随机数</span><br>random(); <span class="hljs-comment">//得到一个[0,1)之间的随机数，返回double</span><br>(<span class="hljs-keyword">int</span>)(Math.random()*<span class="hljs-number">60</span> + <span class="hljs-number">20</span>)<br>(<span class="hljs-keyword">int</span>)(Math.random()*<span class="hljs-number">60</span>)+ <span class="hljs-number">20</span><br><span class="hljs-comment">//使用随机函数获得20~80的随机整数</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="java-util"><a href="#java-util" class="headerlink" title="java.util"></a>java.util</h2><ul><li><p>日期时间类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Date</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Date</span><span class="hljs-params">(<span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> date)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Date</span><span class="hljs-params">(<span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> date, <span class="hljs-keyword">int</span> hours,<span class="hljs-keyword">int</span> minutes)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Date</span><span class="hljs-params">(<span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> date, <span class="hljs-keyword">int</span> hours, <span class="hljs-keyword">int</span> minutes, <span class="hljs-keyword">int</span> seconds)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//获取</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getYear</span><span class="hljs-params">()</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMonth</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDate</span><span class="hljs-params">()</span></span>;      <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDay</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHours</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMinutes</span><span class="hljs-params">()</span></span>;      <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSeconds</span><span class="hljs-params">()</span></span>;      <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">before</span><span class="hljs-params">(Date when)</span></span>;<br><br><span class="hljs-comment">//比较</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">before</span><span class="hljs-params">(Date when)</span>；</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">after</span><span class="hljs-params">(Date when)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span>;<br><br><span class="hljs-comment">//转换</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>vector&lt;E&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造</span><br>Vector();<br>Vector(<span class="hljs-keyword">int</span> capacity);<br>Vector(<span class="hljs-keyword">int</span> capacity, <span class="hljs-keyword">int</span> capacityIncrement);<br><span class="hljs-comment">//eg</span><br>Vector&lt;String&gt; vector1=<span class="hljs-keyword">new</span> Vector&lt;String&gt;(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">//修改</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertElementAt</span><span class="hljs-params">(E obj, <span class="hljs-keyword">int</span> index)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setElementAt</span><span class="hljs-params">(E obj, <span class="hljs-keyword">int</span> index)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeElementAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>;<br>clear()<br><br><span class="hljs-comment">//获取</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span></span>;<br><span class="hljs-function">E <span class="hljs-title">elementAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure></li><li><p><code>Hashtable&lt;K,V&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Hashtable &lt;K,V&gt;();<br><span class="hljs-function">V <span class="hljs-title">put</span> <span class="hljs-params">(K key, V value)</span></span>;<br><span class="hljs-function">V <span class="hljs-title">get</span> <span class="hljs-params">(Object key)</span></span>; <span class="hljs-comment">//关键字匹配</span><br><span class="hljs-function">V <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span></span>; <br></code></pre></td></tr></table></figure><ul><li>覆盖<code>equals</code>方法和<code>hashCode</code>方法<ul><li>原因：关键字匹配时，系统会自动调用关键字的equals方法，如果结果为true且两个关键字的hashCode()方法的结果也相等，则匹配成功。如果没有在关键字类中覆盖equals方法和hashCode方法，则系统会去调用继承自Object类的equals方法和继承自Object类的hashCode方法。Object类的equals方法是在比较两个对象的地址。Object类的hashCode方法是计算对象的地址的散列值。所以这时就算两个关键字对象实体值（即对象内容）相同，也不会匹配。</li><li>要求<ul><li>值相同的两个关键字对象用equals方法比较后相等</li><li>值相同的两个关键字对象的hashCode方法结果相等</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> date;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>    A aobj=<span class="hljs-keyword">null</span>;<br>     <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> A) &#123;<br>aobj=(A)obj;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.date==aobj.date) <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>     &#125;<br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> date;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>Stack&lt;E&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Stack()     <br><span class="hljs-function">E <span class="hljs-title">push</span> <span class="hljs-params">(E item)</span></span><br><span class="hljs-function">E <span class="hljs-title">pop</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong><em>集合类</em></strong></p></li><li><p><code>Arrays</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用Arrays.sort来对数组排序</span><br>java.util.Arrays.sort(x);<br><br><span class="hljs-comment">//使用Arrays.binarySearch函数对数组进行二分查找</span><br><span class="hljs-comment">//如果没找到，则会输出负数</span><br>java.util.Arrays.binarySearch(x,<span class="hljs-number">1</span>));<br><br><span class="hljs-comment">//数组x中的4个元素都改为7</span><br>java.util.Arrays.fill(x,<span class="hljs-number">7</span>);<br></code></pre></td></tr></table></figure></li></ul><h2 id="java-io"><a href="#java-io" class="headerlink" title="java.io"></a>java.io</h2><ul><li><p>字节流</p><ul><li><p>InputStream和OutputStream是所有面向字节的输入输出流的超类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">( <span class="hljs-keyword">byte</span>[] b )</span> <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">( <span class="hljs-keyword">byte</span>[] b, <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len )</span> <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> b)</span> <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">( <span class="hljs-keyword">byte</span>[] b )</span> <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">( <span class="hljs-keyword">byte</span>[] b, <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len )</span> <span class="hljs-keyword">throws</span> IOException</span><br></code></pre></td></tr></table></figure></li><li><p>FileInputStream和FileOutputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">FileInputStream fs=<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>File file=<span class="hljs-keyword">new</span> File (<span class="hljs-string">&quot;a.txt&quot;</span>);<br>FileInputStream fs=<span class="hljs-keyword">new</span> FileInputStream(file);<br><br>FileOutputStream(File file) <br>FileOutputStream(File file, <span class="hljs-keyword">boolean</span> append) <br>FileOutputStream(FileDescriptor fdObj)     <br>FileOutputStream(String name) <br>FileOutputStream(String name, <span class="hljs-keyword">boolean</span> append)<br></code></pre></td></tr></table></figure></li><li><p>过滤流 </p><p>必须将过滤流和节点流连接。连接是通过在过滤流的构造方法中指定入口参数——某个节点流对象来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">FileInputStream in=<span class="hljs-keyword">new</span> FileInputStream(“text”);<br>BufferedInputStream bufin=<span class="hljs-keyword">new</span> BufferedInputStream(in);<br></code></pre></td></tr></table></figure><ul><li><p>BufferedInputStream和BufferedOutputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BufferedInputStream</span><span class="hljs-params">(InputStream in)</span></span>; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BufferedInputStream</span><span class="hljs-params">(InputStream in,<span class="hljs-keyword">int</span> size)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>ObjectInputStream和ObjectOutputStream</p></li></ul></li></ul></li><li><p>字符流</p><ul><li><p>Reader和Writer</p><p>是所有面向字符的输入输出流的超类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] cbuf)</span> <span class="hljs-keyword">throws</span> IOException </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] cbuf,<span class="hljs-keyword">int</span> off,<span class="hljs-keyword">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException  </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(String str)</span> <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] cbuf)</span> <span class="hljs-keyword">throws</span> IOException </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] cbuf,<span class="hljs-keyword">int</span> off,<span class="hljs-keyword">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException  </span><br></code></pre></td></tr></table></figure></li><li><p>FileReader和FileWriter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">File f=<span class="hljs-keyword">new</span> File(“d:\\t1.txt”); <br>FileReader f1=<span class="hljs-keyword">new</span> FileReader(f);<br>FileReader f2=<span class="hljs-keyword">new</span> FileReader(“d:\\t1.txt”);<br><br>File f=<span class="hljs-keyword">new</span> File(“d:\\t1.txt”); <br>FileWriter f1=<span class="hljs-keyword">new</span> FileWriter(f);   <br>FileWriter f2=<span class="hljs-keyword">new</span> FileWriter(“d:\\t1.txt”);<br></code></pre></td></tr></table></figure></li><li><p>InputStreamReader和OutputStreamReader</p><p>把字节流转换成字符流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InputStreamReader</span><span class="hljs-params">(InputStream in)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InputStreamReader</span><span class="hljs-params">(InputStream in,String enc)</span> </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OutputStreamWriter</span><span class="hljs-params">(OutputStream out)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OutputStreamWriter</span><span class="hljs-params">(OutputStream out,String enc)</span> </span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>输入汉字的时候，因为相当于读取了字符的高/低位字节，并未读取完整的汉字。因此需要将字节流转换为字符流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">InputStreamReader isr=<span class="hljs-keyword">new</span> InputStreamReader(System.in);<br><span class="hljs-keyword">try</span> &#123;<br>c=(<span class="hljs-keyword">char</span>)isr.read();<br>System.out.println(c);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>File</code></p><ul><li>在Java中目录和文件都用File类表示，File类建立了Java语言和磁盘文件的联系，File类不能于文件内容的访问。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造</span><br>File(String pathname)<br>File(File parent, String child) <br>File(String parent, String child)<br>File(URI uri)<br><br><span class="hljs-comment">/* pathname和child指定文件名；</span><br><span class="hljs-comment">parent指定目录名，目录名既可以是字符串，也可以是File对象；</span><br><span class="hljs-comment">uri是统一资源标识符（见java.net包）</span><br><span class="hljs-comment">要表示‘\’字符（反斜杠）要用转义字符‘\\’ */</span><br><br><span class="hljs-comment">//文件操作类方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">createNewFile</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">renameTo</span><span class="hljs-params">(File dest)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">delete</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//目录操作类方法</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">mkdir</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String[] <span class="hljs-title">list</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> File[] <span class="hljs-title">listFiles</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//获取文件属性</span></span><br><span class="hljs-function">...</span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-comment">//使用File类创建文件、目录</span></span><br><span class="hljs-function"><span class="hljs-keyword">import</span> java.io.File</span>; <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">creatFile</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建文件</span><br>            File f1=<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;H:\\a.txt&quot;</span>);<br>            <span class="hljs-keyword">boolean</span> success=f1.createNewFile();<br>            <span class="hljs-comment">//创建目录</span><br>            <span class="hljs-comment">//File f1=new File(&quot;H:\\a&quot;);</span><br>            <span class="hljs-comment">//boolean success=f1.mkdir();</span><br>            <span class="hljs-keyword">if</span>(success) &#123;<br>                     System.out.println(<span class="hljs-string">&quot;Creat Successfully&quot;</span>);&#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(f1.getPath());<br>            &#125;<br>          &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>                 System.out.println(e.toString());<br>          &#125;<br>&#125;  <br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h2><ul><li><p>泛型的本质是参数化类型，编写的代码可以被很多不同类型的对象或数据所重用，也就是说所操作的数据类型被指定为一个参数。使得程序具有更好的可读性和安全性。</p></li><li><p><strong>访问 List<T> 与 ArrayList 的对比</strong></p><p><img src="https://s2.loli.net/2022/01/07/U5IOWlGEuj8fpSH.png" style="zoom:50%;" /></p></li></ul><h1 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h1><h2 id="Frame-JFrame"><a href="#Frame-JFrame" class="headerlink" title="Frame(JFrame)"></a>Frame(JFrame)</h2><ul><li>Frame类的对象开始是不可见的，要调用show()方法 (或setVisible(true)方法) 才能显示出来，也可以调用hide()方法将其隐藏。框架对象被创建后就可使用add()方法将其它组件加入到框架中。</li><li>Frame和Dialog是Window的子类，它们都是窗口类，默认的布局管理器都是 <strong>BorderLayout</strong> </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Frame()        <span class="hljs-comment">//创建一个不带标题的框架</span><br>Frame(String)  <span class="hljs-comment">//创建一个带标题的框架</span><br>    <br>show()                  <span class="hljs-comment">//显示框架</span><br>setVisible(<span class="hljs-keyword">boolean</span> b)   <span class="hljs-comment">//使框架可见/不可见</span><br>hide()                  <span class="hljs-comment">//隐藏框架</span><br>setTitle()              <span class="hljs-comment">//设置框架的标题</span><br>setSize(<span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> h)   <span class="hljs-comment">//调整框架的尺寸(宽/高为w/h)</span><br>setBounds(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> w,<span class="hljs-keyword">int</span> h)<br><span class="hljs-comment">//调整框架的位置及尺寸(左上角为(x,y), 宽、高为w、h)</span><br>add(Component ob)<br><span class="hljs-comment">//将其它组件ob加入到框架的中心位置 </span><br>add(String p, Component ob)   <br><span class="hljs-comment">//将组件ob加入到框架的p位置 (框架默认的布局方式是BorderLayout,  它将容器划分为东西南北中)</span><br></code></pre></td></tr></table></figure><h2 id="panel-Jpanel"><a href="#panel-Jpanel" class="headerlink" title="panel(Jpanel)"></a>panel(Jpanel)</h2><ul><li>面板panel(Jpanel)是能在屏幕上实际显示的组件，提供了容纳其他组件的功能，但本身必须放在Window,Frame,Dialog等容器中才能使用</li><li>所有面板的默认的布局管理器是<strong>FlowLayout</strong>,即按照从左至右、从上到下的方式布局</li><li>java.applet.Applet是java.awt.panel的子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">import</span> java.applet.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContainerApplet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Applet</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>          setLayout(<span class="hljs-keyword">new</span> GridLayout(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>));<br>          Panel Panel1=<span class="hljs-keyword">new</span> Panel();<br>          Panel Panel2=<span class="hljs-keyword">new</span> Panel();<br>          add(Panel1);<br>          add(Panel2);<br>          Panel1.add(<span class="hljs-keyword">new</span> Button(“Up”));<br>          Panel1.add(<span class="hljs-keyword">new</span> Button(“Down”));<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="button"><a href="#button" class="headerlink" title="button"></a>button</h2><p>流程：定义一个按钮对象；用new实例化按钮对象；（可以与上一步合并）；用add方法将按钮加入容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Button()             <span class="hljs-comment">//生成一个没有标记的按钮</span><br>Button(String label) <span class="hljs-comment">//生成一个带标记label的按钮</span><br><br>setLabel(String label) <span class="hljs-comment">//设置按钮标记 </span><br>getLabel()             <span class="hljs-comment">//获取按钮标记</span><br>setEnabled(<span class="hljs-keyword">boolean</span>)    <span class="hljs-comment">//能否点击</span><br>setActionCommand(String s)<br><span class="hljs-comment">//设置用户按下按钮时返回的信息</span><br>addActionListener(ActionListener l) <br><span class="hljs-comment">//将l指定为按钮的监听者</span><br>removeActionListener(ActionListener l) <br><span class="hljs-comment">//将l从按钮监听者中去掉</span><br></code></pre></td></tr></table></figure><h2 id="标签-Lable"><a href="#标签-Lable" class="headerlink" title="标签(Lable)"></a>标签(Lable)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">la1=<span class="hljs-keyword">new</span> Label();<br>la2=<span class="hljs-keyword">new</span> Label(<span class="hljs-string">&quot;Label2&quot;</span>);<br><br>getAlignment()       <span class="hljs-comment">//获取对齐方式</span><br>getText()            <span class="hljs-comment">//获取文本</span><br>setAlignment(<span class="hljs-keyword">int</span> aligmnent)  <span class="hljs-comment">//设置对齐方式 Label.CENTER</span><br>setText(String text)         <span class="hljs-comment">//设置文本</span><br>    <br><span class="hljs-comment">//JLabel中是调用</span><br>setHorizontalAlignment(SwingConstants.CENTER);<br></code></pre></td></tr></table></figure><h2 id="文本框-TextField"><a href="#文本框-TextField" class="headerlink" title="文本框(TextField)"></a>文本框(TextField)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">TextField()              <span class="hljs-comment">//创建一个空的文本框</span><br>TextField(Strint text)   <span class="hljs-comment">//创建一个带有初始文本的文本框</span><br>TextField(<span class="hljs-keyword">int</span> Columns)   <span class="hljs-comment">//创建一个指定列数的文本框    </span><br>TextField(String text, <span class="hljs-keyword">int</span> colulmns)<br><span class="hljs-comment">//创建一个指定列数和带有初始文本的文本框 </span><br><br>addActionListener(ActionListener l)<br><span class="hljs-comment">//将l指定为文本框的ActionEvent事件监听者 </span><br>removeActionListener(ActionListener l)<br><span class="hljs-comment">//将l从文本框的监听者中去掉</span><br>setEchoChar(String sc)   <span class="hljs-comment">//设置用户输入的回应字符&#x27;*&#x27;密码</span><br>getEchoChar()            <span class="hljs-comment">//获取回应字符 </span><br>setText(String s)        <span class="hljs-comment">//设置文本框中的字符串 </span><br>getText()                <span class="hljs-comment">//获取文本框中的字符串 </span><br></code></pre></td></tr></table></figure><h2 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h2><ul><li><p>边界布局 BorderLayout</p><ul><li><strong>BorderLayout是容器JFrame和JApplet的默认布局方式**</strong></li><li>将容器分成五个区域，NORTH(顶部)，SOUTH(底部)，WEST (左侧)，EAST(右侧)，CENTER(中间)，每个区域最多只能1个组件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">add(<span class="hljs-keyword">new</span> Button(<span class="hljs-string">&quot;South&quot;</span>), BorderLayout.SOUTH); <br>add(<span class="hljs-keyword">new</span> Button(<span class="hljs-string">&quot;South&quot;</span>),<span class="hljs-string">&quot;South&quot;</span>);<br>add(<span class="hljs-string">&quot;South&quot;</span>,<span class="hljs-keyword">new</span> Button(<span class="hljs-string">&quot;South&quot;</span>));<br><br>BorderLayout() <br><span class="hljs-comment">//构造一个组件之间没有间距的新边界布局。 </span><br>BorderLayout(<span class="hljs-keyword">int</span> hgap, <span class="hljs-keyword">int</span> vgap) <br><span class="hljs-comment">//用指定的组件之间的水平间距构造一个边界布局。</span><br></code></pre></td></tr></table></figure></li><li><p>顺序布局 FlowLayout</p><ul><li><strong>FlowLayout面板Panel和它的子类Applet的默认布局方式</strong></li><li>将组件从左到右依次排列，一行排满就转到下一行继续排列，直到所有的组件都排列完毕。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Frame f=<span class="hljs-keyword">new</span> Frame();<br>f.setLayout(<span class="hljs-keyword">new</span> FlowLayout());<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FlowLayout</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//创建一个新的FlowLayout，其默认值是居中对齐，默认组件彼此有5单位的水平与垂直间距。</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FlowLayout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> align)</span></span><br><span class="hljs-function"><span class="hljs-comment">//创建一个新的FlowLayout，此FlowLayout可以设置对齐（align）方式，对齐必须是LEFT、CENTER或RIGHT之一。默认组件彼此有5单位的水平与垂直间距。</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FlowLayout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> align,<span class="hljs-keyword">int</span> hgap,<span class="hljs-keyword">int</span> vgap)</span></span><br><span class="hljs-function"><span class="hljs-comment">//创建一个新的FlowLayout，可以自己设置对齐方式、水平间隔和垂直间隔。</span></span><br></code></pre></td></tr></table></figure></li><li><p>网格布局 GridLayout</p><ul><li>网格布局比顺序布局多了行和列的设置，也就是说要先设置网格布局共有几行几列。然后加进去的组件会先填完第一行格子，然后再从第二行开始填，依此类推，就像是一个个的格子一般。而且网格布局会将填进去的组件大小设为一样。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GridLayout</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GridLayout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rows,<span class="hljs-keyword">int</span> cols)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GridLayout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rows,<span class="hljs-keyword">int</span> cols,<span class="hljs-keyword">int</span> hgap,<span class="hljs-keyword">int</span> vgap)</span></span><br></code></pre></td></tr></table></figure></li></ul><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ul><li><p>事件源</p><ul><li>事件源是一个事件的产生者。各种图形组件都可以作为事件源</li></ul></li><li><p>事件对象</p><ul><li>图形组件产生的事件。</li><li>一个事件对象包含了以下信息：id——事件的类型。如按键事件、单击鼠标事件等。target——发生事件的对象。when——指出事件发生的时间。x, y——发生事件的坐标。key——键盘事件中被按下的键。arg——一个与事件相关的参数。modifier——修饰键的状态(即Alt,Ctrl键的状态)</li><li>主要的事件对象<ul><li>ComponentEvent（ 组件事件：组件尺寸的变化，移动） </li><li>ContainerEvent（ 容器事件：组件增加，移动） </li><li>WindowEvent（ 窗口事件：关闭窗口，窗口闭合，图标化） </li><li>FocusEvent（ 焦点事件：焦点的获得和丢失） </li><li>KeyEvent（ 键盘事件：键按下、释放） </li><li><strong>MouseEvent</strong>（ 鼠标事件：鼠标单击，移动）</li><li>ActionEvent（动作事件：按钮按下，TextField中按Enter键） </li><li>AdjustmentEvent（调节事件：在滚动条上移动滑块以调节数值） </li><li>ItemEvent（项目事件：选择项目，不选择”项目改变”） </li><li>TextEvent（文本事件：文本对象改变）</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">KeyListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EventListener</span> </span><br><span class="hljs-class"></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">keyPressed</span><span class="hljs-params">(KeyEvent ev)</span></span>; …&#125;<br></code></pre></td></tr></table></figure></li><li><p>事件监听器</p><ul><li>事件监听器就是一个接收事件、解释事件并处理用户交互的方法。事件产生以后，不是由事件源或者其容器对象处理事件，而是将事件委托给事件监听器来处理。监听器包含事件处理程序。</li><li>事件源和监听器对象通过注册的方式建立关联。当事件源发生事件时，事件监听者就代替事件源对事件进行处理。</li><li>每类事件都有对应的事件监听器，监听器是接口，根据动作来定义方法。 </li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">事件监听器</th><th style="text-align:center">事件响应函数</th></tr></thead><tbody><tr><td style="text-align:center"><strong>MouseListener</strong></td><td style="text-align:center"><strong>mouseClicked/mouseEntered  /mouseExited/mousePressed/</strong></td></tr><tr><td style="text-align:center">MouseMotionListener</td><td style="text-align:center">mouseMoved/mouseDragged</td></tr><tr><td style="text-align:center">WindowListener</td><td style="text-align:center">windowOpened/windowClosing</td></tr><tr><td style="text-align:center">ActionListener</td><td style="text-align:center">actionPerformed</td></tr></tbody></table></div><ul><li><p><strong>事件的处理方法</strong></p><ul><li>三个步骤<ul><li><strong>明确事件源是什么，也就是什么组件要被处理。</strong></li><li><strong>明确什么样的事件要被处理。</strong></li><li><strong>在事件监听器的相应事件响应函数中实现自己的功能。</strong></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">import</span> java.awt.event.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String []args)</span> </span>&#123;<br>        Frame f=<span class="hljs-keyword">new</span> Frame(<span class="hljs-string">&quot;我的第一个窗口&quot;</span>);<br>        f.setSize(<span class="hljs-number">400</span>,<span class="hljs-number">300</span>);<br>        f.setLayout(<span class="hljs-keyword">null</span>);<br>        f.addWindowListener(<span class="hljs-keyword">new</span> MyWindowAdapter()); <br>        f.setVisible(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//创建窗口后要调用setVisible(true)才能显示出来</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWindowAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WindowAdapter</span></span><br><span class="hljs-class"></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">windowClosing</span><span class="hljs-params">(WindowEvent e)</span></span><br><span class="hljs-function"></span>&#123;System.exit(<span class="hljs-number">0</span>);&#125;&#125;<br><br><span class="hljs-comment">//创建了一个匿名内部类对象</span><br><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">import</span> java.awt.event.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String []args)</span> </span>&#123;<br>        Frame f=<span class="hljs-keyword">new</span> Frame(<span class="hljs-string">&quot;我的第一个窗口&quot;</span>);<br>        f.setSize(<span class="hljs-number">400</span>,<span class="hljs-number">300</span>);<br>        f.setLayout(<span class="hljs-keyword">null</span>);<br>        f.addWindowListener(<span class="hljs-keyword">new</span> WindowAdapter() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">windowClosing</span><span class="hljs-params">(WindowEvent e)</span> </span>&#123;<br>                System.exit(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;);<br>        f.setVisible(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//创建窗口后要调用setVisible(true)才能显示出来</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//按钮上响应点击鼠标事件（MouseClicked）为例</span><br>JButton jButton1 = <span class="hljs-keyword">new</span> JButton();<br>jButton1.addMouseListener(<span class="hljs-keyword">new</span> MymouseAdapter());<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MymouseAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MouseAdapter</span> </span><br><span class="hljs-class"></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mouseClicked</span><span class="hljs-params">(MouseEvent e)</span> </span>&#123;……&#125;&#125;<br><span class="hljs-comment">//或者匿名内部类</span><br>frame.add(jButton1);<br><span class="hljs-comment">//元件要 add()</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="字体、颜色外观"><a href="#字体、颜色外观" class="headerlink" title="字体、颜色外观"></a>字体、颜色外观</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//颜色和字体setBackground, setForeground, setFont</span><br><span class="hljs-comment">//位置和大小setBounds, setLocation, setSize</span><br><span class="hljs-keyword">import</span> java.awt.*; <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">static</span> Font ff=<span class="hljs-keyword">new</span> Font(<span class="hljs-string">&quot;黑体&quot;</span>, Font.ITALIC, <span class="hljs-number">30</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span><br><span class="hljs-function">    </span>&#123;<br>        Frame f=<span class="hljs-keyword">new</span> Frame();<br>        f.setLayout(<span class="hljs-keyword">new</span> FlowLayout());<br>        Button b1=<span class="hljs-keyword">new</span> Button(<span class="hljs-string">&quot;B1&quot;</span>);<br>        Button b2=<span class="hljs-keyword">new</span> Button(<span class="hljs-string">&quot;B2&quot;</span>);<br>        b2.setBackground(Color.blue);<br>        b2.setForeground(<span class="hljs-keyword">new</span> Color(<span class="hljs-number">200</span>,<span class="hljs-number">100</span>,<span class="hljs-number">0</span>));<span class="hljs-comment">//红   </span><br>        b2.setFont(ff);<br>        b1.setBounds(<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">60</span>,<span class="hljs-number">20</span>);<br>   b2.setLocation(<span class="hljs-number">100</span>,<span class="hljs-number">40</span>);   <br>   b2.setSize(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>);<br>        f.add(b1);<br>        f.add(b2);<br>        f.setSize(<span class="hljs-number">180</span>,<span class="hljs-number">100</span>);<br>        f.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图形绘制"><a href="#图形绘制" class="headerlink" title="图形绘制"></a>图形绘制</h2><ul><li><p>要绘制图形，必须具备两个要素：画布和画笔</p></li><li><p>Swing中任何JComponent类的子类都可以充当画布的角色，任何java.awt.Component类的子类都可以作为画布</p></li><li><p>所有swing控件都有一个paint方法，负责在需要的时候对控件进行绘制，<strong>一定要在绘制的时候覆盖</strong> <code>public void paint (Graphics g)</code></p></li><li><p>paint方法中的参数g就是画笔，paint方法是自动调用的，当第一次显示组件或改变组件的大小需要重新画组件的界面时，该方法都会由系统自动调用</p></li><li><p>实际开发中，通常都是采用继承JComponent或JPanel类并重写paint的方式来获得画布和画笔的，然后加到顶层容器中；也可以直接重写窗口Frame类的paint方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JComponent</span> </span>&#123;    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">paint</span> <span class="hljs-params">(Graphics g)</span> </span>&#123;<br>    g.setColor(Color.BLACK);<br>    g.drawString(str,x,y);<br>    g.drawOval(x,y,w,h);<br>    g.fiilOval(x,y,w,h); <br>    g.drawRect(x,y,w,h);<br>    g.fillRect(x,y,w,h);<br>    g.drawLine(x1,y1,x2,y2);<br>    g.drawArc(x,y,w,h,startAngle,arcAngle);<br>    &#125;<br>&#125;        <br>MyComponent m=<span class="hljs-keyword">new</span> MyComponet();<br>add(m);<br></code></pre></td></tr></table></figure></li><li><p>Graphics对象的获取总共有两种方法</p><ul><li>通过paint方法接收的参数来获得对象，paint方法是由系统调用的，调用时系统会将需要的Graphics对象引用传给该方法。然后在paint方法中收到这个参数就可以在指定的画布上画画了</li><li>通过相应的getGraphics方法来获得Graphics对象，所有Component类子类对象都有这个方法，但对于控件一般不应该使用此方法获取画笔，而是通过第一种</li></ul></li><li><p>坐标系统：绘制图形采用的是笛卡尔坐标系统，该坐标都是以像素为单位。画布上左上角为该坐标的原点（0,0）位置，x轴向右延伸，y轴向下延伸</p></li><li><p>定位：在一个画布上定位某个图形时，是通过图形的最左上的定位进行的</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//画正方形 drawRect fillRect （x y 宽 高）</span><br><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rect</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Frame</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">paint</span><span class="hljs-params">(Graphics g)</span> </span>&#123;<br>        g.setColor(Color.orange);<br>        g.drawRect(<span class="hljs-number">10</span>,<span class="hljs-number">40</span>,<span class="hljs-number">100</span>,<span class="hljs-number">60</span>);  <span class="hljs-comment">//空心</span><br>        g.fillRect(<span class="hljs-number">120</span>,<span class="hljs-number">40</span>,<span class="hljs-number">100</span>,<span class="hljs-number">60</span>); <span class="hljs-comment">//实心</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        Rect f=<span class="hljs-keyword">new</span> Rect();<br>        f.setTitle(<span class="hljs-string">&quot;It&#x27;s Rect!&quot;</span>);<br>        f.setSize(<span class="hljs-number">230</span>,<span class="hljs-number">120</span>);<br>        f.show();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//画直线 drawLine 起始点坐标</span><br><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Line</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Frame</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">paint</span><span class="hljs-params">(Graphics g)</span></span>&#123;<br>        g.drawLine(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">0</span>);<br>        g.drawString(<span class="hljs-string">&quot;这是一条直线，长为&quot;</span>+(<span class="hljs-keyword">int</span>)Math.sqrt(<span class="hljs-number">200</span>*<span class="hljs-number">200</span>+<span class="hljs-number">100</span>*<span class="hljs-number">100</span>),<span class="hljs-number">10</span>,<span class="hljs-number">120</span>);<br>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        Line f=<span class="hljs-keyword">new</span> Line();<br>        f.setTitle(<span class="hljs-string">&quot;It&#x27;s Line!&quot;</span>);<br>        f.setBounds(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">200</span>,<span class="hljs-number">130</span>);<br>        f.show();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//画圆 drawOval fillOval （x y 宽 高）</span><br><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Oval</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Frame</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">paint</span><span class="hljs-params">(Graphics g)</span> </span>&#123;<br>        g.setColor(Color.red);<br>        g.drawOval(<span class="hljs-number">10</span>,<span class="hljs-number">40</span>,<span class="hljs-number">100</span>,<span class="hljs-number">60</span>);<br>        g.fillOval(<span class="hljs-number">140</span>,<span class="hljs-number">40</span>,<span class="hljs-number">60</span>,<span class="hljs-number">60</span>); <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        Oval f=<span class="hljs-keyword">new</span> Oval();<br>        f.setTitle(<span class="hljs-string">&quot;画椭圆和圆!&quot;</span>);<br>        f.setSize(<span class="hljs-number">230</span>,<span class="hljs-number">120</span>);<br>        f.show();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//画笑脸(画弧形）</span><br><span class="hljs-comment">//drawArc （x y 宽 高 起始角 转角）（逆时针，0向右）</span><br><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">aFace</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Frame</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">paint</span><span class="hljs-params">(Graphics g)</span> </span>&#123;<br>        g.setColor(Color.blue);<br>        g.drawOval(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">80</span>,<span class="hljs-number">100</span>);<br>        g.fillOval(<span class="hljs-number">70</span>,<span class="hljs-number">80</span>,<span class="hljs-number">14</span>,<span class="hljs-number">7</span>);<br>        g.fillOval(<span class="hljs-number">110</span>,<span class="hljs-number">80</span>,<span class="hljs-number">14</span>,<span class="hljs-number">7</span>);<br>        g.drawArc(<span class="hljs-number">70</span>,<span class="hljs-number">110</span>,<span class="hljs-number">40</span>,<span class="hljs-number">20</span>,<span class="hljs-number">180</span>,<span class="hljs-number">180</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        aFace f=<span class="hljs-keyword">new</span> aFace();<br>        f.setTitle(<span class="hljs-string">&quot;It’s me!&quot;</span>);<br>        f.setSize(<span class="hljs-number">180</span>,<span class="hljs-number">180</span>);<br>        f.show();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//动画（和多线程）</span><br><span class="hljs-keyword">import</span> javax.swing.*;<br><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangeExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JFrame</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> b = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ChangeExample</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.setBounds(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">200</span>);<br>        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br>        <span class="hljs-keyword">this</span>.setTitle(<span class="hljs-string">&quot;一个简单的动画&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">paint</span><span class="hljs-params">(Graphics g)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.paint(g);<br>        g.setColor(Color.red);<br>        <span class="hljs-keyword">if</span> (b) g.drawRect(<span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">else</span> g.drawOval(<span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">150</span>, <span class="hljs-number">100</span>);<br>        b = !b;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        &#125;<br>        repaint();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ChangeExample e = <span class="hljs-keyword">new</span> ChangeExample();<br>        e.setVisible(<span class="hljs-keyword">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul><li>程序：一段静态的代码，应用程序执行的蓝本。</li><li>进程：程序的一次动态执行过程。</li><li>线程：程序内部的控制流，比进程更小的执行单位。一个进程在执行过程中，为了同时完成多个操作，可以产生多个线程，形成多条执行线索。</li><li>进程和线程的区别<ul><li>每个进程有一段专有内存空间。进程各自占有不同空间，内存消耗很大，会造成系统在不同程序之间切换时开销很大，进程之间通信速度很慢。</li><li>同一进程的各线程之间共享相同内存空间，利用共享内存来实现数据交换、实时通信及必要的同步工作。线程之间通信速度快，相互切换所占系统资源也小。</li></ul></li><li>线程自身不能够自动运行，必须栖身于某一进程中，由进程触发，每个Java应用程序运行时都对应一个进程——主线程</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li><p>声明一个<code>Thread</code>类的子类，并覆盖 <code>run()</code>方法</p><ul><li>步骤<ul><li>定义一个<code>Thread</code>类的扩展类</li><li>覆盖<code>public void run()</code>方法</li><li>创建对象(用构造方法)</li><li>调用该对象的<code>start()</code>方法，将该线程启动（注意不能直接调用<code>run()</code>方法）, <code>start()</code>方法引起<code>run</code>的调用</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编写一个简单的程序，要求它按两个不同的时间间隔（1秒和3秒）在屏幕上连续显示当前时间</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimePrinter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> pauseTime;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TimePrinter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, String n)</span> </span>&#123;<br>        pauseTime = x;<br>        name = n;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(name + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-keyword">new</span> Date(System.currentTimeMillis()));<br>                Thread.sleep(pauseTime);<br>            &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>                System.out.println(e);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        TimePrinter tp1 = <br>            <span class="hljs-keyword">new</span> TimePrinter(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;Fast Guy&quot;</span>);<br>        tp1.start();<br>        TimePrinter tp2 = <br>            <span class="hljs-keyword">new</span> TimePrinter(<span class="hljs-number">3000</span>, <span class="hljs-string">&quot;Slow Guy&quot;</span>);<br>        tp2.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//编写一个线程，该线程可以控制界面上标签的移动，每过1秒，向右移动10个像素。主界面上设置一个按钮，可以用来启动上述线程。</span><br><span class="hljs-keyword">import</span> javax.swing.*;<br><span class="hljs-keyword">import</span> java.awt.*;<br><span class="hljs-keyword">import</span> java.awt.event.MouseAdapter;<br><span class="hljs-keyword">import</span> java.awt.event.MouseEvent;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> JLabel jl;<br>    MyThread(JLabel jl)&#123; MyThread.jl =jl;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep(<span class="hljs-number">1000</span>);<br>                jl.setLocation(jl.getX() + <span class="hljs-number">10</span>,<br>                               jl.getY());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie)&#123;<br>                System.out.println(ie);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String []args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        Frame f=<span class="hljs-keyword">new</span> Frame(<span class="hljs-string">&quot;我的第一个窗口&quot;</span>);<br>        f.setSize(<span class="hljs-number">400</span>,<span class="hljs-number">300</span>);<br>        jl = <span class="hljs-keyword">new</span> JLabel(<span class="hljs-string">&quot;hello&quot;</span>);<br>        jl.addMouseListener(<span class="hljs-keyword">new</span> MouseAdapter() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mouseClicked</span><span class="hljs-params">(MouseEvent e)</span></span>&#123;<br>                MyThread thread1=<span class="hljs-keyword">new</span> MyThread(jl);<br>                thread1.start();<br>            &#125;<br>        &#125;);<br>        f.add(jl);<br>        f.setVisible(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//创建窗口后要调用setVisible(true)才能显示出来</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>声明一个实现 <code>Runnable</code> 接口的类，并实现<code>run()</code>方法</p><ul><li>在创建线程时还是用<code>Thread</code>类创建线程对象，把实现<code>Runnable</code>接口的类的对象作为<code>Thread</code>类的构造方法的参数,再调用<code>Thread</code>类对象的<code>start()</code>方法</li><li>步骤<ul><li>定义一个实现<code>Runnable</code>接口的类</li><li>实现<code>public void run()</code>方法(必须实现)</li><li>将该类的对象作为<code>Thread</code>类构造方法的参数，创建一个线程实例</li><li>调用该对象的<code>start()</code>方法启动线程</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编写一个简单的程序，要求它按两个不同的时间间隔（1秒和3秒）在屏幕上连续显示当前时间</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimePrinter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> pauseTime;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TimePrinter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, String n)</span> </span>&#123;<br>        pauseTime = x;<br>        name = n;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(name + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-keyword">new</span> Date(System.currentTimeMillis()));<br>                Thread.sleep(pauseTime);<br>            &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>                System.out.println(e);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> TimePrinter(<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;Fast Guy&quot;</span>));<br>        t1.start();<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> TimePrinter(<span class="hljs-number">3000</span>, <span class="hljs-string">&quot;Slow Guy&quot;</span>));<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>比较</p><ul><li>实现Runnable接口的优势：符合OO设计的思想，便于用extends继承其它类。</li><li>采用继承Thread类方法的优点：程序代码更简单。</li><li>通过Thread实例的start()，一个Thread的实例只能产生一个线程</li><li>Runnable的实例是可运行的，但它自己并不能直接运行，它需要被Thread对象来包装才行运行 ，但同一实例(Runnable实例)可产生多个线程</li></ul></li></ul><h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造</span><br><span class="hljs-comment">//target实际执行线程体的目标对象，它必须实现接口Runnable ，任何实现接口Runnable的对象都可以作为一个线程的目标对象</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(Runnable target)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(ThreadGroup group,String name)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(String name)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(Runnable target)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(ThreadGroup group,Runnable target)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">(ThreadGroup group,Runnable targer,String name)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//开始运行当前线程；</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//该方法用来定义线程体。一旦线程被启动执行，就开始执行</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//强制当前线程停止运行，并抛出ThreadDead错误；</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//撤消当前线程；</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAlive</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//测试当前线程是否在活动；</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">suspend</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//临时挂起当前线程；</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resume</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//恢复运行挂起的线程；</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Thread <span class="hljs-title">currentThread</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//返回当前活动线程的引用；</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//调用该方法将CPU让给具有与当前线程相同优先级的线程。如果没有同等优先级的线程是Runnable状态，yield()方法将什么也不做。</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">yield</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//sleep()</span></span><br><span class="hljs-function"><span class="hljs-comment">//该方法用来使一个线程暂停运行一段固定的时间。在线程睡眠时间内，将运行别的线程,线程将进入就绪(Runnable)状态</span></span><br><span class="hljs-function"><span class="hljs-comment">//需要捕获异常IOException</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span></span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function"><span class="hljs-comment">//使当前活动线程睡眠指定的时间millisme;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis,<span class="hljs-keyword">int</span> nanos)</span></span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function"><span class="hljs-comment">//使当前活动线程睡眠指定的时间millisme加上十万分之nanos秒；</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//join()方法使当前的线程等待，直到结束为止，线程恢复到运行状态。</span></span><br><span class="hljs-function"><span class="hljs-comment">//如当前线程发出调用t.join()，则当前线程将等待线程t结束后(最多等待设置的时间)再继续执行</span></span><br><span class="hljs-function"><span class="hljs-title">join</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span></span><br><span class="hljs-function"><span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis,<span class="hljs-keyword">long</span> nanos)</span> </span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> InterruptedException</span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-comment">//interrupt()</span></span><br><span class="hljs-function"><span class="hljs-comment">//如果t在调用sleep()、join()、wait()等方法被阻塞时，则该方法将中断t的阻塞状态，并将接收InterruptException。</span></span><br><span class="hljs-function">t.<span class="hljs-title">interrupt</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//优先级控制，优先级高的先被调度</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPriority</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newPriouity)</span>  </span><br><span class="hljs-function"><span class="hljs-comment">//设置线程的优先级，可以在MIN_PRIORITY=1、NORM_PRIORIITY=5和MAX_PRIORITY=10之间</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPriority</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//获得当前线程的优先级</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span><br><span class="hljs-function"><span class="hljs-comment">//设置线程名；</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//得到当前线程名；</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ThreadGroup <span class="hljs-title">getThreadGroup</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//返回当前的线程组；</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-comment">//常用主要方法</span></span><br><span class="hljs-function"><span class="hljs-comment">//启动和停止</span></span><br><span class="hljs-function"><span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//等待和通知</span></span><br><span class="hljs-function"><span class="hljs-title">wait</span><span class="hljs-params">()</span>, <span class="hljs-title">notify</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//睡眠</span></span><br><span class="hljs-function"><span class="hljs-title">sleep</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//挂起和恢复</span></span><br><span class="hljs-function"><span class="hljs-title">suspend</span><span class="hljs-params">()</span>, <span class="hljs-title">resume</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"><span class="hljs-comment">//撤消线程</span></span><br><span class="hljs-function"><span class="hljs-title">destroy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">join</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">yield</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">isAlive</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">setPriority</span><span class="hljs-params">()</span> </span><br></code></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li><p>创建状态：当一个线程处于创建状态时，它仅仅是一个空的线程对象，系统不为它分配资源。 </p></li><li><p>可运行状态：当一个线程处于可运行状态时，系统为这个线程分配了它需的系统资源，安排其运行并调用线程运行方法，这样就使得该线程处于可运行( Runnable )状态。这一状态并不是运行中状态（Running )，因为线程也许实际上并未真正运行。单处理器的计算机要在同一时刻运行所有的处于可运行状态的线程是不可能的，Java的运行系统必须实现调度来保证这些线程共享处理器。 </p></li><li><p>不可运行状态</p><p>当下面5种情况发生时，线程就进入不可运行状态:</p><ol><li>调用了<code>sleep()</code>方法；</li><li>调用了<code>suspend()</code>方法；</li><li>为等候一个条件变量，线程调用<code>wait()</code>方法；</li><li>输入输出流中发生线程阻塞。</li><li>线程试图调用另一个对象的同步方法，但那个对象处于对象锁定状态，暂时无法使用</li></ol><p>上面5种情况，要使线程返回可运行状态，各有特定的方法与之对应：<br>1) 如果线程处于睡眠状态中，<code>sleep()</code>方法中的参数为睡眠时间，当这个时间过去后，线程即为可运行的；<br>2) 如果一个线程被挂起，要使该线程重新处于可运行状态，需调用<code>resume()</code>方法；<br>3) 如果线程在等待条件变量，那么要停止等待的话，需要该条件变量的线程对象调用<code>notifyAll()</code>方法；<br>4) 如果在I/O流中发生线程阻塞，则特定的I/O完成后可结束这种不可运行状态。<br>5) 同步的方法完成，释放了同步锁</p></li><li><p>死亡状态</p><ul><li>自然撤消</li><li>调用<code>stop()</code>方法停止当前线程 </li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/08/tEvKjzdAL26nYqf.png" alt="image-20220108113753735" style="zoom: 33%;" /></p><h2 id="同步互斥"><a href="#同步互斥" class="headerlink" title="同步互斥"></a>同步互斥</h2><ul><li>把一个方法声明为<code>synchronized</code>有效地防止冲突.调用任何synchronized方法时，对象就会被锁定，不可调用那个对象的其他任何synchronized方法。　　　</li><li>wait:导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法，该方法是会释放锁的。</li><li>notify：唤醒正在等待对象监视器的单个线程。 如果任何线程正在等待这个对象，其中一个被选择被唤醒。</li><li>wait和notify（notifyAll）必须配合synchronized使用，而且wait必须在notify前用，wait后就会进入notify所在的线程，notify后唤醒wait所在的线程，但是wait所在的线程仍然没有获取锁，需要等待notify所在的线程释放锁。</li><li>不但可以把一个方法设定为synchronized，还可以把一段代码设定为同步的，这块代码称作“关键区域”或“同步块”</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//同步堆栈（线程安全堆栈）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncStack</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; <span class="hljs-comment">//堆栈指针初始值为0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> []buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">6</span>];<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span></span>&#123; <span class="hljs-comment">//加上互斥锁</span><br>        <span class="hljs-keyword">while</span>(index == buffer.length)&#123; <br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">this</span>.wait(); <span class="hljs-comment">//等待，直到有数据出栈</span><br>            &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;&#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.notify(); <span class="hljs-comment">//通知其它线程把数据出栈</span><br>        buffer[index] = c;<br>        index++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">char</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//加上互斥锁 </span><br>        <span class="hljs-keyword">while</span>(index ==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">this</span>.wait(); <span class="hljs-comment">//等待其它线程把数据入栈</span><br>            &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;&#125;<br>        &#125; <br>        <span class="hljs-keyword">this</span>.notify(); <span class="hljs-comment">//通知其它线程入栈 </span><br>        index--; <br>        <span class="hljs-keyword">return</span> buffer[index];<br>    &#125;<br>    <span class="hljs-comment">/***main***/</span><br>&#125; <br><br><span class="hljs-comment">//设计两个线程，其中一个线程IncThread，工作流程为循环10次，每次对共享变量J增加1（函数为inc()），另外一个线程DecThread，工作流程为循环10次，每次对共享变量J减少1(函数为dec())，在主程序中启动两个线程进行并发执行。在改写数据过程中利用同步机制保障数据的一致性。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">data</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">()</span></span>&#123;j++;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dec</span><span class="hljs-params">()</span></span>&#123;j--;&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IncThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    data d;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IncThread</span><span class="hljs-params">(data dtemp)</span></span>&#123; d=dtemp;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) d.inc();&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    data d;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecThread</span><span class="hljs-params">(data dtemp)</span></span>&#123;d=dtemp;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) d.dec();&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] arg)</span> </span>&#123;<br>        data d = <span class="hljs-keyword">new</span> data();<br>        IncThread Inc = <span class="hljs-keyword">new</span> IncThread(d);<br>        DecThread Dec = <span class="hljs-keyword">new</span> DecThread(d);<br>        Inc.start();<br>        Dec.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>建立数据源</li><li>加载驱动程序：Class类的forName方法，将驱动程序类加载到JVM中</li><li>获得连接对象：使用DriverManager类的静态方法getConnection来获得连接对象</li><li>创建语句对象：通过Connection对象的createStatement方法来创建语句对象，才可以执行SQL语句；</li><li>执行SQL语句：使用语句对象来执行SQL语句，有两种情况：<ul><li>一种是执行DELETE、UPDATE和INSERT之类的数据库操作语句（DML），这样的语句没有数据结果返回，使用Statement对象的executeUpdate方法执行；</li><li>另一种是执行SELECT这样的数据查询语句（DQL），这样的语句将从数据库中获得所需的数据，使用Statement对象的executeQuery 方法执行；</li></ul></li><li>关闭资源：当对数据库的操作结束后，应当将所有已经被打开的资源关闭，否则将会造成资源泄漏；Connection对象、Statement对象和ResultSet对象都有执行关闭的close方法；有可能抛出SQLException异常，必须捕捉；请注意关闭的顺序，最后打开的资源最先关闭，最先打开的资源最后关闭。</li></ul><p><img src="https://s2.loli.net/2022/01/08/rWvHKBC3d8VReYq.png" style="zoom: 50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.sql.*;    <span class="hljs-comment">//导入java.sql包</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCDemo</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String strCon = <span class="hljs-string">&quot;jdbc:odbc:myODBC&quot;</span>;  <span class="hljs-comment">//连接字符串</span><br>    String strUser = <span class="hljs-string">&quot;sa&quot;</span>;               <span class="hljs-comment">//数据库用户名</span><br>    String strPwd = <span class="hljs-string">&quot;&quot;</span>;                  <span class="hljs-comment">//口令</span><br>    System.out.println(<span class="hljs-string">&quot;正在连接数据库...&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;  <span class="hljs-comment">//监控异常</span><br>      Class.forName(<span class="hljs-string">&quot;sun.jdbc.odbc.JdbcOdbcDriver&quot;</span>);  <span class="hljs-comment">//加载驱动程序</span><br>      Connection con = DriverManager.getConnection(strCon, strUser, strPwd);<br>      <span class="hljs-comment">//获得连接对象</span><br>      System.out.println(<span class="hljs-string">&quot;成功连接到数据库。&quot;</span>);<br>      Statement sta = con.createStatement();    <span class="hljs-comment">//创建语句对象</span><br>      <span class="hljs-comment">//执行SQL语句</span><br>      String strSql = <span class="hljs-string">&quot;DELETE FROM Friends WHERE [Name] = &#x27;郑六&#x27;&quot;</span>;<br>      <span class="hljs-keyword">int</span> count = sta.executeUpdate(strSql);<br>      System.out.println(<span class="hljs-string">&quot;成功删除&quot;</span> + count + <span class="hljs-string">&quot;行数据。&quot;</span>);<br>      sta.close();<br>      con.close();    <br>      <span class="hljs-comment">//关闭所有已经打开的资源</span><br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException cnfe) &#123; cnfe.printStackTrace(); &#125;<br>    <span class="hljs-keyword">catch</span> (SQLException sqle) &#123; sqle.printStackTrace(); &#125; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="操作结果集"><a href="#操作结果集" class="headerlink" title="操作结果集"></a>操作结果集</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>  String strCon = <span class="hljs-string">&quot;jdbc:odbc:MyODBC&quot;</span>;<br>  System.out.println(<span class="hljs-string">&quot;正在连接数据库...&quot;</span>);<br>  Class.forName(<span class="hljs-string">&quot;sun.jdbc.odbc.JdbcOdbcDriver&quot;</span>);<br>  Connection con;<br>  con = DriverManager.getConnection(strCon, <span class="hljs-string">&quot;sa&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>  System.out.println(<span class="hljs-string">&quot;成功连接到数据库。&quot;</span>);<br>  Statement sta = con.createStatement();<br>  ResultSet rs = sta.executeQuery(<span class="hljs-string">&quot;SELECT * FROM Friends&quot;</span>);<br>  System.out.println(<span class="hljs-string">&quot;查询到数据如下：&quot;</span>);<br>  <span class="hljs-keyword">while</span> (rs.next()) &#123;        <span class="hljs-comment">//循环将结果集游标往下移动，到达末尾返回false</span><br>    <span class="hljs-comment">//根据字段名称获得各个字段的值</span><br>    System.out.print(rs.getString(<span class="hljs-string">&quot;Name&quot;</span>) + <span class="hljs-string">&quot;\t&quot;</span>);     <span class="hljs-comment">//获得字符串</span><br>    System.out.print(rs.getString(<span class="hljs-string">&quot;Address&quot;</span>) + <span class="hljs-string">&quot;\t&quot;</span>);  <span class="hljs-comment">//获得字符串</span><br>    System.out.print(rs.getInt(<span class="hljs-string">&quot;Telephone&quot;</span>) + <span class="hljs-string">&quot;\t&quot;</span>);   <span class="hljs-comment">//获得整数</span><br>    System.out.print(rs.getDate(<span class="hljs-string">&quot;HireDate&quot;</span>) + <span class="hljs-string">&quot;\t&quot;</span>);   <span class="hljs-comment">//获得日期型数据</span><br>    System.out.println(rs.getFloat(<span class="hljs-string">&quot;Salary&quot;</span>));         <span class="hljs-comment">//获得浮点型数据</span><br>  &#125;<br>     rs.close();<br>    sta.close();<br>    con.close();<br>&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException cnfe) &#123; cnfe.printStackTrace(); &#125;<br>  <span class="hljs-keyword">catch</span> (SQLException sqle) &#123; sqle.printStackTrace(); &#125;<br></code></pre></td></tr></table></figure><h2 id="PreparedStatement接口"><a href="#PreparedStatement接口" class="headerlink" title="PreparedStatement接口"></a>PreparedStatement接口</h2><ul><li>如果要多次执行相似的SQL语句，可以使用PreparedStatemend（预编译语句对象）对象来执行；</li><li>通过Connection对象的prepareStatement方法来创建预编译语句对象；</li><li>PreparedStatement对象会将SQL语句预先编译，这样将会获得比Statement对象更高的执行效率</li><li>索引从1开始</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">String strCon = <span class="hljs-string">&quot;jdbc:odbc:MyODBC&quot;</span>;<br>System.out.println(<span class="hljs-string">&quot;正在连接数据库...&quot;</span>);<br>Class.forName(<span class="hljs-string">&quot;sun.jdbc.odbc.JdbcOdbcDriver&quot;</span>);<br>Connection con = DriverManager.getConnection(strCon, <span class="hljs-string">&quot;sa&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;成功连接到数据库。&quot;</span>);<br><br>PreparedStatement ps = con.prepareStatement(<span class="hljs-string">&quot;UPDATE Friends SET Address = ? WHERE Name = ?&quot;</span>);<br><span class="hljs-comment">//使用带参数的SQL语句创建PreparedStatement对象</span><br><span class="hljs-comment">//设置SQL语句中的参数值</span><br><br>ps.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;长沙&quot;</span>);<br>ps.setString(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;王五&quot;</span>);<br><span class="hljs-keyword">int</span> count = ps.executeUpdate();     <span class="hljs-comment">//执行命令</span><br>System.out.println(<span class="hljs-string">&quot;成功更新了&quot;</span> + count + <span class="hljs-string">&quot;行数据。&quot;</span>);   <br>ps.close();    <span class="hljs-comment">//关闭资源</span><br>con.close();<br></code></pre></td></tr></table></figure><h2 id="纯Java驱动连接MySQL"><a href="#纯Java驱动连接MySQL" class="headerlink" title="纯Java驱动连接MySQL"></a>纯Java驱动连接MySQL</h2><ul><li><p>使用纯Java驱动连接到MySQL 5.0数据库，加载驱动程序应改成如下语句<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></p></li><li><p>连接字符串应如下格式：<br><code>&quot;jdbc:mysql://服务器名或IP:3306/数据库名&quot;</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Connection con = <br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DriverManager</span>.</span></span>getConnection<br>(<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/test&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>); <br></code></pre></td></tr></table></figure></li></ul><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><ul><li>套接口编程：利用传输层（TCP或UDP）实现网络进程通信的编程，这是所有应用开发的基础</li><li>Socket：传输层提供的网络进程通信接口; 进程之间的通信的抽象连接点; 用于表达两台机器间一个连接的终端</li><li>java.net包提供的类Socket类、ServerSocket类</li></ul><h2 id="套接口类-Socket"><a href="#套接口类-Socket" class="headerlink" title="套接口类(Socket)"></a>套接口类(Socket)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造</span><br>Socket(String host, <span class="hljs-keyword">int</span> port) <br>    <span class="hljs-keyword">throws</span> UnknownHostException, <span class="hljs-function">IOException</span><br><span class="hljs-function"><span class="hljs-title">Socket</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port, <span class="hljs-keyword">boolean</span> stream)</span></span><br><span class="hljs-function"><span class="hljs-title">Socket</span><span class="hljs-params">(InetAddress address,<span class="hljs-keyword">int</span> port)</span> </span><br><span class="hljs-function"><span class="hljs-title">Socket</span><span class="hljs-params">(InetAddress address,<span class="hljs-keyword">int</span> port <span class="hljs-keyword">boolean</span> stream)</span></span><br><span class="hljs-function"><span class="hljs-comment">//stream用于决定生成的套接口是流套接口还是数据报套接口</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">//方法</span></span><br><span class="hljs-function">InetAddress <span class="hljs-title">getInetAddress</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//返回该套接口所连接的地址</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getPort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//返回该套接口所连接的远程端口</span></span><br><span class="hljs-function">snchronized <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function"><span class="hljs-comment">//关闭套接口 </span></span><br><span class="hljs-function">InputStream <span class="hljs-title">getInputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOExcepiton</span><br><span class="hljs-function"><span class="hljs-comment">//获得从套接口读入数据的输入流</span></span><br><span class="hljs-function">OutputStream <span class="hljs-title">getOutputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function"><span class="hljs-comment">//获得向套接口进行写操作的输出流</span></span><br></code></pre></td></tr></table></figure><h2 id="服务器套接口类（ServerSocket）"><a href="#服务器套接口类（ServerSocket）" class="headerlink" title="服务器套接口类（ServerSocket）"></a>服务器套接口类（ServerSocket）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//构造</span><br>ServerSocket(<span class="hljs-keyword">int</span> port) <span class="hljs-function"><span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function"><span class="hljs-title">ServerSocket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port，<span class="hljs-keyword">int</span> count)</span> </span><br><span class="hljs-function"><span class="hljs-comment">//count对该ServerSocket与端口间的连接进行监听的次数</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-comment">//方法</span></span><br><span class="hljs-function">Socket <span class="hljs-title">accept</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function"><span class="hljs-comment">//等待一个连接，该方法将阻塞当前线程，直到连接成功。该方法返回一个套接口类对象，通过该对象，程序与连接的客户进行通信。</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span><br><span class="hljs-function"><span class="hljs-comment">//关闭套接口。</span></span><br></code></pre></td></tr></table></figure><h2 id="基于TCP的Socket通讯实现"><a href="#基于TCP的Socket通讯实现" class="headerlink" title="基于TCP的Socket通讯实现"></a>基于TCP的Socket通讯实现</h2><ul><li><p>TCP是一种可靠的、基于连接的网络协议，当两个网络进程准备基于TCP通信时，都必须首先建立各自的一个套接口：服务器建立套接口后，侦听来自网络的客户连接请求；客户通过套接口，指定服务器的IP地址和端口号，便可与服务器进行通信</p></li><li><p>具体实现过程</p><ul><li>服务器：一直运行，不断监听客户端的连接<ul><li>创建ServerSocket对象，指定服务器监听的端口号；</li><li>调用以上建立服务器套接口对象的accept方法等待客户的连接；</li><li>一旦有客户送来正确请求，就连接到端口，accept方法返回一个新的套接口对象（Socket类对象）；</li><li>获取该返回对象绑定的输入输出流对象，实现和客户的通信</li></ul></li><li>客户：主动发起连接的一方<ul><li>创建一个Socket类对象，指定所要连接服务器的IP地址和端口（服务器接受连接，该对象就建立）；</li><li>获得该Socket对象绑定的输入输出流，实现和服务器的通信</li></ul></li></ul><p><img src="https://s2.loli.net/2022/01/08/rvZ7MAW61uXmf5K.png" style="zoom: 50%;" /></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实现基于TCP协议的Socket通信， 实现登录服务端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Service</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket serverSocket = <span class="hljs-keyword">null</span>;<br>        Socket socket = <span class="hljs-keyword">null</span>;<br>        InputStream is = <span class="hljs-keyword">null</span>;<br>        InputStreamReader isr = <span class="hljs-keyword">null</span>;<br>        BufferedReader br = <span class="hljs-keyword">null</span>;<br>        String info;<br>        OutputStream os = <span class="hljs-keyword">null</span>;<br>        PrintWriter pw = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.创建一个服务器ServerSocket，指定绑定端口， 并监听此端口</span><br>            serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8888</span>);<br>            <br>            <span class="hljs-comment">//2.调用accept（）方法开始监听，等待客户端链接</span><br>            System.out.println(<span class="hljs-string">&quot;---服务器即将启动，等待客户端的连接---&quot;</span>);<br>            socket = serverSocket.accept();<br>            <br>            <span class="hljs-comment">//3.获取输入流 用来读取客户端发送的登录信息</span><br>            is = socket.getInputStream();<br>            <span class="hljs-comment">//将字节流转换为字符流</span><br>            isr = <span class="hljs-keyword">new</span> InputStreamReader(is);<br>            <span class="hljs-comment">//为输入流添加缓冲</span><br>            br = <span class="hljs-keyword">new</span> BufferedReader(isr);<br>            <span class="hljs-comment">//循环读取客户端数据</span><br>            <span class="hljs-keyword">while</span> ((info = br.readLine()) != <span class="hljs-keyword">null</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot; 我是服务器，客户端说：&quot;</span> + info);<br>            &#125;<br>            socket.shutdownInput(); <span class="hljs-comment">//关闭输入流</span><br>            <br>            <span class="hljs-comment">//4.获取输出流，响应客户端的请求</span><br>            os = socket.getOutputStream();<br>            pw = <span class="hljs-keyword">new</span> PrintWriter(os);<br>            pw.write(<span class="hljs-string">&quot;欢迎登录&quot;</span>);<br>            pw.flush(); <span class="hljs-comment">//将缓存输出        </span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <br>            <span class="hljs-comment">//5.关闭资源</span><br>            pw.close();<br>            os.close();<br>            br.close();<br>            isr.close();<br>            is.close();<br>            socket.close();<br>            serverSocket.close();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实现基于TCP协议的Socket通信， 实现登录客户端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>        Socket socket = <span class="hljs-keyword">null</span>;<br>        InputStream is = <span class="hljs-keyword">null</span>;<br>        BufferedReader br = <span class="hljs-keyword">null</span>;<br>        String info;<br>        OutputStream os = <span class="hljs-keyword">null</span>;<br>        PrintWriter pw = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.创建Socket，知名需要连接的服务器的地址和端口号</span><br>            socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8888</span>);<br>            <br>            <span class="hljs-comment">//2.通过输出流向服务器端发送请求信息</span><br>            os = socket.getOutputStream();<br>            <br>            <span class="hljs-comment">//将输出流包装成打印流</span><br>            pw = <span class="hljs-keyword">new</span> PrintWriter(os);<br>            pw.write(<span class="hljs-string">&quot;用户名：admin;密码：123&quot;</span>);<br>            pw.flush();<br>            socket.shutdownOutput();<span class="hljs-comment">//关闭输出流</span><br>            <br>            <span class="hljs-comment">//3.获取输入流,用来读取服务端的响应信息</span><br>            is = socket.getInputStream();<br>            br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(is));<br>            info  = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">while</span> ((info = br.readLine()) != <span class="hljs-keyword">null</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;我是客户端，服务器回应：&quot;</span>+ info);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <br>            <span class="hljs-comment">//4.关闭相关资源</span><br>            br.close();<br>            is.close();<br>            pw.close();<br>            os.close();<br>            socket.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基于UDP的Socket通讯实现"><a href="#基于UDP的Socket通讯实现" class="headerlink" title="基于UDP的Socket通讯实现"></a>基于UDP的Socket通讯实现</h2><ul><li><p>通信前不需要预先建立连接，速度快，可靠性差；每次发送的数据独立路由，都需要加上对方的IP地址和端口．</p></li><li><p>支持UDP的两个主要类：DatagramSocket, DatagramPacket</p><ul><li><p>数据报套接口（DatagramSocket）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">DatagramSocket()<br>DatagramSocket(<span class="hljs-keyword">int</span> port)<br>receive(DatagramPacket packet)<br>send(DatagramPacket packet)<br></code></pre></td></tr></table></figure></li><li><p>数据报类（DatagramPacket）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">DatagramPacket(<span class="hljs-params">byte</span>[] <span class="hljs-params">buf</span>, <span class="hljs-params">int</span> <span class="hljs-params">length</span>)</span><br><span class="hljs-comment">//接收数据报，作为receive()的参数</span><br><span class="hljs-constructor">DatagramPacket(<span class="hljs-params">byte</span>[] <span class="hljs-params">buf</span>, <span class="hljs-params">int</span> <span class="hljs-params">length</span>, InetAddress <span class="hljs-params">address</span>, <span class="hljs-params">int</span> <span class="hljs-params">port</span>)</span>;<br><span class="hljs-comment">//发送数据报，作为send()的参数</span><br>InetAddress get<span class="hljs-constructor">Address()</span><br><span class="hljs-built_in">int</span> get<span class="hljs-constructor">Port()</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UDPServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] buf=<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];  <span class="hljs-comment">//报文缓冲区</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//构造DatagramSocket类对象，端口号6789</span><br>            DatagramSocket serversocket=<span class="hljs-keyword">new</span> DatagramSocket(<span class="hljs-number">6789</span>);  <span class="hljs-comment">//建立数据报套接口</span><br>            System.out.println(<span class="hljs-string">&quot;Server is waiting......&quot;</span>);<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-comment">//构造DatagramPacket类对象，用来从数据报套接字接收数据</span><br>                DatagramPacket serverpacket = <span class="hljs-keyword">new</span> DatagramPacket(buf,<span class="hljs-number">1024</span>);<br>                <span class="hljs-comment">//等待接收数据报</span><br>                serversocket.receive(serverpacket);<br>                <span class="hljs-comment">//字节数组转换成字符串</span><br>                String data=<span class="hljs-keyword">new</span> String(buf,<span class="hljs-number">0</span>,serverpacket.getLength ());<br>                <span class="hljs-keyword">if</span>(data.equals(<span class="hljs-string">&quot;&quot;</span>))<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(data.equals(<span class="hljs-string">&quot;quit&quot;</span>))<br>                    <span class="hljs-keyword">break</span>;<br>                System.out.println(<span class="hljs-string">&quot;client said :&quot;</span>+data);<br>                <span class="hljs-comment">//接收的字符串转换成大写</span><br>                String strToSend =data.toUpperCase();<br>                InetAddress clientIP=serverpacket.getAddress();<span class="hljs-comment">//获得客户地址</span><br>                <span class="hljs-keyword">int</span> clientPort=serverpacket.getPort() ; <span class="hljs-comment">//获得客户端口</span><br>                <span class="hljs-keyword">byte</span>[] msg=strToSend.getBytes (); <span class="hljs-comment">//</span><br>                DatagramPacket clientpacket =<br>                        <span class="hljs-keyword">new</span> DatagramPacket(msg,strToSend.length(),clientIP,clientPort);<br>                <span class="hljs-comment">//将数据打包发送给客户</span><br>                serversocket.send(clientpacket) ;<br>            &#125;<br>            serversocket.close ();<br>            System.out.println(<span class="hljs-string">&quot;Server is closed!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UDPClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            String strToSend;<br>            <span class="hljs-keyword">byte</span>[] bufsend;  <span class="hljs-comment">//发送报文缓冲区</span><br>            <span class="hljs-keyword">byte</span>[] bufrec;  <span class="hljs-comment">//接收报文缓冲区</span><br>            DatagramPacket clientpacket;<br>            <span class="hljs-comment">//构造DatagramSocket类对象clientSocket</span><br>            DatagramSocket clientSocket=<span class="hljs-keyword">new</span> DatagramSocket();<br>            <span class="hljs-comment">//构造DataInputStream类对象sysin ，与System.in绑定</span><br>            DataInputStream sysin=<span class="hljs-keyword">new</span> DataInputStream(System.in );<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;\nWaiting for input a line text......&quot;</span>);<br>                <span class="hljs-comment">//从sysin输入一行</span><br>                strToSend=sysin.readLine() ;<br>                <span class="hljs-comment">//把字符串转换为字节数组</span><br>                bufsend=strToSend.getBytes();<br>                <span class="hljs-comment">//构造DatagramPacket类对象clientpacket ，服务器端口号约定为6789</span><br>                clientpacket =<br>                        <span class="hljs-keyword">new</span> DatagramPacket(bufsend,strToSend.length(),InetAddress.getLocalHost(),<span class="hljs-number">6789</span>);<br>                <span class="hljs-comment">//输入一行后打包发送给服务器</span><br>                clientSocket.send(clientpacket) ;<br>                <span class="hljs-comment">//如输入字符串是quit，停止发送</span><br>                <span class="hljs-keyword">if</span>(strToSend.equals(<span class="hljs-string">&quot;quit&quot;</span>))<br>                    <span class="hljs-keyword">break</span>;<br>                bufrec=<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>                DatagramPacket receivePacket=<span class="hljs-keyword">new</span><br>                        DatagramPacket(bufrec,<span class="hljs-number">1024</span>);<br>                <span class="hljs-comment">//接收数据报</span><br>                clientSocket.receive(receivePacket);<br>                String received=<span class="hljs-keyword">new</span> String(receivePacket.getData(),<span class="hljs-number">0</span>);<br>                System.out.println(<span class="hljs-string">&quot;From Server:&quot;</span>+ received );<br>                <span class="hljs-comment">//以上构造数据报接收服务器端发送来的数据</span><br>            &#125;<br>            clientSocket.close ();<br>        &#125;<br>        <span class="hljs-comment">//异常处理</span><br>        <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="考前教育"><a href="#考前教育" class="headerlink" title="考前教育"></a>考前教育</h1><h2 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h2><h3 id="某学长"><a href="#某学长" class="headerlink" title="某学长"></a>某学长</h3><p><a href="https://comydream.github.io/2019/01/04/java-review/">《Java语言及网络编程》复习笔记 | ComyDream Studio</a></p><h3 id="同班同学"><a href="#同班同学" class="headerlink" title="同班同学"></a>同班同学</h3><ul><li>程序填空，根据一段描述写代码，根据界面写代码</li><li>一段代码问你输出结果（主要考察参数传递，构造函数调用顺序，类型转换）</li><li>指出代码中的错误（权限修饰符，super关键字）</li><li><strong>简述内部类，匿名内部类设计的好处</strong>（内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据；内部类可以对同一个包中的其他类隐藏起来；使用匿名内部类定义回调函数，节省代码）</li><li>线程安全的栈或队列（synchronized关键字），见上</li><li>输入字符串进行截取，替换等操作（java.io和java.lang.String，另外凡涉及IO都应当进行异常处理）</li><li>按要求存放元素（java.util.Vector , java.util.List，Java.util.Map）</li></ul><h3 id="信安老师"><a href="#信安老师" class="headerlink" title="信安老师"></a>信安老师</h3><p>（强调）开发环境的配置，环境变量、系统变量有哪些，它的作⽤是什么。 开发流程要知道，哪些是⽤来做编译的，哪些是⽤来启动虚拟机的，源⽂件的后缀是什么（.java）中 间字节码的后缀（.class）编译过程中我们的邮件命名，编译完成后会出现⼏个class⽂件</p><p>贯穿试卷 （⽤户）标识符命名规则 基本数据类型（数据转换） 作⽤域，初始化（⾯向对象中，声明的位置不⼀样，由谁初始化也不⼀样，在成员变量⾥，由编译器 来初始化，在形参⾥⽤形参初始化，局部变量和布尔变量由⽤户⾃⼰初始化），初始化数组(基本类型 数组初始化是基本类型的值；对象类型在数组⾥初始化的值是null,需要初始化对象来调⽤。) 运算符要知道优先级 参数传递（重点）（⽅法定义⾥必考，要知道 穿传⼀个基本数据类型，它的结果是什么样的，传⼀个 引⽤类型结果是什么样的。引⽤类型传到⽅法⾥⾯它的引⽤值可能发⽣变化，它的对象引⽤，指向性 的对象和不指向性的对象它⾥⾯的变化情况是什么）</p><p>⼤部分题都在这章 访问权限修饰符和⾮访问权限修饰符在封装时的语法（必考） 访问权限修饰符类⼀级的、成员⼀级的访问权限是不⼀样的。 ⾮访问权限修饰符（final、statick)。 继承多态 单继承 可以实现多接⼝ 向上转型问题 ⽅法调⽤时多态的概念 多态有两种实现机制：覆盖和 重载 继承通过多态实现重载 运⾏时动态链遍机制 覆盖和重载语法规则 ⽅法头⽣成的时候覆盖和重载要求的是什么样 和他的输⼊参数有没有关系 与访 问权限修饰符的关系 对象初始化顺序，成员变量和构造⽅法、对静态变量和静态块、在初始化的过程的顺序（重点） super等关键字的含义是什么，构造⽅法使⽤的规则， 掌握接⼝与抽象类的语法 Lamb表达式不考 匿名内置类实现监听器</p><p>运⾏时出现的问题，异常出现的阶段，分类 异常处理的语法规则 异常出现时有两种处理⽅法</p><p>integer包装类的使⽤⽅法，基本数据类型、字符串之间转换⽤包装类实现 范型（有很少的选择题），注意如何使⽤，使⽤时的问题 I/o 选择题 scanner ⽤法</p><p>图形怎么往⽂件放，布局管理器怎么⽤，常⻅的布局管理器有哪些。 事件处理机制（编程）编写事件监听器，安放在事件源（图⽚ 上来完成某个⼯作</p><p>构造线程的⽅法：两种 定义 线程的6态，状态之间的转换，常⻅的函数⽅法怎么⽤ 线程的同步只⽤掌握synchronized互斥</p><h3 id="计科老师"><a href="#计科老师" class="headerlink" title="计科老师"></a>计科老师</h3><ul><li><p><strong>java源文件的组成</strong>：类或外部结构，例“class Student{}”；main()方法，也叫做程序的入口；编写的代码，是写在main方法中的。</p></li><li><p><strong>main方法的作用</strong></p><ul><li>public：为了保证JVM在任何情况下都可以访问到main方法，就用public修饰</li><li>静态的：可以让JVM调用main方法的时候更加方便，不需要通过对象调用。</li><li>没有返回值。Java不需要main方法向操作系统返回退出信息。如果main方法正常退出，那么Java应用层序的退出代码为0，表示成功的运行了程序。</li><li>main的名称：不能变，是为了JVM能够识别程序运行的起点，main方法可以被重载，重载的main方法不会被执行。main方法作为程序初始线程的起点，任何其他线程均由该线程启动。</li><li>String [] args：是main方法中唯一可以改变的地方。args是arguments的缩写，只是一个变量默认名，习惯性写作它，但是也可以改变的，只要符合命名规则随便你写成什么。其实它是程序运行传入的一个参数组。</li></ul></li><li><code>.java</code>文件可以没公共类，<code>main</code>可以不在公共类里，要有公共类也只能有一个公共类</li><li><p><strong>简单工厂（静态工厂方法）</strong>：写一个乐器类，有很多子类是具体乐器，见接口笔记</p></li><li><p>抽象类和接口的使用，抽象类和抽象方法的关系，见笔记</p></li><li>一个复杂对象方法的构造调用顺序，见笔记</li><li>泛型约束容器的类型和与普通数组的区别，见笔记</li><li>util集合类vector，见笔记</li><li>几种基本的布局管理器，面板窗体默认布局管理(BorderLayout是容器JFrame和JApplet的默认布局方式,FlowLayout面板Panel和它的子类Applet的默认布局方式)，还有gridLayout见笔记</li><li>，如何安排布，前景色，背景色（布局f.setLayout(new xxxLayout());颜色和字体setBackground, setForeground, setFont，位置和大小setBounds, setLocation, setSize）</li><li>画图：画字符串\椭圆\弧\矩形，见笔记</li><li>常用组件按钮文本框标签，见笔记</li><li>事件处理，事件源监听器，见笔记</li><li>时间监听器的编写，能有编写处理函数mouse就不要创建action的</li></ul><p>实验7列表不做</p><p>8不做 9做</p><p>9.4换成窗体</p><p>加减乘除计算器 窗体上的鼠标单击变笑脸哭脸 用线程调用控制动画一会画椭圆一会画矩形</p><p>第八章<br>  1.实现方法继承thread<br>  2.接口runnable<br>  3.基本方法调用静态方法不是静态方法sleep stop等 第九章的习题<br>  4.多线程 on notify等三个</p><h2 id="JavaEE程序设计"><a href="#JavaEE程序设计" class="headerlink" title="JavaEE程序设计"></a>JavaEE程序设计</h2><h3 id="来自老师"><a href="#来自老师" class="headerlink" title="来自老师"></a>来自老师</h3><p>填空题 10个x2分=20</p><p>问答题 5个x6分=30（概念，有延伸、从实现、编译的角度融入自己的思考）</p><p>编程题有基础和高级 </p><p>基础题 2个x10分=20 不得引入工具 例如队列不用queue </p><p>高级题 </p><p>综合 建议写注释 不会也需要搭建整体的框架</p><p>USB接口，引线数量做常量，功能数据传递和充电</p><p>（接口里面写不写public final，数据都是常量）</p><p>抽象类和接口 抽象方法和非抽象方法</p><p>参数传参和多线程一起 构造函数</p><p>a继承b继承c c调用a的函数</p><p>线程同步互斥（协作竞争）是什么，什么时候用</p><p>线程中断的执行方法，如何恢复 yield wait sleep join interrupt</p><p>socket 本机进程通信</p><p>捕获、抛出方式有哪些</p><p>什么是错误</p><p>数据库（url username password） 记得关闭</p><p>为什么要class？（不知道写的啥）</p><p>==（地址）与equal（重写object）</p><p>文件管文件也管目录、绑定与关闭</p><p>I/O流必须会 字节 system.in 字符串 buffer stringbuffer 可变 string不可变</p><p>参数基于拷贝 简单类(一致) 复杂类(地址) 原因 （提高数据相应效率，有常量池，降低代价）</p><ul><li><p>排序算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">selectSort</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sorting</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] list)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;list.length; i++)&#123;<br>            <span class="hljs-keyword">int</span> min = list[i];<br>            <span class="hljs-keyword">int</span> min_index = i;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>; j&lt;list.length; j++)&#123;<br>                <span class="hljs-keyword">if</span>(list[j] &lt; min)&#123;<br>                    min_index = j;<br>                    min = list[j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">int</span> temp = list[i];<br>            list[i] = list[min_index];<br>            list[min_index] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">bubbleSort</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sorting</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] list)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;list.length-<span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;list.length-<span class="hljs-number">1</span>-i; j++)&#123;<br>                <span class="hljs-keyword">if</span>(list[j] &gt; list[j+<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-keyword">int</span> temp = list[j];<br>                    list[j] = list[j+<span class="hljs-number">1</span>];<br>                    list[j+<span class="hljs-number">1</span>] = temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">sort</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">xxxxSort</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; buf.length; i++) &#123;<br>            buf[i] = sc.nextInt();<br>        &#125;<br>        sorting(buf);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j : buf) &#123;System.out.print(j + <span class="hljs-string">&quot; &quot;</span>);&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>CUMT课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《编译技术-2021秋》结课考试小结</title>
    <link href="/2021/12/17/%E3%80%8A%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF-2021%E7%A7%8B%E3%80%8B%E7%BB%93%E8%AF%BE%E8%80%83%E8%AF%95%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/12/17/%E3%80%8A%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF-2021%E7%A7%8B%E3%80%8B%E7%BB%93%E8%AF%BE%E8%80%83%E8%AF%95%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>适用人群：中国矿业大学计算机科学与技术专业学生</p></blockquote><h1 id="2021秋期末真题"><a href="#2021秋期末真题" class="headerlink" title="2021秋期末真题"></a>2021秋期末真题</h1><blockquote><p>题干为个人回忆版本，并对覃航和王唯一提供的版本进行补充，已尽力与原题目描述保持一致。答案来自本人理解，不确保与老师理解完全一致。</p></blockquote><p>1、给出关于货币的自然语言描述：写正则表达式，画有限状态自动机，写代码。（难，考场上老师直接提醒了跳过去，先做后面的题）<br>2、最右推导，说明一个句型是该文法的句型；画出语法树；写出短语，直接短语，句柄。<br>3、LL（1），消除左递归，提取公共左因子，构造分析表。<br>4、LR（1），画出识别活前缀的DFA，构造分析表，说明为什么是LR（1）文法，写出句子的分析过程（考的分析失败！）。<br>5、while do - if then else - 布尔表达式和赋值语句，翻译成三地址代码。<br>6、给出文法和示例，构造翻译模式，写出递归下降子程序。（求嵌套深度，但不是括号的嵌套，L-属性文法。注意这里递归下降子程序是带语义动作的，以及不是所有的大写字母都是非终结符，要看具体问题描述。）</p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>给出关于货币的自然语言描述</p><ol><li>：写正则表达式，画有限状态自动机，写代码。（难，考场上老师直接提醒了跳过去，先做后面的题）</li></ol><blockquote><p>考动态规划-最大子段和。</p><ol><li>结合题目内容描述最大子段和算法即可。</li><li>$O(n)$</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>CUMT课程笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《算法导论-2021秋》课程小结</title>
    <link href="/2021/12/08/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-2021%E7%A7%8B%E3%80%8B%E7%BB%93%E8%AF%BE%E8%80%83%E8%AF%95%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/12/08/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-2021%E7%A7%8B%E3%80%8B%E7%BB%93%E8%AF%BE%E8%80%83%E8%AF%95%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>适用人群：中国矿业大学计算机科学与技术专业学生</p></blockquote><h1 id="2021秋期末真题"><a href="#2021秋期末真题" class="headerlink" title="2021秋期末真题"></a>2021秋期末真题</h1><blockquote><p>题干为个人回忆版本，同时，由黄凯同学提供第四题题干，并进行题干二次核对，已尽力与原题目描述保持一致。答案来自本人理解，不确保与老师理解完全一致。</p></blockquote><h2 id="第一题（10）"><a href="#第一题（10）" class="headerlink" title="第一题（10）"></a>第一题（10）</h2><p>给出了一个大整数乘法算法的描述，对于n位乘法，仅作3次n/2位的乘法和1次n位的加法即可</p><ol><li>根据题意写出递归公式（5）</li><li>求算法复杂度（5）</li></ol><blockquote><p>考概述-主定理法等。</p><script type="math/tex; mode=display">\begin{array}{X}T(n) =\left\{\begin{matrix}O(1)  & n=1\\3T(\frac{n}{2} ) + O(1) & n>1 \\\end{matrix}\right. \\\\O(n^{\log_32})\end{array}</script></blockquote><h2 id="第二题（10）"><a href="#第二题（10）" class="headerlink" title="第二题（10）"></a>第二题（10）</h2><p>现有程序设计比赛公示名单，已经按照学号非降序排列好了，现在插入学号为x的学生</p><ol><li>写出算法描述，如何找到x之前的学生的最大序号i和x之后的学生的最小序号j（5）</li><li>最坏情况下的算法复杂度（5）</li></ol><blockquote><p>考分治-二分搜索。</p><ol><li>结合题目内容描述二分搜索即可。（但我不是很理解为什么要说非降序排列，直接说升序排列不可以吗，难道有一个人学号出现多次，有重复元素吗，考试我是按照无重复元素写的），最后有<code>i = mid - 1</code>与<code>j = mid + 1</code></li><li>$O(\log n)$</li></ol></blockquote><h2 id="第三题（10）"><a href="#第三题（10）" class="headerlink" title="第三题（10）"></a>第三题（10）</h2><p>开了个小卖部，给出1-12月各月的盈利，含负数，负数就是亏损，求连续月份的最大盈利和</p><ol><li>写出算法描述（5）</li><li>最坏时间复杂度分析（5）</li></ol><blockquote><p>考动态规划-最大子段和。</p><ol><li>结合题目内容描述最大子段和算法即可。</li><li>$O(n)$</li></ol></blockquote><h2 id="第四题（20）"><a href="#第四题（20）" class="headerlink" title="第四题（20）"></a>第四题（20）</h2><p>体育馆预约，给出十个人预约的开始时间与结束时间，现在进行安排</p><ol><li>写出算法描述（10）</li><li>能安排多少人（5）</li><li>能安排哪些人（5）</li></ol><blockquote><p>考贪心-活动安排问题。</p><ol><li>结合题目内容描述活动安排算法即可。</li><li>算出来就出来了。</li><li>算出来就出来了。</li></ol></blockquote><h2 id="第五题（20）"><a href="#第五题（20）" class="headerlink" title="第五题（20）"></a>第五题（20）</h2><p>有五堆石子，数量已知</p><ol><li>只能取得两个相邻石子合并，这一次合并的代价是两堆石子数量之和，求合并成一堆最小代价（<a href="https://www.acwing.com/problem/content/284/">题目链接</a>）（10）</li><li>任意取得两个石子合并，这一次合并的代价是两堆石子数量之和，求合并成一堆的最小代价（10）</li></ol><blockquote><ol><li>考动态规划-石子合并。</li><li>考贪心-哈夫曼。</li><li>对于先入为主与考试时间分配策略问题，见感悟部分。</li></ol></blockquote><h2 id="第六题（15）"><a href="#第六题（15）" class="headerlink" title="第六题（15）"></a>第六题（15）</h2><p>打算法比赛，还有五个小时，还有五个题目没做，给出题目价值和预计AC题目时间，利用回溯法求最优解</p><ol><li>什么集合类型（5）</li><li>剪枝函数（5）</li><li>画树（5）</li></ol><blockquote><p>考回溯-01背包。</p><ol><li><p>子集树。</p></li><li><p>都是定义</p><p>分支剪枝：$cw&gt;c$</p><p>限界剪枝：$cp+cr \leq bestw$</p></li><li><p>都是定义，没啥说的。</p></li></ol></blockquote><h2 id="第七题（15）"><a href="#第七题（15）" class="headerlink" title="第七题（15）"></a>第七题（15）</h2><p>给出一个图，点是学生，线是学生存在闺蜜关系，求最大闺蜜团，要求利用分支限界法，利用优先队列。</p><p><img src="https://s2.loli.net/2021/12/10/rwO6NARU2zG5acW.png" style="zoom:50%;" /></p><ol><li>什么集合类型（5）</li><li>剪枝函数（5）</li><li>画树（5）</li></ol><blockquote><p>考分支限界-最大团问题。</p><ol><li><p>子集树（对于知识点记忆与考试时间分配策略问题，见感悟部分）</p></li><li><p>分支剪枝：存在当前加入的点与任意已成团的某个点在原图没有连线</p><p>限界剪枝：$num = c + r \leq best$</p><p>优先级：$num$</p></li><li><p>都是定义，没啥说的。（1,3,4,5）</p></li></ol></blockquote><h1 id="关于考试的感想"><a href="#关于考试的感想" class="headerlink" title="关于考试的感想"></a>关于考试的感想</h1><ol><li>考试整体时间感觉不是很充裕，如果每道题正常速度做完且不出错的话，应该只能预留出几分钟而已。</li><li>我的个人建议是，即便题干小问没有说明要你写出最后大题干计算得出答案，最好也要把大题干的实际问题答案给求出来，并且明示计算结果放在最后。</li><li>⚠<strong>关于第四大题</strong>：至于为什么第四题没有做，空白了，20分直接不要，是因为看到“合并石子”我就直接跳过了，其他的句子是<strong>一个字也没有多看</strong>，这是极为严重的错误。在我印象中很早就知道有合并石子这个题目，但是当时觉得很难，做不出来，后来学习算法之后也没有重新去学习该怎么做这个题（但是真的是很简单的…），因此条件反射看到“石子”我就认为自己不会做，导致直接跳题，甚至第二小问很简单的哈夫曼都没有注意到要去做。所以<strong>平时遇到不会的题目一定要及时去做，去分析相同点，多去遇见一些类似的题型，多刷题和总结，融会贯通。</strong></li><li>⚠<strong>关于第七大题</strong>：首先是复习不认真，算法知识点记得不牢固，子集树还是排列树纠结了很久（特别是前面一题已经考了子集树为什么还是考子集树，我觉得不应该…导致误判，至少有20分钟我在研究怎么画排列数，节点的字母写到UVW的时候开始怀疑自己是不是弄错了，然后醒悟过来了…我的节点优先级一直都没有变（因为如果按照排列树的话，$num$一直都等于原图节点数量，不像子集树一样会减小）然后是明知道画树已经非常麻烦了，又要重画，为什么不再重新看看第四大题，哪怕看一看题目都好，<strong>不要这么固执</strong>，可能也是时间已经很紧张了，心理作用，过分看重考试结果了，所以心态愈发不稳定。</li><li><strong>平时复习一定要全方位，第一是要课本知识记忆准确，第二是强调泛化能力，从课本脱离，应用到各个场景。</strong></li><li>这波是真的寄了，战前准备和战术上都极其失误，预估考试卷面70左右，平时分看老师了，学弟学妹们一定要好好学啊，血泪教训已经摆在这里了。</li></ol><h1 id="关于课程的感想"><a href="#关于课程的感想" class="headerlink" title="关于课程的感想"></a>关于课程的感想</h1><ol><li>上课的时候没有怎么认真听，注意力还是不够集中，其实认真听还是听得懂的，只是不能长期保持这种状态，老师教的还是不错的，就是不认真，课堂测验学压缩算法都是十分钟看ppt立马学会计算结果的，然后还算对了（所以感觉逼迫自己努力去学习的话，应该还是能学好的，也许不是自己学习能力的问题吧）基本上课程学会都是结课后看ppt，可能平时手机的影响确实是太大了…不够自律。上课时间还是要好好把握住的。</li><li>算法是计算机专业非常重要的一门课程，算法能力也体现一个计算机人的专业程度，程序设计竞赛考算法，面试需要算法，管饭碗的东西为什么不认真学呢。</li><li>也没有主动去多深入学习一下，特别是关于定理的证明，因为不考就不深入探究了，其实只是我们学校不考试，别的学校本科也会有考察的，可能研究生面试复试之类的也会考察。真要做只适应应试的做题家，肯定是走不远的。</li><li>算法虐我千百遍…哎…不会再爱了…挺不好受的，希望今后有空多看黑书，多看看MIT的算法导论课程，以及面试算法题，然后多加实践，多码代码，刷刷leetcode和acwing等面试相关算法题，加油。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>CUMT课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《实用优化算法-2021秋》课程小结</title>
    <link href="/2021/11/14/%E3%80%8A%E5%AE%9E%E7%94%A8%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95-2021%E7%A7%8B%E3%80%8B%E7%BB%93%E8%AF%BE%E8%80%83%E8%AF%95%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/11/14/%E3%80%8A%E5%AE%9E%E7%94%A8%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95-2021%E7%A7%8B%E3%80%8B%E7%BB%93%E8%AF%BE%E8%80%83%E8%AF%95%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="一维搜索"><a href="#一维搜索" class="headerlink" title="一维搜索"></a>一维搜索</h1><ul><li>黄金分割法（第一题考了这个，迭代两次就行，不过这次考的不是二次函数，加了一个cos函数，所以计算器计算的时候要注意设置为弧度制）</li><li>斐波那契法</li></ul><h1 id="无约束搜索"><a href="#无约束搜索" class="headerlink" title="无约束搜索"></a>无约束搜索</h1><ul><li>下降方向（第二题第一小问考了这个，给出函数，点，方向，确定是否为下降方向，就是定义）</li><li>最优性条件（第二题第二小问考了这个，直接函数求导为0求解就行，正定矩阵大于零，是极小点）</li><li>梯度下降法（第三题第一小问考了这个，迭代一次；第三题第二小问要求证明xk的坐标与k的关系式，应该是证明每次α的值都是一样的，推导一下就行，考试没想出来，应该是这里扣的三分）</li><li>牛顿法与阻尼牛顿法</li><li>共轭梯度法</li><li>拟牛顿法（第四题，DFP公式记牢）</li></ul><h1 id="有约束搜索"><a href="#有约束搜索" class="headerlink" title="有约束搜索"></a>有约束搜索</h1><ul><li>有效集、KKT点、λ、σ（第六题考了数形结合画图，求最小值点，对于最小值点求出该点的λ参数，注意比如1≤x≤5是两个条件，要转换成x≥1与-x+5≥0才行）</li><li>外罚函数法</li><li>内罚函数法/内点法/障碍函数法（第五题考了这个，障碍函数使用对数函数，不等式约束，最后好像求出了两个点，都计算一下取最小值）</li><li>增广拉格朗日/乘子法（第七题考了这个，等式约束）</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>最后老师发的练习题还是很管用的，好好做两遍，第一遍学算法步骤，第二遍验证计算能力，就差不多了</li><li>学的知识很多，考的内容还好，主要是计算要准确，考试给的数字不难，大多可以手算，很少用到计算器，但是不要不带计算器，第一题还是需要的，有一题画图，所以最好带上铅笔直尺</li><li>公式一定要记准确</li><li>有的算到最后和结论不一样就知道要再算一遍，比如拟牛顿法二次函数计算x2时g2肯定为0也就是结束计算，算出来g2不对就要返回去检查计算了</li><li>好多题做完第一遍后检查可以利用数形结合，基本上约束条件和函数比较好画，都是直线，椭圆，二次函数之类的，画个简单的图形判断最优解就知道自己算的对不对了，第一遍自己算错了三个，然后画图之后好像都改对了</li><li>考了97，平时分98，总评98。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CUMT课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《算法导论》笔记</title>
    <link href="/2021/10/26/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/10/26/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><p><strong>重要特性</strong>  输入、输出、确定性、有限性</p><p><strong>算法描述</strong>  自然语言、流程图、伪代码、程序代码</p><p><strong>算法的复杂性</strong>  时间复杂性、空间复杂性</p><p><strong>算法的渐进性态</strong></p><p>$O(g(n))$ 上界</p><p>$Ω(g(n))$ 下界</p><p>$Θ(g(n))$ 确界</p><p>$logn &lt; n &lt; nlogn &lt; n^2 &lt; n^3 &lt;2^n$</p><p><strong>NP完全理论</strong>  能在多项式时间内求解的判定性问题称为P问题，在多项式时间能验证猜测解的正确性为NP问题</p><h1 id="递归与分治"><a href="#递归与分治" class="headerlink" title="递归与分治"></a>递归与分治</h1><h2 id="递归概念"><a href="#递归概念" class="headerlink" title="递归概念"></a>递归概念</h2><p><strong>递归定义</strong>  用函数自身定义的函数 GNU is Not Unix</p><p><strong>递归函数两个要素</strong>  边界条件与递归方程</p><p><strong>满足条件</strong>  可转化（可以转化为一个或者多个子问题，子问题的求解方法与原问题完全相同，只在规模上不同）、调用次数有限、有结束递归的条件来终止递归，并不是所有递归都可以转换</p><p><strong>何时使用递归</strong>  定义是递归的（斐波那契），数据结构是递归的（链表），问题的求解方法是递归的（汉诺塔，数的排列）</p><p><strong>递归算法转化为非递归算法</strong></p><ol><li><p>直接转化法：直接用循环结构的算法替代递归算法，不需要使用栈</p></li><li><p>用栈模拟系统的运行过程，通过分析只保存必须保存的信息，从而用非递归算法替代递归算法，需要使用栈</p></li></ol><h2 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Template&lt;class type&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Perm</span><span class="hljs-params">(Type list[], <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//递归地产生所有前缀是list[0:k-1],且后缀是list[k:m]的全排列的所有</span><br><span class="hljs-keyword">if</span> (k==m) &#123; <span class="hljs-comment">//只剩下一个元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++) cout&lt;&lt;list[i];<br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">//还有多个元素，递归产生后缀是list[k:m] 的全排列</span><br><span class="hljs-keyword">for</span>(i=k;i&lt;=m;i++) &#123;<br><span class="hljs-built_in">Swap</span>(list[k],list[i]);<br>    <span class="hljs-built_in">Perm</span>(list,k+<span class="hljs-number">1</span>,m);<br>    <span class="hljs-built_in">Swap</span>(list[k],list[i]); <span class="hljs-comment">//记得还原</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h2><p>对于数据n，最大加数不大于m的划分个数记作q(n,m)</p><script type="math/tex; mode=display">q(n,m) = \left\{\begin{matrix}1  & n = 1,m = 1\\ q(n,n) &n<m \\ 1+q(n,n-1) &n = m \\ q(n,m-1)+q(n-m,m) &n>m>1\end{matrix}\right.</script><h2 id="分治概念"><a href="#分治概念" class="headerlink" title="分治概念"></a>分治概念</h2><p><strong>设计思想</strong>  将一个难以直接解决的大问题，分割成一些规模较小的子问题，这些子问题互相独立且与原问题相同，从而递归地解子问题，将各个子问题的解合并得到原问题的解</p><p><strong>适用问题</strong>  该问题可以分解为若干个规模较小的相同问题；该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题；该问题的规模缩小到一定的程度就可以容易地解决；利用该问题分解出的子问题的解可以合并为该问题的解</p><p><strong>求解过程</strong> 分解、求解、合并</p><p><strong>时间复杂性计算</strong>  扩展递归技术、递归树、主定理方法</p><p><strong><em>▲主定理方法</em></strong>  T(n)=aT(n/b)+f(n)，其中a≥1，b&gt;1为常数，该方程描述了算法的执行时间，算法将规模为n的问题分解成a个子问题，每个子问题的大小为n/b。比较两个式子大小即可</p><script type="math/tex; mode=display">T(n) = aT(\frac{n}{b} ) + f(n) =\left\{\begin{matrix}O(n^{log_{b}a } )  & n^{log_{b}a} > f(n)\\O(n^{log_{b} a }log_2 n) & n^{log_{b}a} = f(n) \\O(f(n)) & n^{log_{b}a} < f(n)\end{matrix}\right.</script><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p><strong>问题描述</strong>  给定已按升序排好序的n个元素a[1:n]，现要在这n个元素中找出一特定元素x</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BinarySearch</span><span class="hljs-params">(Type a[ ], <span class="hljs-keyword">const</span> Type &amp;x,<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> right=n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br><span class="hljs-keyword">int</span> middle=(left+right)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(x==a[middle])<br><span class="hljs-keyword">return</span> middle;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&gt;a[middle])<br>left=middle+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>right=middle<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释</strong></p><p>指针left在什么情况下会超过right?</p><p>Left指针向左移动, right指针向右移动，如果一直没有找到结果，那么这两个指针最终会重叠，指向同一个位置。 此时队列中只剩下一个元素。</p><p>此时，left=right； 因此middle=left=right；</p><p>如果这个元素满足x==a[middle]，程序结束 return middle；</p><p>否则如果x&gt;a[middle], left=middle+1后，left将位于right的右边；</p><p>否则如果x&lt;a[middle], right=middle-1后，right将位于left的左边</p><h2 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h2><p><strong>问题描述</strong>  XY是n位二进制整数，计算他们的乘积XY</p><script type="math/tex; mode=display">\begin{array}  {X}X=A2^{\frac{n}{2}}+B, Y=C2^{\frac{n}{2}}+D \\   XY = AC2^n+(AD+BC)2^{\frac{n}{2} }+BD  \\  =AC2^n+((A-B)(D-C)+AC+BD)2^{\frac{n}{2}}+BD \\  T(n) = O(n^{log3}) =\left\{\begin{matrix}O(1)  & n=1\\3T(\frac{n}{2} ) + O(n) & n>1 \\\end{matrix}\right.\end{array}</script><h2 id="Strassen乘法"><a href="#Strassen乘法" class="headerlink" title="Strassen乘法"></a>Strassen乘法</h2><p><strong>问题描述</strong>  计算两个矩阵相乘的结果，分块矩阵计算</p><script type="math/tex; mode=display">\begin{array}  {X}  T(n) = O(n^{3}) =\left\{\begin{matrix}O(1)  & n=1\\8T(\frac{n}{2} ) + O(n^2) & n>1 \\\end{matrix}\right.\end{array}</script><p><strong>解释</strong>  两个 n/2×n/2 的矩阵相加： 一行需要n/2次加法，共有n/2行，因此，两个矩阵相加的复杂度为 n/2×n/2=n^2/4，四次矩阵相加的复杂度为 O(n^2)</p><p><strong>改进算法</strong>  只需要七次乘法</p><h2 id="棋盘覆盖"><a href="#棋盘覆盖" class="headerlink" title="棋盘覆盖"></a>棋盘覆盖</h2><p><strong>问题描述</strong>  2^k阶的棋盘中只有一个方格残缺，要求用L型骨牌覆盖残缺棋盘上的所有方格且任何2个L型骨牌不得重叠覆盖，用递推求解时间复杂度</p><script type="math/tex; mode=display">\begin{array}  {X}  T(k) = O(4^{k}) =\left\{\begin{matrix}O(1)  & k=0\\4T(k-1 ) + O(1) & k>0 \\\end{matrix}\right.\end{array}</script><p><strong>解释</strong>  测试哪个子棋盘残缺以及形成3个残缺子棋盘需要O(1) ，覆盖4个残缺子棋盘（ 2^(k-1)阶）需四次递归调用，共需时间4T(k-1)</p><h2 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h2><p><strong>问题描述</strong> 数组排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">temlplate  &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">type</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(Type a[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function">  </span>&#123;   <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>eft &lt; right) <span class="hljs-comment">//至少有2个元素</span><br>       &#123;  <br>       <span class="hljs-keyword">int</span> i = (left + right ) /<span class="hljs-number">2</span>; <span class="hljs-comment">//取中点</span><br>       <span class="hljs-built_in">MergeSort</span>(a, <span class="hljs-number">1</span>eft, i)；<br>       <span class="hljs-built_in">MergeSort</span>(a, i+<span class="hljs-number">1</span>, right)；<br>       <span class="hljs-built_in">Merge</span>(a, b, <span class="hljs-number">1</span>eft, i, right)；<span class="hljs-comment">//从a合并到数组b</span><br>       <span class="hljs-built_in">copy</span>(a, b, left, right);<span class="hljs-comment">//复制回数组a</span><br>     &#125;<br> &#125;    <br></code></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{array}  {X}  T(n) = O(nlogn) =\left\{\begin{matrix}O(1)  & n=1\\2T(\frac{n}{2} ) + O(n) & n>1 \\\end{matrix}\right.\end{array}</script><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>问题描述</strong> 数组排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSoft</span><span class="hljs-params">(Type a[], <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(p&lt;r) &#123;<br>        <span class="hljs-keyword">int</span> q=<span class="hljs-built_in">Partition</span>(a, p, r)<br>        <span class="hljs-comment">//找到q的位置</span><br>        <span class="hljs-comment">//同时确保该位置右边的比基准元素大，左边的比基准元素小</span><br>        <span class="hljs-built_in">QuickSort</span>(a, p, q<span class="hljs-number">-1</span>); <span class="hljs-comment">//对左半段排序</span><br>        <span class="hljs-built_in">QuickSoft</span>(a, q+<span class="hljs-number">1</span>, r); <span class="hljs-comment">//对右半段排序</span><br>        &#125;<br>     &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(Type a[],<span class="hljs-keyword">int</span> p , <span class="hljs-keyword">int</span> r )</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = p; j = r+<span class="hljs-number">1</span>;<br>    type x = a[p];<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123; <br>         <span class="hljs-keyword">while</span>(a[++i] &lt; x &amp;&amp; i &lt; r);<br>         <span class="hljs-keyword">while</span>(a[--j] &gt; x);<br>         <span class="hljs-keyword">if</span> (i &gt;= j) <span class="hljs-keyword">break</span>;<br>         <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>    &#125;<br>    <span class="hljs-built_in">swap</span>(a[p], a[j]);<br>    <span class="hljs-keyword">return</span> j;<br>&#125;<br><br><span class="hljs-comment">//随机选择基准点的快速排序</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">randomizedQuickSoft</span><span class="hljs-params">(Type a[], <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p&lt;r) &#123;<br>        <span class="hljs-keyword">int</span> q=<span class="hljs-built_in">randomizedPartition</span>(a, p, r);<br>        <span class="hljs-built_in">randomizedQuickSort</span>(a, p, q<span class="hljs-number">-1</span>); <span class="hljs-comment">//对左半段排序</span><br>        <span class="hljs-built_in">randomizedQuickSoft</span>(a, q+<span class="hljs-number">1</span>, r); <span class="hljs-comment">//对右半段排序</span><br>        &#125;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">randomizedPartition</span><span class="hljs-params">(Type a[], <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-built_in">random</span>(p, r);<br>    <span class="hljs-built_in">swap</span>(a[i], a[p]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Partition</span> (a,p,r);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释</strong></p><ol><li>步骤<ul><li>分解：以a[p]为基准元素将a[p:r]划分成3段a[p:q-1],a[q]和a[q+1:r]，使a[p:q-1]中任意一个元素小于等于a[q]，而a[q+1:r]中任何一个元素大于等于a[q]，下标q在划分过程中确定</li><li>递归求解：通过递归调用快速排序算法分别对a[p:q-1]和a[q+1:r]进行排序</li><li>合并</li></ul></li><li>最坏情况，已经排好，O(n^2)</li><li>最好情况，每次划分大小都是n/2，O(nlogn)</li></ol><p><img src="https://i.loli.net/2021/10/26/Gm4dM5kU1rN2K9Y.jpg" style="zoom:67%;" /></p><h2 id="线性时间选择"><a href="#线性时间选择" class="headerlink" title="线性时间选择"></a>线性时间选择</h2><p><strong>问题描述</strong> </p><p>无序排列中求n个元素中第k小的元素（主要求中位数）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span><br><span class="hljs-function">Type <span class="hljs-title">RandomizedSelect</span> <span class="hljs-params">(a[], <span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p==r) <span class="hljs-keyword">return</span> a[p];<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-built_in">RandomizedPartition</span>(a, p, r), <span class="hljs-comment">//前面有</span><br>    j = i-p+l  <span class="hljs-comment">//统计前半部分元素个数j,  i为基准点</span><br>    <span class="hljs-keyword">if</span> ( k &lt;= j )<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">RandomizedSelect</span>(a, p, i, k);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">RandomizedSelect</span>(a, i+<span class="hljs-number">1</span>, r, k-j);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释</strong></p><p>根据随机产生的基准点，将元素分为2组，基准点包含在第1组中；如果k&lt;=j，则第k小元素落在a段，为a段的第k小元素；如果k&gt;j，则a段的所有元素都比第k小元素还要小，第k小元素落在b段，为b段中的第k-j小元素（-j的含义是去掉a段的元素总个数）</p><p>最坏情况，分成两个1和n-1的子问题，O(n^2)</p><p>最好情况，每次都产生n/2大小的子问题，O(n)</p><p><strong>基准点选择优化</strong></p><p>例如可以分成五个组，取每组中位数的中位数。设所有元素互不相同。在每一组中有2个元素小于本组的中位数，而n/5个中位数中又有(n-5)/10个小于基准x,因此，找出的基准x至少比3(n-5)/10个元素大。同理，基准x也至少比3(n-5)/10个元素小。当n≥75时，3(n-5)/10≥n/4所以按此基准划分所得的2个子数组的长度都至少缩短1/4。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Type <span class="hljs-title">Select</span><span class="hljs-params">(Type a[], <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (r-p&lt;<span class="hljs-number">75</span>) &#123;<br>        TO DO<span class="hljs-comment">//用某个简单排序算法对数组a[p:r]排序;</span><br>        <span class="hljs-keyword">return</span> a[p+k<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;=(r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">5</span>; i++ ) &#123;<br>        <span class="hljs-comment">//将a[p+5*i]至a[p+5*i+4]的第3小元素与a[p+i]交换位置;</span><br>        Type x = <span class="hljs-built_in">Select</span>(a, p, p+(r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">5</span>, (r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-built_in">Partition</span>(a,p,r, x),<br>        j=i-p+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (k&lt;=j) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Select</span>(a,p,i,k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">Select</span>(a,i+<span class="hljs-number">1</span>,r,k-j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>例题</strong></p><p>a=[2,6,9,1,4,10,20,6,22,11,10,9,4,3,7,16,11,8,2,5,4,1]</p><p>寻找第5小元素</p><p>(要求两个中位数选择较小的一个，支点放在第一个列表中)</p><p><strong>解答</strong></p><p>$n=22$，分组如下</p><p>[2,6,9,1,4] [10,20,6,22,11] [10,9,4,3,7] [16,11,8,2,5] [4,1]</p><p>中位数集合[4, 11, 7, 8, 4]，选择中位数的中位数为7作为支点</p><p>把支点放在第一个列表中</p><p>划分a[0:11]=[2, 6, 1, 4, 6, 4, 3, 2, 5, 4, 1, 7]<br>       a[12:21]=[9, 10, 20, 22, 11, 10, 9, 16, 11, 8] </p><p>对a[0:11]继续分组 [2,6,1,4,6],[4,3,2,5,4],[1]</p><p>中间元集合:[4,4,1]，中间元的中间元为4作为支点</p><p>把支点放在第一个列表中，划分：[2,1,4,4,3,2,4,1] [6,6,5]</p><p>对a[0:7]继续分组 [2,1,4,4,3],[2,4,1]</p><p>中间元集合:[3,2]，中间元的中间元为2作为支点</p><p>划分：[2,1,2,1] [4,4,3,4]</p><p>第一组小于5了</p><p>取第二组第5-4=1小的，也就是3</p></blockquote><h2 id="最接近点对"><a href="#最接近点对" class="headerlink" title="最接近点对"></a>最接近点对</h2><p><strong>一维情况</strong></p><p>1) 将S上的n个点分成大致相等的2个子集S1和S2<br>2) 分别求S1和S2中的最接近点对<br>3) 求一点在S1、另一点在S2中的最接近点对<br>4) 从上述三对点中找距离最近的一对</p><p><strong>二维情况</strong></p><ol><li>m为S中各点x间坐标的中位数，构造S1和S2    O(n)</li><li>递归求S1和S2的最小距离    2T(n/2)</li><li>求上述两个距离的最小值dm</li><li>设P1是S1中距垂直分割线l的距离在dm之内的所有点组成的集合；P2是S2中距分割线l的距离在d之内所有点组成的集合；将P1和P2中的点依其y坐标值排序；并设X和Y是相应的已排好序的点列    O(nlogn)</li><li>通过扫描X以及对于X中每个点检查Y中与其距离在dm之内的所有点(最多6个)可以完成合并；当X中的扫描指针逐次向上移动时，Y中的扫描指针可在宽为2dm的区间内移动；设dl是按这种扫描方式找到的点对间的最小距离；    O(n)</li><li>选择dm dl的最小值</li></ol><h2 id="循环赛日程表"><a href="#循环赛日程表" class="headerlink" title="循环赛日程表"></a>循环赛日程表</h2><p><strong>问题描述</strong>  设有n(n = 2^k)位选手参加网球循环赛，循环赛共进行n-1天，每位选手要与其他n-1位选手比赛一场，且每位选手每天必须比赛一场，不能轮空。</p><p><strong>发现规律</strong></p><p><img src="https://s2.loli.net/2021/12/07/y2EaPBCRoXkjQWO.png" alt="" style="zoom: 67%;" /></p><p><img src="https://s2.loli.net/2021/12/06/U93fnXqQmOthd68.png" style="zoom:50%;" /></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>基本思想</strong>  基本思想是在对一个多阶段决策的问题，按照某一顺序，根据每一步所选决策的不同，会引起状态的转移，最后会在变化的状态中获取到一个决策序列。</p><p><strong>基本要素</strong></p><ol><li>最优子结构性质（分析问题是否满足最优性原理（用反证法）：①先假设由问题的最优解导出的子问题的解不是最优的；②再证明在这个假设下可构造出比原问题最优解更好的解，从而导致矛盾）</li><li>子问题重叠性质（子问题不相互独立，重复出现，只在第一次遇到时加以求解，并把答案保存起来，以后再遇到时不必重新求解）</li></ol><p><strong>算法步骤</strong></p><ol><li>分析最优解的性质，并刻画其结构特征；</li><li>递归地定义最优值；</li><li>以自底向上或自顶向下的方式计算出最优值；</li><li>根据递归计算最优值时得到的信息，从子问题的最优解逐步构造出整个问题的最优解。</li></ol><h2 id="矩阵连乘"><a href="#矩阵连乘" class="headerlink" title="矩阵连乘"></a>矩阵连乘</h2><p><strong>问题描述</strong>  每计算出一个元素，需要q次乘法，最终得到的矩阵是p×r矩阵，有p×r个元素，因此，计算C需要的乘法次数为q×p×r。每次要选择较小的q×p×r。给定n个矩阵｛A1,A2,…,An｝，其中Ai与Ai+1是可乘的，且i=1,2⋯,n-1,如何确定计算矩阵连乘积的计算次序，使得计算矩阵连乘的数乘次数最少。</p><script type="math/tex; mode=display">m[i][j]=\left\{\begin{array}{cc}0 & i=j \\\min_{i\leq{k}<j} \{m[i][k]+m[k+1][j]+p_{i-1}p_kp_j\} & i<j\end{array}\right.</script><p><strong>解释</strong>  矩阵连乘积从Ai到Aj定义为A[i:j]，A[i:j]最少的乘法次数定义为m[i,j]，最优断开位置k记为𝑠[i,j]=k，T(n)=O(n^3)</p><blockquote><p><strong>例题</strong></p><p>计算矩阵连乘积A[1:6]的最少数乘次数，其中各矩阵的维数分别为p=[30,35,15,5,10,20,25]</p><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{matrix}𝑚[1][2]=𝑚[1][1]+𝑚[2][2]+p_0p_1p_2=15750\\𝑚[2][3]=𝑚[2][2]+𝑚[3][3]+p_1p_2p_3=2650\\...\\m[1][3]= \min \left\{\begin{matrix}m[1][1]+m[2][3]+p_0p_1p_3=7875▲\\m[1][2]+m[3][3]+p_0p_2p_3=18000\end{matrix}\right.\\s[1][3]=1\\...\\m[2][6]= \min \left\{\begin{matrix}  m[2][2]+m[3][6]+p_1p_2p_6=0+5375+35*15*25=18500\\m[2][3]+m[4][6]+p_1p_3p_6=2625+3500+35*5*25=10500▲\\m[2][4]+m[5][6]+p_1p_4p_6=4375+5000+35*10*25=18125\\m[2][5]+m[6][6]+p_1p_5p_6=7125+0+35*20*25=24625\end{matrix}\right.\\s[2][6]=3\\...\end{matrix}</script><div class="table-container"><table><thead><tr><th style="text-align:center">m</th><th style="text-align:center">A1</th><th style="text-align:center">A2</th><th style="text-align:center">A3</th><th style="text-align:center">A4</th><th style="text-align:center">A5</th><th style="text-align:center">A6</th></tr></thead><tbody><tr><td style="text-align:center">A1</td><td style="text-align:center">0</td><td style="text-align:center">15750</td><td style="text-align:center">7875</td><td style="text-align:center">9375</td><td style="text-align:center">11875</td><td style="text-align:center"><strong>15125</strong></td></tr><tr><td style="text-align:center">A2</td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">2625</td><td style="text-align:center">4375</td><td style="text-align:center">7125</td><td style="text-align:center">10500</td></tr><tr><td style="text-align:center">A3</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">750</td><td style="text-align:center">2500</td><td style="text-align:center">5375</td></tr><tr><td style="text-align:center">A4</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1000</td><td style="text-align:center">3500</td></tr><tr><td style="text-align:center">A5</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">5000</td></tr><tr><td style="text-align:center">A6</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">s</th><th style="text-align:center">A1</th><th style="text-align:center">A2</th><th style="text-align:center">A3</th><th style="text-align:center">A4</th><th style="text-align:center">A5</th><th style="text-align:center">A6</th></tr></thead><tbody><tr><td style="text-align:center">A1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center"><strong>1</strong></td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center"><strong>3</strong></td></tr><tr><td style="text-align:center">A2</td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">A3</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">A4</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">4</td><td style="text-align:center"><strong>5</strong></td></tr><tr><td style="text-align:center">A5</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">A6</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td></tr></tbody></table></div><p>从右上角的元素开始分割，从A3后面分为A[1,3]与A[4,6]，s[1,3]=1，从A1后面拆分，s[4,6]=5，从A5后面拆分，<strong>得到((A1(A2A3)((A4A5)A6)，次数最少是15125</strong></p></blockquote><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LCSLength</span></span><br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> *x, <span class="hljs-keyword">char</span> *y,<span class="hljs-keyword">int</span> c[][], <span class="hljs-keyword">int</span> b[][])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;m;i++) c[i][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;n;i++) c[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-comment">//m,n是X和Y的长度</span><br>            <span class="hljs-keyword">if</span> (x[i]==y[j]) &#123;<br>                c[i][j]=c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>                b[i][j]=<span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c[i<span class="hljs-number">-1</span>][j]&gt;=c[i][j<span class="hljs-number">-1</span>]) &#123;<br>                c[i][j]=c[i<span class="hljs-number">-1</span>][j];<br>                b[i][j]=<span class="hljs-number">2</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                c[i][j]=c[i][j<span class="hljs-number">-1</span>];<br>                b[i][j]=<span class="hljs-number">3</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LCS</span><span class="hljs-params">(i, j, X, b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span> || j==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (b[i,j]==<span class="hljs-string">&quot;1&quot;</span> ) &#123;<br>        <span class="hljs-built_in">LCS</span>(i<span class="hljs-number">-1</span>, j<span class="hljs-number">-1</span>, x, b);<br>        cout &lt;&lt;x[i];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b[i,j]==<span class="hljs-string">&quot;2&quot;</span> ) <br>       <span class="hljs-built_in">LCS</span>(i<span class="hljs-number">-1</span>, j, x, b);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">LCS</span>(i, j<span class="hljs-number">-1</span>, x, b);<br>&#125;   <span class="hljs-comment">//计算复杂性：O(m+n)</span><br><span class="hljs-comment">//LCS(i, j, X, b)实现根据b的内容打印出Xi与Yj的最长公共子序列。</span><br><span class="hljs-comment">//调用LCS(m,n,x,b) 可打印出序列X和Y的最长公共子序列。</span><br></code></pre></td></tr></table></figure><script type="math/tex; mode=display">c[i][j]=\left\{\begin{array}{cc}0 & i=0, j=0 \\c[i-1][j-1]+1 & i, j>0 ; x_{i}=y_{j} \\\max \{c[i-1][j], c[i][j-1]\} & i, j>0 ; x_{i} \neq y_{j}\end{array}\right.</script><p><strong>解释</strong>  c[i,j]记录序列Xi和Yj的最长公共子序列长度，b[i,j]可以记录是哪种类型。在c表中从最右下角的那个元素开始，看b表中对应位置的值，如果为1，则在c表中从当前位置往左上角走；如果为2，则在c表中从当前位置往正上方走；如果为3，则在c表中从当前位置沿水平方向往后退一位；依次类推，直到c表中箭头退到c[0，0]为止。</p><p><strong>补充</strong>  两个序列的最长公共子序列不唯一，不影响最长公共子序列的长度；但是可能会产生不一样的公共子序列，见例题</p><blockquote><p><strong>例题</strong></p><p>给定两个序列为X=ABCBDAB和Y=BDCABA，求最长公共子序列。</p><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{matrix}i=1,X_1=\{A\}\\j=1,Y_1=\{B\},𝑐[1][1]=\max⁡\{ 𝑐[0][1],𝑐[1][0]\}=0, b[1][1]=2 or 3\\j=2,Y_2=\{BD\},𝑐[1][2]=\max⁡\{ 𝑐[0][2],𝑐[1][1]\}=0, b[1][2]=2\\...\\j=4,Y_4=\{BDCA\},𝑐[1][4]=c[0][3]+1=1, b[1][4]=1\\...\\i=7,X_7=\{ABCBDAB\}\\j=6,Y_6=\{BDCABA\},\max⁡\{ 𝑐[6][6],𝑐[7][5]\}=4, b[7][6]=2 or 3\end{matrix}</script><p><img src="https://i.loli.net/2021/11/03/AiVcQH3dqO6XTpa.png" alt="c表与b表" style="zoom:50%;" /></p><p>斜线箭头尾部位置对应的元素为公共子序列元素（下标从1开始），也就是有BCBA（x[2346]与y[1356]）\BCAB（x[2367]与y[1345]）\BDAB（x[4567]与y[1245]）</p><p>PS: 对于C[1,1]=max{c[0,1],c[1,0]}={0,0}=0等情况，此时，b[1,1]=2或3都可以，不影响最终的结果。可能有多个答案。</p></blockquote><h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><p><strong>问题描述</strong> n个整数组成的序列，求该序列连续子段和的最大值（规定当所有<br>整数均为负整数时定义其最大子段和为0）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MaxSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> *a)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>, b=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (b&gt;<span class="hljs-number">0</span>) b+=a[i];<br>        <span class="hljs-keyword">else</span> b=a[i];<br>        <span class="hljs-keyword">if</span> (b&gt;sum) sum=b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><script type="math/tex; mode=display">b[j]= \min\{b[j-1]+a[j],a[j]\}(1\leq j \leq n)</script><p><strong>解释</strong> b[j]为以a[1,j]之间的任一位置开始，以a[j]为结束的最大子段和（必须要到j才行）。从i开始，到j-1结束的子段和的最大值&lt;=0，从i开始到j结束的子段和的最大值应该为a[j]自身。从i开始，到j-1结束的子段和的最大值大于0，此时，将a[j]加上（不是因为如果a[j]小于零就不加了，b[j]的定义就是要加到j），所得到的值应该是从i开始，到j结束的子段和的最大值。 O(n)</p><blockquote><p><strong>例题</strong></p><p>a[1:6]=[-2,11,-4,13,-5,-2]</p><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{matrix}j=1,𝑏[1]=\max\{𝑏[0]+𝑎[1],𝑎[1]\}=-2,i=1\\j=2,𝑏[2]=\max\{𝑏[1]+𝑎[2],𝑎[2]\}=11,i=2\\j=3,𝑏[3]=\max\{𝑏[2]+𝑎[3],𝑎[3]\}=11-4=7,i=2\\j=4,𝑏[4]=\max\{𝑏[3]+𝑎[4],𝑎[5]\}=7+13=20,i=2\\j=5,𝑏[5]=\max\{𝑏[4]+𝑎[5],𝑎[5]\}=20-5=15,i=2\\j=6,𝑏[6]=\max\{𝑏[5]+𝑎[6],𝑎[6]\}=15-2=13,i=2\end{matrix}</script><p>比较各个$b[i]$，其中最大的就是最大子段和，也就是$b[4]=20$,$i=2$开始，$j=4$结束，也就是$[11,-4,13]$</p></blockquote><h2 id="凸多边形最优三角剖分"><a href="#凸多边形最优三角剖分" class="headerlink" title="凸多边形最优三角剖分"></a>凸多边形最优三角剖分</h2><p><strong>问题描述</strong>  给定一个凸多边形以及定义在由多边形的边和弦组成的三角形上的权函数$w$。求一个三角剖分，使得剖分中诸三角形上的权之和为最小。 </p><script type="math/tex; mode=display">t[i][j]=\left\{\begin{array}{cc}0 & i=j \\\min_{i\leq{k}<j} \{t[i][k]+t[k+1][j]+w(v_{i-1}v_kv_j)\} & i<j\end{array}\right.</script><p><strong>解释</strong></p><p>定义$t[i][j]$为凸子多边形的最优剖分对应权函数值， $s[i][j]$记录了$v_{i-1}$和$ v_j$一起构成三角形的第3个顶点$k$的位置，据此，用$O(n)$时间就可以构造出<br>最优三角剖分中的所有三角形。</p><p>计算最优值与矩阵连乘积相似。计算凸$n+1$多边形的最优值为$ t[1][n]$</p><blockquote><p><strong>例题</strong></p><p>（好难算啊不会考吧）</p><p><img src="https://s2.loli.net/2021/12/07/isJWTNkCPd4ORfS.png" style="zoom:50%;" /></p><p><img src="https://s2.loli.net/2021/12/07/sTxqwMUX5JoyA3g.png" style="zoom:50%;" /></p><p><img src="https://s2.loli.net/2021/12/07/ViKmFwAuHB3PQ27.png" style="zoom:50%;" /></p><p><img src="https://s2.loli.net/2021/12/07/8d7TXheayMsRpr1.png" style="zoom:50%;" /></p><p><img src="https://s2.loli.net/2021/12/07/PUfmEldrnXp9W8B.png" style="zoom:50%;" /></p></blockquote><h2 id="图像压缩"><a href="#图像压缩" class="headerlink" title="图像压缩"></a>图像压缩</h2><p><strong>问题描述</strong>  数字化图像是的像素阵列。假定每个像素有一个0~255的灰度值，存储一个像素需8位。为了减少存储空间，采用变长模式，即不同像素用不同位数来存储。</p><ol><li>线性化：图片拉直，转换为$1×n^2$向量</li><li>分段：分成连续的$m$段，每段像素存储位数相同，每段最多含256个像素点</li><li>存放信息：第$i$段长度（8bit），第$i$段中像素存储位数（3bit）</li></ol><script type="math/tex; mode=display">\begin{matrix}s[i]=\min\limits_{1 \leq k \leq \min \{i,256\}}\{s[i-k]+k*bmax(i-k+1,i)  \}+11\\bmax(i,j)=\max\limits_{i\leq k \leq j}\{a[k]\}\end{matrix}</script><p><strong>解释</strong></p><p>假设$s[i]$是序列${p_1,p_2,…,p_i}$的最优解，$a[i]$是第i个像素点的位数。</p><ol><li>假设$p_i$自成一段，则$s[i]=s[i-1]$+保存$p_i$的代价</li><li>取$s[i]$为min时对应的元素个数为$k$，$s[i]=s[i-k]$+保存最后$k$个像素的代价</li><li>保存最后$k$个像素的代价=$k*max${$k$个灰度值二进制位数}+11</li></ol><blockquote><p><strong>例题</strong></p><p>求像素序列4，6，5，7，129，138，1的最优分段。</p><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{matrix}a=[3,3,3,3,8,8,1]\\s[0]=0\\s[1]=s[0]+1*\max \{3\} +11=14\\s[2]= \min \left\{\begin{matrix}s[0]+2* \max \{3,3\} + 11 = 17▲\\s[1] + 1*\max \{3\} +11 =28\end{matrix}\right.\\...\\s[7]= \min \left\{\begin{matrix}s[0]+7* \max \{3,3,3,3,8,8,1\} + 11 = 67\\s[1]+6* \max \{3,3,3,8,8,1\} + 11 = 73\\...\\s[4]+3* \max \{8,8,1\} + 11 = 58▲\\...\\s[6]+1* \max \{1\} + 11 = 62\end{matrix}\right.\end{matrix}</script><p>看s[7]=58，看58那一行是s[4]+3*max，前四个一起，后三个一起</p><p>看s[4]=23，看23那一行是s[0]+4*max，前四个就在一起，不再分</p><p>最后得到（4，6，5，7）（129，138，1）</p><p>ps每次计算比大小可以不加上11但是最后求$s$的时候别忘了加11</p></blockquote><h2 id="电路布线"><a href="#电路布线" class="headerlink" title="电路布线"></a>电路布线</h2><p><strong>问题描述</strong> 确定将哪些连线安排在第一层上，使得该层上有尽可能多的连线且不相交</p><script type="math/tex; mode=display">\begin{matrix} i=1, \qquad Size(i,j) = \left\{\begin{matrix}0 && j<\pi(1)\\1 && j \geq \pi (1)\end{matrix}\right.\\\\i>1,\qquad Size(i,j) = \left\{\begin{matrix}Size(i-1,j) && j<\pi(i)\\\max \{ Size(i-1,j),Size(i-1,\pi(i)-1)+1\} && j \geq \pi (i)\end{matrix}\right.\end{matrix}</script><p><strong>解释</strong>  MNS(i,j)表示上面序号小于i，连接到下面的序号都小于j的不相交的集合，最后要求MNS(n,n)。如果j<pi(i)，(i,pi(i)）不在MNS中，将i点删除没有影响。如果j>=pi(i)，如果（i,pi(i)）不在MNS中，将i点删除没有影响，就是size(i,j)=size(i-1,j)，如果（i,pi(i)）在MNS中，就是size(i,j)=size(i-1,pi(i)-1)+1</p><blockquote><p><strong>例题</strong></p><p>已知[(1 8)(2 7)(3 4)(4 2)(5 5)(6 1)(7 9)(8 3)(9 10)(10 6)]，求最大不相交情况</p><p><strong>解答</strong></p><p>i=1，pi(1)=8，j&gt;=<strong>8</strong>的size都为1</p><p>i=2，pi(2)=7，j&lt;<strong>7</strong>的size为size(<strong>1</strong>,j)，j&gt;=<strong>7</strong>的size为size(<strong>1</strong>,j)与size(<strong>1</strong>,<strong>6</strong>)+1=1的最大值</p><p>i=3，pi(3)=4，j&lt;<strong>4</strong>的size为size(<strong>2</strong>,j)，j&gt;=<strong>4</strong>的size为size(<strong>2</strong>,j)与size(<strong>2</strong>,<strong>3</strong>)+1=1的最大值</p><p>…</p><p><img src="https://s2.loli.net/2021/12/07/k9Gt8KfjJzgrnBc.png" style="zoom:50%;" /></p><p>最后size(10,10)=4，最多可以有四条不相交。</p><p>蓝色是算法选择的路径（向上优先，也可以用向左优先，答案都是四个，但值会有一点不同）。在斜角值改变时可以取得所求的子集。答案也就是[(3 4)(5 5)(7 9)(9 10)]，[(4  2)(5 5)(7 9)(9 10)]</p></blockquote><h2 id="流水作业调度"><a href="#流水作业调度" class="headerlink" title="流水作业调度"></a>流水作业调度</h2><p><strong>问题描述</strong>   n个作业要在两台机器M1和M2上进行加工。每个作业加工的顺序都是先在M1上加工，然后在M2加工。M1和M2加工作业i所需的时间分别为ai 和bi。确定n个作业的最优加工顺序，使得加工完成所需的时间最少。</p><p><strong>算法</strong></p><ol><li>N1集合存放ai&lt;bi的作业，N2存放ai≥bi的作业</li><li>N1中作业按照ai升序排序，N2中作业按照bi降序排序</li><li>N1连接N2，计算时间</li></ol><blockquote><p><strong>例题</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">任务</th><th style="text-align:center">J1</th><th style="text-align:center">J2</th><th style="text-align:center">J3</th><th style="text-align:center">J4</th><th style="text-align:center">J5</th><th style="text-align:center">J6</th></tr></thead><tbody><tr><td style="text-align:center">工序1</td><td style="text-align:center">30</td><td style="text-align:center">120</td><td style="text-align:center">50</td><td style="text-align:center">20</td><td style="text-align:center">90</td><td style="text-align:center">110</td></tr><tr><td style="text-align:center">工序2</td><td style="text-align:center">80</td><td style="text-align:center">100</td><td style="text-align:center">90</td><td style="text-align:center">60</td><td style="text-align:center">30</td><td style="text-align:center">10</td></tr></tbody></table></div><p><strong>解答</strong></p><ol><li><p>分集合  {1,3,4}{2,5,6}</p></li><li><p>排序  {4,1,3}{2,5,6}</p></li><li><p>合并与计算时间</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">任务</th><th style="text-align:center">J4</th><th style="text-align:center">J1</th><th style="text-align:center">J3</th><th style="text-align:center">J2</th><th style="text-align:center">J5</th><th style="text-align:center">J6</th></tr></thead><tbody><tr><td style="text-align:center">M1结束</td><td style="text-align:center">20</td><td style="text-align:center">50×</td><td style="text-align:center">100×</td><td style="text-align:center">220×</td><td style="text-align:center">310×</td><td style="text-align:center"><strong>420↓</strong></td></tr><tr><td style="text-align:center">M2开始</td><td style="text-align:center">20</td><td style="text-align:center">60</td><td style="text-align:center">140</td><td style="text-align:center">230</td><td style="text-align:center">330</td><td style="text-align:center">420</td></tr><tr><td style="text-align:center">M2结束</td><td style="text-align:center"><strong>80↗</strong></td><td style="text-align:center"><strong>160↗</strong></td><td style="text-align:center"><strong>250↗</strong></td><td style="text-align:center"><strong>350↗</strong></td><td style="text-align:center">380×</td><td style="text-align:center"><strong>430</strong></td></tr></tbody></table></div><p>ps：第k个任务M2开始的时间要取第k个任务M1结束的时间和第k-1个任务M2结束的时间的较大值。</p></blockquote><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><p><strong>问题描述</strong>  给定n种物品和一个背包。物品i的重量是wi，其价值为vi，背包的容量为c。问如何选择装入背包中的物品使得装入物品的总价值最大？</p><script type="math/tex; mode=display">\begin{matrix} m(i,j) = \left\{\begin{matrix}m(i+1,j) && 0 \leq j<w_i\\ \max \{ m(i+1,j),m(i+1,j-w_i)+v_i\} && j \geq w_i\end{matrix}\right.\\\\m(n,j) = \left\{\begin{matrix}0 && 0 \leq j<w_n\\ v_n && j \geq w_n\end{matrix}\right.\end{matrix}</script><p><strong>解释</strong>  m[i,j]表示可选择物品i, i+1, …, n时，背包容量为j装入的最大价值</p><blockquote><p><strong>例题</strong></p><p>n=5,c=10,W={2,2,6,5,4},V={6,3,5,4,6}</p><p><strong>解答</strong></p><p>i=5时，j<4时，装不进去，为0，j>=4时，能把w5=4装进去，为v5=6</p><p>i=4时，若j<5，则w4=5无法放入，m(4,j)=m(5,j)，j>=5时，比较m(5,j)与m(5,j-5)+4的最大值（可以看作先直接把m(5,j)往上复制一行，j&gt;=5时再比较更新即可，后面同理）</p><p>i=3时，若j<6，则w4=6无法放入，m(3,j)=m(4,j)，j>=6时，比较m(4,j)与m(4,j-6)+5的最大值</p><p>… 最后结果如下图</p><p><img src="https://i.loli.net/2021/11/13/Gn7oYtlkrdaIzhC.png" style="zoom:50%;" />当</p><p>从m(1,10)开始看起，m(1,10)!=m(2,10),说明1肯定被放入了背包中。1的重量为2，剩下的容量为10-2=8；</p><p>从m(2,8)开始看起，m(2,8)!=m(3,8),说明2肯定被放入了背包中。2的重量为2，剩下的容量为8-2=6；</p><p>从m(3,6)开始看起，m(3,6)=m(4,6),说明3肯定没有放入背包中。继续m(4,6)=m(5,6),说明4肯定没有放入背包中。</p><p>当i=5时，看剩余的容量，如果满足5号物品的重量，则5肯定放入。否则，5无法放入。此例，容量为6，5号物品重量为4，5号物品放入。</p><p>最后得到放入的五件物品状态为<strong>(1,1,0,0,1)</strong></p></blockquote><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><strong>思想</strong>  在贪婪算法中采用逐步构造最优解的方法。在每个阶段，都作出一个看上去最优的决策。它并不一定对所有问题都成功，因为不从整体最优加以考虑，贪心解法可能不是全局最优解，但是对某些问题特别简单、有效。</p><p><strong>基本要素</strong></p><ol><li><strong>最优子结构性质</strong>  问题的最优解包含其子问题的最优解</li><li><strong>贪心选择性质</strong>  问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到，当前的选择和子问题的解无关，只和以往做出的选择有关</li></ol><h2 id="活动安排"><a href="#活动安排" class="headerlink" title="活动安排"></a>活动安排</h2><p><strong>问题描述</strong>  在活动集合中选择最大的相容活动子集合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Type&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GreedySelector</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,Type s[],Type f[],<span class="hljs-keyword">bool</span> A[] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">//s存开始时间，f存结束时间，且按结束时间非减续排列；</span></span></span><br><span class="hljs-params"><span class="hljs-function">    A[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>; <span class="hljs-comment">//排在第1个的活动最先结束，直接放入A；</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-comment">//从第2个活动开始检测</span></span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-keyword">if</span> (s[i]&gt;=f[j]) &#123; A[i]=<span class="hljs-literal">true</span>; j=i; &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-comment">//如果相容，放入A</span></span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-keyword">else</span> A[i]=<span class="hljs-literal">false</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure><p><strong>证明贪心选择性质</strong></p><ol><li>假设问题有一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始，做了贪心选择后，原问题简化为规模更小的类似子问题。</li><li>运用数学归纳法证明，每一步贪心选择→问题的整体最优解</li></ol><blockquote><p><strong>例题</strong></p><div class="table-container"><table><thead><tr><th></th><th style="text-align:center">1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>start</td><td style="text-align:center">5</td><td>0</td><td>3</td><td>5</td><td>3</td><td>1</td><td style="text-align:center">8</td><td style="text-align:center">6</td><td style="text-align:center">8</td><td>12</td><td>2</td></tr><tr><td>stop</td><td style="text-align:center">9</td><td>6</td><td>5</td><td>7</td><td>8</td><td>4</td><td style="text-align:center">11</td><td style="text-align:center">10</td><td style="text-align:center">12</td><td>14</td><td>13</td></tr></tbody></table></div><p><strong>解答</strong></p><p>待安排的11个活动按结束时间的非减序排列</p><div class="table-container"><table><thead><tr><th></th><th style="text-align:center">6</th><th>3</th><th>2</th><th>4</th><th>5</th><th>1</th><th style="text-align:center">8</th><th style="text-align:center">7</th><th style="text-align:center">9</th><th>11</th><th>10</th></tr></thead><tbody><tr><td>start</td><td style="text-align:center"><strong>1</strong></td><td>3</td><td>0</td><td><strong>5</strong></td><td>3</td><td>5</td><td style="text-align:center">6</td><td style="text-align:center"><strong>8</strong></td><td style="text-align:center">8</td><td>2</td><td><strong>12</strong></td></tr><tr><td>stop</td><td style="text-align:center"><strong>4</strong></td><td>5</td><td>6</td><td><strong>7</strong></td><td>8</td><td>9</td><td style="text-align:center">10</td><td style="text-align:center"><strong>11</strong></td><td style="text-align:center">12</td><td>13</td><td><strong>14</strong></td></tr></tbody></table></div><p>最后为(6,4,7,10)</p></blockquote><h2 id="0-1背包-1"><a href="#0-1背包-1" class="headerlink" title="0-1背包"></a>0-1背包</h2><p><strong>几种贪心策略</strong>（但是都不能保证得到最优解）</p><ol><li>选择可以装入背包的价值最大的物品</li><li>选择可装入背包的重量最小的物品</li><li>选择可装入背包的vi/wi最大的物品（一般用来做回溯法或者分支限界的限界函数）</li></ol><h2 id="最优装载"><a href="#最优装载" class="headerlink" title="最优装载"></a>最优装载</h2><p><strong>策略</strong>  重量最轻的先装  T(n)=O(nlogn)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Loading</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x[], Type w[], Type c, <span class="hljs-keyword">int</span> n )</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> *t = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [n+<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">Sort</span>(w, t, n) ; <span class="hljs-comment">//按货箱重量排序/</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; = n; i ++)<br>    x[i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;= n &amp;&amp; w[t[i]] &lt;= c; i++) &#123;<br>        [t[i]] = <span class="hljs-number">1</span>;<br>        c-= w[t[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>例题</strong></p><p>(100,200,50,90,150,50,20,80), c=400</p><p><strong>解答</strong></p><p>所考察货箱的次序为73684152，考察到5时装不下了</p><p>(<strong>100</strong>,200,<strong>50</strong>,<strong>90</strong>,150,<strong>50</strong>,<strong>20</strong>,<strong>80</strong>) 装了390</p><p>(1,0,1,1,0,1,1,1)</p></blockquote><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p><strong>前缀码</strong>  对每一个字符规定一个0,1串作为其代码，并要求任一字符的代码都不是其它字符代码的前缀，这种编码称为前缀码。</p><p><strong>问题描述</strong>  找到使平均码长达到最小的前缀码编码方案</p><p><strong>策略</strong>  频率小的字符，深度大。队列Q以f(c)为键值存放二叉树各结点，通过贪心选择，将最小频率的两个二叉树合并，然后将新树（频率为上述两个二叉树频率之和）插入Q中。   T(n)=O(nlogn)</p><p><strong>证明贪心选择性质</strong></p><p>设x和y是字符集C中具有最小频率的两个字符，证明存在C的最优前缀码，使x和y具有最长、相同的码长且仅最后一位编码不同。设二叉树T表示C的任意一个最优前缀码方案。只要证明可以对T做适当修改后，得到一棵新的二叉树T’， 新树中，x和y是最深叶子且为兄弟。同时，新树也是C的最优前缀码方案。</p><p><strong>证明最优子结构性质</strong></p><p>设T表示C的一个最优前缀码方案。x和y是树T中的叶子节点且为兄弟。z是它们的父亲。若将z看做是具有频率f(z)=f(x)+f(y)的字符，则证明树T’=T-{x,y}表示字符集C’=C-{x,y} U {z}的一个最优前缀码即可。</p><blockquote><p><strong>例题</strong></p><p>设在1000个字母的文章中各字母出现的频率为a:83, b:14,  c:28,  d:38,  e:131,  f:29,  g:20,  h:53……，求最优编码。</p><p><strong>解答</strong></p><p><img src="https://i.loli.net/2021/11/14/5kI9jcio2xabpgC.png" style="zoom: 67%;" /></p><p>ps:注意兄弟节点左小右大（按题目规定）</p></blockquote><h2 id="单源最短路径-dijksta"><a href="#单源最短路径-dijksta" class="headerlink" title="单源最短路径(dijksta)"></a>单源最短路径(dijksta)</h2><p><a href="https://www.bilibili.com/video/BV1q4411M7r9">dijksta视频演示</a></p><blockquote><p><strong>例题</strong></p><p><img src="https://i.loli.net/2021/11/14/VuRe1vE9fZ6tKcS.png"  style="zoom: 33%;" /></p><p><strong>解答</strong></p><p><img src="https://i.loli.net/2021/11/16/81LgIlVw5zusOx9.png" style="zoom:25%;" /></p><p><img src="https://i.loli.net/2021/11/14/RuqJGtPOHmzlV6n.png" style="zoom: 25%;" /></p></blockquote><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>特点</strong>  深度优先搜索策略、算法框架是解空间（子集树与排列树）、在搜索的时候要避免遗漏，同时要高效。（具有限界函数的深度优先生成法称为回溯法）</p><p><strong>解空间</strong>  子集树（0-1，装载，子集和）与排列树（旅行商，m着色，n后）</p><p><strong>基本元素</strong>  活结点（自身已生成但其儿子还没有全部生成），拓展结点（正在产生儿子的结点），死结点（不满足约束或者所有儿子已经产生的结点）</p><p><strong>剪枝</strong>  用约束函数在扩展结点处剪去不满足约束的子树（左剪枝），用限界函数剪去得不到最优解的子树（右剪枝）</p><p><strong>终止条件</strong>  找到所有的解，解空间中没有活结点为止</p><h2 id="装载问题"><a href="#装载问题" class="headerlink" title="装载问题"></a>装载问题</h2><p><strong>问题描述</strong>   n个集装箱要装到2艘载重量分别为c1,c2的货轮，其中集装箱 i的重量为wi。要求找到装载方案将这n个货箱装上这2艘轮船</p><p><strong>解释</strong>  若装载问题有解, 采用如下策略可得一个最优装载方案：将第一艘轮船尽可能装满，将剩余的货箱装到第二艘轮船上。将第一艘船尽可能装满类似0-1背包问题</p><blockquote><p><strong>例题</strong></p><p>n=4,c1=12,W={8,6,2,3}</p><p><strong>解答</strong></p><p><img src="https://i.loli.net/2021/11/14/zurCOpm69MXy3Hk.png"  style="zoom: 67%;" /></p></blockquote><h2 id="0-1背包-2"><a href="#0-1背包-2" class="headerlink" title="0-1背包"></a>0-1背包</h2><p><strong>解释</strong>  子集树。只要左儿子节点是一个可行结点，搜索就进入左子树（不超过背包重量）（约束剪枝）。在右子树中有可能包含最优解是才进入右子树搜索，否则将右子树剪去（利用单价贪心求解价值上限）（限界剪枝）。$cw$是背包当前重量，$M-cw$是背包剩余的空间，$cp$是当前总收益，$rp$是贪心算法剩余的物品收益，$bestw$记录当前最优价值，也就是判断$bp=cp+rp&gt;bestw$是右节点的限界函数。（此外，回溯法解0-1背包的前置条件是物品已按$p_i/w_i$非增次序排序）</p><blockquote><p><strong>例题</strong></p><p>M=110</p><p>w=(1,11,21,23,33,43,45,55)，v=(11,21,31,33,43,53,55,65)</p><p><strong>解答</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th></tr></thead><tbody><tr><td style="text-align:center">w</td><td style="text-align:center">1</td><td style="text-align:center">11</td><td style="text-align:center">21</td><td style="text-align:center">23</td><td style="text-align:center">33</td><td style="text-align:center">43</td><td style="text-align:center">45</td><td style="text-align:center">55</td></tr><tr><td style="text-align:center">v</td><td style="text-align:center">11</td><td style="text-align:center">21</td><td style="text-align:center">31</td><td style="text-align:center">33</td><td style="text-align:center">43</td><td style="text-align:center">53</td><td style="text-align:center">55</td><td style="text-align:center">65</td></tr><tr><td style="text-align:center">v/w</td><td style="text-align:center">11</td><td style="text-align:center">1.9</td><td style="text-align:center">1.48</td><td style="text-align:center">1.43</td><td style="text-align:center">1.3</td><td style="text-align:center">1.23</td><td style="text-align:center">1.22</td><td style="text-align:center">1.18</td></tr></tbody></table></div><p><img src="https://i.loli.net/2021/11/14/7TLS4elkFUYRHOu.png" style="zoom:50%;" /></p><p>最优解为<strong>(1,1,1,0,1,1,0,0)</strong></p></blockquote><h2 id="n后问题"><a href="#n后问题" class="headerlink" title="n后问题"></a>n后问题</h2><p><strong>问题描述</strong>   皇后问题要求在一个n×n的棋盘上放置n个皇后，使得它们彼此不受”攻击”。n皇后问题要求寻找在棋盘上放置这n个皇后的方案，使得它们中任何两个都不在同一行、同一列或同一斜线上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nQueen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    Queen X；<br>    <span class="hljs-comment">//初始化X    </span><br>    X.n=n；<span class="hljs-comment">//皇后个数</span><br>    X.sum=<span class="hljs-number">0</span>；<br>    <span class="hljs-keyword">int</span>*p=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [n+<span class="hljs-number">1</span>]；<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>；i&lt;=n；i++) p[i]= <span class="hljs-number">0</span>；<br>    X.x=p；<br>    X.<span class="hljs-built_in">Backtrack</span>(<span class="hljs-number">1</span>)；<br>    <span class="hljs-keyword">delete</span> [] p；<br>    returnX. sum;<br>&#125;<br><br><span class="hljs-keyword">bool</span> Queen:: <span class="hljs-built_in">Place</span>(<span class="hljs-keyword">int</span> k) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; k; j++)<br>      <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">abs</span>(k-j) == <span class="hljs-built_in">abs</span>(x[j] - x[k])) <br>        ||(x[j] == x[k] ))<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br> <br><span class="hljs-keyword">void</span> Queen:: <span class="hljs-built_in">Backtrack</span>(<span class="hljs-keyword">int</span> t) &#123;<br>    <span class="hljs-keyword">if</span> (t &gt; n) <br>        sum++;<br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>         x[t] = i;<br>         <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Place</span>(t)) <br>             <span class="hljs-built_in">Backtrack</span>(t+<span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释</strong>  (x1, …, xn) , x[i]表示皇后i放在棋盘的第i行的第x[i]列，解空间是排列树。abs(i-j)≠abs(x[i] – x[j]))是约束函数（不在同一列已经实现）。如下图是4皇后的一个解。</p><p><img src="https://i.loli.net/2021/11/14/8KqMfCEVO9LyBxs.png" style="zoom: 67%;" /></p><h2 id="m着色"><a href="#m着色" class="headerlink" title="m着色"></a>m着色</h2><p><strong>解释</strong>  n元组(x0,x1,…,xn-1)表示图G的m-着色判定问题的解。对所有i和j，若邻接矩阵a[i，j]=1，则xi≠xj（约束条件）</p><blockquote><p><strong>例题</strong></p><p>使用回溯算法来求解图的m(m=3)着色问题的如下图实例。<br>(1) 给出解向量的形式，指出解空间树的类型。<br>(2) 描述搜索过程。<br>(3) 画出找到一个解所生成的部分搜索树，并给出这个解。</p><p><img src="https://i.loli.net/2021/11/14/uSJZqLQAlK3TedO.png" style="zoom: 67%;" /></p><p><strong>解答</strong></p><p>X=(x0,x1,x2,x3,x4)</p><p><img src="https://i.loli.net/2021/11/14/usNAxhWT4jkSvbQ.png" style="zoom: 67%;" /></p><p><strong>X=(1,2,3,2,1)</strong></p></blockquote><h2 id="旅行售货员"><a href="#旅行售货员" class="headerlink" title="旅行售货员"></a>旅行售货员</h2><h2 id="子集和"><a href="#子集和" class="headerlink" title="子集和"></a>子集和</h2><p><strong>问题描述</strong>  给出n个正实数集合与正整数M，找到元素之和为M的子集</p><blockquote><p><strong>例题</strong></p><p>设有n=6个正数的集合{5,10,12,13,15,18}和整数M=30，求W的所有元素之和为M的子集</p><p><strong>解答</strong></p><p><img src="https://i.loli.net/2021/11/14/ioq9NwWbhaYLnpT.png" style="zoom: 50%;" /></p><p>最后一步，5，6两个物品全要为31，所以不要前四个物品的右子树肯定不需要考虑了。</p></blockquote><h1 id="分支限界"><a href="#分支限界" class="headerlink" title="分支限界"></a>分支限界</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p><strong>解空间</strong>  子集树（单源最短路径问题）与排列树（售货商）</p><p><strong>搜索方式</strong>  广度优先或最小耗费优先</p><p><strong>适用问题</strong>  存在性问题（找出满足约束条件的一个解）与最优化问题（在满足约束条件的解中找出在某种意义下的最优解） </p><p><strong>活结点表（其实叫队列更好一点）</strong></p><ul><li>每一个活结点只有一次机会成为扩展结点</li><li>活结点一旦成为扩展结点，一次性产生其所有儿子结点（导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中）</li><li>从活结点表中取出下一结点成为当前扩展结点，并重复结点扩展过程</li><li>直到找到所需的解或活结点表为空时为止</li></ul><p><strong>选择扩展结点的两种常用方法</strong>  队列式（先进先出）、优先队列式（按照耗费/收益优先级选取下一个结点作为当前拓展结点）</p><h2 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h2><p>子集树</p><p>剪枝的原则：在扩展顶点i时，如果从当前扩展结点i到j有边可达，且从源出发途经i再到j的所对应路径长度小于当前最优路径长度，则将该顶点作为活结点插入到活结点优先队列中</p><blockquote><p><strong>例题</strong></p><p><img src="https://i.loli.net/2021/11/16/wrZ41YiqExp6QSc.png" style="zoom: 67%;" /></p><p><strong>解答</strong></p><ol><li><p>队列法</p><p><img src="https://i.loli.net/2021/11/16/bjfoQFy5YwlKaDS.png" style="zoom:50%;" /></p></li><li><p>优先队列法（dist短的优先）</p></li></ol><p>结果</p><p><strong>dist=(10,30,60,16,50)</strong></p><p><strong>prev=(0,0,5,1,2)</strong></p></blockquote><h2 id="装载问题-1"><a href="#装载问题-1" class="headerlink" title="装载问题"></a>装载问题</h2><p>子集树</p><p>约束函数：已装容量与c1容量</p><p>限界函数：un=已经装载的重量ew+剩余重量r</p><blockquote><p><strong>例题</strong></p><p>n=4,c_1=12,W={8,6,3,2}</p><p><strong>解答</strong></p><p>优先队列法（un大的先拓展）</p><p>叶子结点成为扩展结点，得到一个最优解</p><p><img src="https://i.loli.net/2021/11/16/X4e2TVIv6z8GZsO.png" style="zoom:67%;" />1q</p><p>解为(1,0,1,0)</p></blockquote><h2 id="0-1背包-3"><a href="#0-1背包-3" class="headerlink" title="0-1背包"></a>0-1背包</h2><blockquote><p><strong>例题</strong></p><p>n=3, w=[20,15,15], v=[45,25,25], c= 30</p><p><strong>解答</strong></p><ol><li><p>队列法</p><p><img src="https://i.loli.net/2021/11/14/o8DeUcu1SzGlpP6.png" style="zoom:50%;" /></p></li><li><p>优先队列法（价值大的先拓展）</p><p><img src="https://i.loli.net/2021/11/16/okxtwCMfvdA1SsO.png" style="zoom:50%;" /></p></li></ol><p>取(0,1,1)</p></blockquote><h2 id="最大团"><a href="#最大团" class="headerlink" title="最大团"></a>最大团</h2><p>完全子图（图中所有点任意连线都在原图中）</p><p>团（最大完全子图）</p><p>空子图（图中所有点任意连线不在原图中）</p><p>最大独立集（最大空子图）</p><p>补图（原图的完全图-原图，点不变）</p><p>有：若U是G的一个最大团，则U是G的补图G‘的一个最大独立集</p><p><img src="https://i.loli.net/2021/11/16/PK1ROEXvV3mJlcY.png" style="zoom:50%;" /></p><p>约束条件：是否是团（该顶点与当前团中其它顶点之间是否有边相连）</p><p>限界函数：当前团尺寸cn+剩余顶点数目r≤当前已求出最大尺寸bestn</p><p>优先级：un=cn+r</p><p>终止条件：遇到子集树中的一个叶结点（即n+1层结点）成为当前扩展结点</p><blockquote><p><strong>例题</strong></p><p><img src="https://i.loli.net/2021/11/16/ZKs1IP4xDRMmgbO.png" alt=""></p><p><strong>解答</strong></p><p>优先队列法（un大的先拓展）</p><p><img src="https://i.loli.net/2021/11/16/PMr6sCnxNp7hkGo.png" style="zoom: 67%;" /></p><p>一个可行结果为(1，1，1，0)</p></blockquote><h2 id="回溯与分支限界对比"><a href="#回溯与分支限界对比" class="headerlink" title="回溯与分支限界对比"></a>回溯与分支限界对比</h2><p><img src="https://i.loli.net/2021/11/16/QEZtAoMVafKiuY4.png" alt="回溯与分支限界对比" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>CUMT课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>分治</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心</tag>
      
      <tag>回溯</tag>
      
      <tag>分支限界</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/10/26/hello-world/"/>
    <url>/2021/10/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
