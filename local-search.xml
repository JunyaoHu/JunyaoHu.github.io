<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《实用优化算法-2021秋》课程小结</title>
    <link href="/2021/11/14/%E3%80%8A%E5%AE%9E%E7%94%A8%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95-2021%E7%A7%8B%E3%80%8B%E8%AF%BE%E7%A8%8B%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/11/14/%E3%80%8A%E5%AE%9E%E7%94%A8%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95-2021%E7%A7%8B%E3%80%8B%E8%AF%BE%E7%A8%8B%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="一维搜索"><a href="#一维搜索" class="headerlink" title="一维搜索"></a>一维搜索</h1><ul><li>黄金分割法（第一题考了这个，迭代两次就行，不过这次考的不是二次函数，加了一个cos函数，所以计算器计算的时候要注意设置为弧度制）</li><li>斐波那契法</li></ul><h1 id="无约束搜索"><a href="#无约束搜索" class="headerlink" title="无约束搜索"></a>无约束搜索</h1><ul><li>下降方向（第二题第一小问考了这个，给出函数，点，方向，确定是否为下降方向，就是定义）</li><li>最优性条件（第二题第二小问考了这个，直接函数求导为0求解就行，正定矩阵大于零，是极小点）</li><li>梯度下降法（第三题第一小问考了这个，迭代一次；第三题第二小问要求证明xk的坐标与k的关系式，应该是证明每次α的值都是一样的，推导一下就行，考试没想出来，应该是这里扣的三分）</li><li>牛顿法与阻尼牛顿法</li><li>共轭梯度法</li><li>拟牛顿法（第四题，DFP公式记牢）</li></ul><h1 id="有约束搜索"><a href="#有约束搜索" class="headerlink" title="有约束搜索"></a>有约束搜索</h1><ul><li>有效集、KKT点、λ、σ（第六题考了数形结合画图，求最小值点，对于最小值点求出该点的λ参数，注意比如1≤x≤5是两个条件，要转换成x≥1与-x+5≥0才行）</li><li>外罚函数法</li><li>内罚函数法/内点法/障碍函数法（第五题考了这个，障碍函数使用对数函数，不等式约束，最后好像求出了两个点，都计算一下取最小值）</li><li>增广拉格朗日/乘子法（第七题考了这个，等式约束）</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>最后老师发的练习题还是很管用的，好好做两遍，第一遍学算法步骤，第二遍验证计算能力，就差不多了</li><li>学的知识很多，考的内容还好，主要是计算要准确，考试给的数字不难，大多可以手算，很少用到计算器，但是不要不带计算器，第一题还是需要的，有一题画图，所以最好带上铅笔直尺</li><li>公式一定要记准确</li><li>有的算到最后和结论不一样就知道要再算一遍，比如拟牛顿法二次函数计算x2时g2肯定为0也就是结束计算，算出来g2不对就要返回去检查计算了</li><li>好多题做完第一遍后检查可以利用数形结合，基本上约束条件和函数比较好画，都是直线，椭圆，二次函数之类的，画个简单的图形判断最优解就知道自己算的对不对了，第一遍自己算错了三个，然后画图之后好像都改对了</li><li>考了97，平时分98，总评98。</li></ul>]]></content>
    
    
    <categories>
      
      <category>CUMT课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《算法导论》笔记</title>
    <link href="/2021/10/26/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/10/26/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><p><strong>重要特性</strong>  输入、输出、确定性、有限性</p><p><strong>算法描述</strong>  自然语言、流程图、伪代码、程序代码</p><p><strong>算法的复杂性</strong>  时间复杂性、空间复杂性</p><p><strong>算法的渐进性态</strong></p><p>$O(g(n))$ 上界</p><p>$Ω(g(n))$ 下界</p><p>$Θ(g(n))$ 确界</p><p>$logn &lt; n &lt; nlogn &lt; n^2 &lt; n^3 &lt;2^n$</p><p><strong>NP完全理论</strong>  能在多项式时间内求解的判定性问题称为P问题，在多项式时间能验证猜测解的正确性为NP问题</p><h1 id="递归与分治"><a href="#递归与分治" class="headerlink" title="递归与分治"></a>递归与分治</h1><h2 id="递归概念"><a href="#递归概念" class="headerlink" title="递归概念"></a>递归概念</h2><p><strong>递归定义</strong>  用函数自身定义的函数 GNU is Not Unix</p><p><strong>递归函数两个要素</strong>  边界条件与递归方程</p><p><strong>满足条件</strong>  可转化（可以转化为一个或者多个子问题，子问题的求解方法与原问题完全相同，只在规模上不同）、调用次数有限、有结束递归的条件来终止递归，并不是所有递归都可以转换</p><p><strong>何时使用递归</strong>  定义是递归的（斐波那契），数据结构是递归的（链表），问题的求解方法是递归的（汉诺塔，数的排列）</p><p><strong>递归算法转化为非递归算法</strong></p><ol><li><p>直接转化法：直接用循环结构的算法替代递归算法，不需要使用栈</p></li><li><p>用栈模拟系统的运行过程，通过分析只保存必须保存的信息，从而用非递归算法替代递归算法，需要使用栈</p></li></ol><h2 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Template&lt;class type&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Perm</span><span class="hljs-params">(Type list[], <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//递归地产生所有前缀是list[0:k-1],且后缀是list[k:m]的全排列的所有</span><br><span class="hljs-keyword">if</span> (k==m) &#123; <span class="hljs-comment">//只剩下一个元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++) cout&lt;&lt;list[i];<br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">//还有多个元素，递归产生后缀是list[k:m] 的全排列</span><br><span class="hljs-keyword">for</span>(i=k;i&lt;=m;i++) &#123;<br><span class="hljs-built_in">Swap</span>(list[k],list[i]);<br>    <span class="hljs-built_in">Perm</span>(list,k+<span class="hljs-number">1</span>,m);<br>    <span class="hljs-built_in">Swap</span>(list[k],list[i]); <span class="hljs-comment">//记得还原</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h2><p>对于数据n，最大加数不大于m的划分个数记作q(n,m)</p><script type="math/tex; mode=display">q(n,m) = \left\{\begin{matrix}1  & n = 1,m = 1\\ q(n,n) &n<m \\ 1+q(n,n-1) &n = m \\ q(n,m-1)+q(n-m,m) &n>m>1\end{matrix}\right.</script><h2 id="分治概念"><a href="#分治概念" class="headerlink" title="分治概念"></a>分治概念</h2><p><strong>设计思想</strong>  将一个难以直接解决的大问题，分割成一些规模较小的子问题，这些子问题互相独立且与原问题相同，从而递归地解子问题，将各个子问题的解合并得到原问题的解</p><p><strong>适用问题</strong>  该问题可以分解为若干个规模较小的相同问题；该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题；该问题的规模缩小到一定的程度就可以容易地解决；利用该问题分解出的子问题的解可以合并为该问题的解</p><p><strong>求解过程</strong> 分解、求解、合并</p><p><strong>时间复杂性计算</strong>  扩展递归技术、递归树、主定理方法</p><p><strong><em>▲主定理方法</em></strong>  T(n)=aT(n/b)+f(n)，其中a≥1，b&gt;1为常数，该方程描述了算法的执行时间，算法将规模为n的问题分解成a个子问题，每个子问题的大小为n/b。比较两个式子大小即可</p><script type="math/tex; mode=display">T(n) = aT(\frac{n}{b} ) + f(n) =\left\{\begin{matrix}O(n^{log_{b}a } )  & n^{log_{b}a} > f(n)\\O(n^{log_{b} a }log_2 n) & n^{log_{b}a} = f(n) \\O(f(n)) & n^{log_{b}a} < f(n)\end{matrix}\right.</script><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p><strong>问题描述</strong>  给定已按升序排好序的n个元素a[1:n]，现要在这n个元素中找出一特定元素x</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BinarySearch</span><span class="hljs-params">(Type a[ ], <span class="hljs-keyword">const</span> Type &amp;x,<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> right=n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br><span class="hljs-keyword">int</span> middle=(left+right)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(x==a[middle])<br><span class="hljs-keyword">return</span> middle;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&gt;a[middle])<br>left=middle+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>right=middle<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释</strong></p><p>指针left在什么情况下会超过right?</p><p>Left指针向左移动, right指针向右移动，如果一直没有找到结果，那么这两个指针最终会重叠，指向同一个位置。 此时队列中只剩下一个元素。</p><p>此时，left=right； 因此middle=left=right；</p><p>如果这个元素满足x==a[middle]，程序结束 return middle；</p><p>否则如果x&gt;a[middle], left=middle+1后，left将位于right的右边；</p><p>否则如果x&lt;a[middle], right=middle-1后，right将位于left的左边</p><h2 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h2><p><strong>问题描述</strong>  XY是n位二进制整数，计算他们的乘积XY</p><script type="math/tex; mode=display">\begin{array}  {X}X=A2^{\frac{n}{2}}+B, Y=C2^{\frac{n}{2}}+D \\   XY = AC2^n+(AD+BC)2^{\frac{n}{2} }+BD  \\  =AC2^n+((A-B)(D-C)+AC+BD)2^{\frac{n}{2}}+BD \\  T(n) = O(n^{log3}) =\left\{\begin{matrix}O(1)  & n=1\\3T(\frac{n}{2} ) + O(n) & n>1 \\\end{matrix}\right.\end{array}</script><h2 id="Strassen乘法"><a href="#Strassen乘法" class="headerlink" title="Strassen乘法"></a>Strassen乘法</h2><p><strong>问题描述</strong>  计算两个矩阵相乘的结果，分块矩阵计算</p><script type="math/tex; mode=display">\begin{array}  {X}  T(n) = O(n^{3}) =\left\{\begin{matrix}O(1)  & n=1\\8T(\frac{n}{2} ) + O(n^2) & n>1 \\\end{matrix}\right.\end{array}</script><p><strong>解释</strong>  两个 n/2×n/2 的矩阵相加： 一行需要n/2次加法，共有n/2行，因此，两个矩阵相加的复杂度为 n/2×n/2=n^2/4，四次矩阵相加的复杂度为 O(n^2)</p><p><strong>改进算法</strong>  只需要七次乘法</p><h2 id="棋盘覆盖"><a href="#棋盘覆盖" class="headerlink" title="棋盘覆盖"></a>棋盘覆盖</h2><p><strong>问题描述</strong>  2^k阶的棋盘中只有一个方格残缺，要求用L型骨牌覆盖残缺棋盘上的所有方格且任何2个L型骨牌不得重叠覆盖，用递推求解时间复杂度</p><script type="math/tex; mode=display">\begin{array}  {X}  T(k) = O(4^{k}) =\left\{\begin{matrix}O(1)  & k=0\\4T(k-1 ) + O(1) & k>0 \\\end{matrix}\right.\end{array}</script><p><strong>解释</strong>  测试哪个子棋盘残缺以及形成3个残缺子棋盘需要O(1) ，覆盖4个残缺子棋盘（ 2^(k-1)阶）需四次递归调用，共需时间4T(k-1)</p><h2 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h2><p><strong>问题描述</strong> 数组排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">temlplate  &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">type</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(Type a[], <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function">  </span>&#123;   <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>eft &lt; right) <span class="hljs-comment">//至少有2个元素</span><br>       &#123;  <br>       <span class="hljs-keyword">int</span> i = (left + right ) /<span class="hljs-number">2</span>; <span class="hljs-comment">//取中点</span><br>       <span class="hljs-built_in">MergeSort</span>(a, <span class="hljs-number">1</span>eft, i)；<br>       <span class="hljs-built_in">MergeSort</span>(a, i+<span class="hljs-number">1</span>, right)；<br>       <span class="hljs-built_in">Merge</span>(a, b, <span class="hljs-number">1</span>eft, i, right)；<span class="hljs-comment">//从a合并到数组b</span><br>       <span class="hljs-built_in">copy</span>(a, b, left, right);<span class="hljs-comment">//复制回数组a</span><br>     &#125;<br> &#125;    <br></code></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{array}  {X}  T(n) = O(nlogn) =\left\{\begin{matrix}O(1)  & n=1\\2T(\frac{n}{2} ) + O(n) & n>1 \\\end{matrix}\right.\end{array}</script><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>问题描述</strong> 数组排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSoft</span><span class="hljs-params">(Type a[], <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(p&lt;r) &#123;<br>        <span class="hljs-keyword">int</span> q=<span class="hljs-built_in">Partition</span>(a, p, r)<br>        <span class="hljs-comment">//找到q的位置</span><br>        <span class="hljs-comment">//同时确保该位置右边的比基准元素大，左边的比基准元素小</span><br>        <span class="hljs-built_in">QuickSort</span>(a, p, q<span class="hljs-number">-1</span>); <span class="hljs-comment">//对左半段排序</span><br>        <span class="hljs-built_in">QuickSoft</span>(a, q+<span class="hljs-number">1</span>, r); <span class="hljs-comment">//对右半段排序</span><br>        &#125;<br>     &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(Type a[],<span class="hljs-keyword">int</span> p , <span class="hljs-keyword">int</span> r )</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = p; j = r+<span class="hljs-number">1</span>;<br>    type x = a[p];<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123; <br>         <span class="hljs-keyword">while</span>(a[++i] &lt; x &amp;&amp; i &lt; r);<br>         <span class="hljs-keyword">while</span>(a[--j] &gt; x);<br>         <span class="hljs-keyword">if</span> (i &gt;= j) <span class="hljs-keyword">break</span>;<br>         <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>    &#125;<br>    a[p] = a[j]；<br>    a[j] = x;<br>    <span class="hljs-keyword">return</span> j;<br>&#125;<br><br><span class="hljs-comment">//随机选择基准点的快速排序</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">randomizedQuickSoft</span><span class="hljs-params">(Type a[], <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p&lt;r) &#123;<br>        <span class="hljs-keyword">int</span> q=<span class="hljs-built_in">randomizedPartition</span>(a, p, r);<br>        <span class="hljs-built_in">randomizedQuickSort</span>(a, p, q<span class="hljs-number">-1</span>); <span class="hljs-comment">//对左半段排序</span><br>        <span class="hljs-built_in">randomizedQuickSoft</span>(a, q+<span class="hljs-number">1</span>, r); <span class="hljs-comment">//对右半段排序</span><br>        &#125;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">randomizedPartition</span><span class="hljs-params">(Type a[], <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-built_in">random</span>(p, r);<br>    <span class="hljs-built_in">swap</span>(a[i], a[p]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Partition</span> (a,p,r);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释</strong></p><ol><li>步骤<ul><li>分解：以a[p]为基准元素将a[p:r]划分成3段a[p:q-1],a[q]和a[q+1:r]，使a[p:q-1]中任意一个元素小于等于a[q]，而a[q+1:r]中任何一个元素大于等于a[q]，下标q在划分过程中确定</li><li>递归求解：通过递归调用快速排序算法分别对a[p:q-1]和a[q+1:r]进行排序</li><li>合并</li></ul></li><li>最坏情况，已经排好，O(n^2)</li><li>最好情况，每次划分大小都是n/2，O(nlogn)</li></ol><p><img src="https://i.loli.net/2021/10/26/Gm4dM5kU1rN2K9Y.jpg" style="zoom:67%;" /></p><h2 id="线性时间选择"><a href="#线性时间选择" class="headerlink" title="线性时间选择"></a>线性时间选择</h2><p><strong>问题描述</strong> </p><p>无序排列中求n个元素中第k小的元素（主要求中位数）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span><br><span class="hljs-function">Type <span class="hljs-title">RandomizedSelect</span> <span class="hljs-params">(a[], <span class="hljs-keyword">int</span> p,<span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p==r) <span class="hljs-keyword">return</span> a[p];<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-built_in">RandomizedPartition</span>(a, p, r), <span class="hljs-comment">//前面有</span><br>    j = i-p+l  <span class="hljs-comment">//统计前半部分元素个数j,  i为基准点</span><br>    <span class="hljs-keyword">if</span> ( k &lt;= j )<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">RandomizedSelect</span>(a, p, i, k);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">RandomizedSelect</span>(a, i+<span class="hljs-number">1</span>, r, k-j);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释</strong></p><p>根据随机产生的基准点，将元素分为2组，基准点包含在第1组中；如果k&lt;=j，则第k小元素落在a段，为a段的第k小元素；如果k&gt;j，则a段的所有元素都比第k小元素还要小，第k小元素落在b段，为b段中的第k-j小元素（-j的含义是去掉a段的元素总个数）</p><p>最坏情况，分成两个1和n-1的子问题，O(n^2)</p><p>最好情况，每次都产生n/2大小的子问题，O(n)</p><p><strong>基准点选择优化</strong></p><p>例如可以分成五个组，取每组中位数的中位数。设所有元素互不相同。在每一组中有2个元素小于本组的中位数，而n/5个中位数中又有(n-5)/10个小于基准x,因此，找出的基准x至少比3(n-5)/10个元素大。同理，基准x也至少比3(n-5)/10个元素小。当n≥75时，3(n-5)/10≥n/4所以按此基准划分所得的2个子数组的长度都至少缩短1/4。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Type <span class="hljs-title">Select</span><span class="hljs-params">(Type a[], <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (r-p&lt;<span class="hljs-number">75</span>) &#123;<br>        TO DO<span class="hljs-comment">//用某个简单排序算法对数组a[p:r]排序;</span><br>        <span class="hljs-keyword">return</span> a[p+k<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;=(r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">5</span>; i++ ) &#123;<br>        <span class="hljs-comment">//将a[p+5*i]至a[p+5*i+4]的第3小元素与a[p+i]交换位置;</span><br>        Type x = <span class="hljs-built_in">Select</span>(a, p, p+(r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">5</span>, (r-p<span class="hljs-number">-4</span>)/<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-built_in">Partition</span>(a,p,r, x),<br>        j=i-p+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (k&lt;=j) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Select</span>(a,p,i,k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">Select</span>(a,i+<span class="hljs-number">1</span>,r,k-j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最接近点对"><a href="#最接近点对" class="headerlink" title="最接近点对"></a>最接近点对</h2><p><strong>一维情况</strong></p><p>1) 将S上的n个点分成大致相等的2个子集S1和S2<br>2) 分别求S1和S2中的最接近点对<br>3) 求一点在S1、另一点在S2中的最接近点对<br>4) 从上述三对点中找距离最近的一对</p><p><strong>二维情况</strong></p><ol><li>m为S中各点x间坐标的中位数，构造S1和S2    O(n)</li><li>递归求S1和S2的最小距离    2T(n/2)</li><li>求上述两个距离的最小值</li><li>设P1是S1中距垂直分割线l的距离在d之内的所有点组成的集合；P2是S2中距分割线l的距离在d之内所有点组成的集合；将P1和P2中点依其y坐标值排序；并设X和Y是相应的已排好序的点列    O(nlogn)</li><li>通过扫描X以及对于X中每个点检查Y中与其距离在d之内的所有点(最多6个)可以完成合并；当X中的扫描指针逐次向上移动时，Y中的扫描指针可在宽为2d的区间内移动；设dl是按这种扫描方式找到的点对间的最小距离；    O(n)</li></ol><h2 id="循环赛日程表"><a href="#循环赛日程表" class="headerlink" title="循环赛日程表"></a>循环赛日程表</h2><p><strong>问题描述</strong>  设有n(n = 2^k)位选手参加网球循环赛，循环赛共进行n-1天，每位选手要与其他n-1位选手比赛一场，且每位选手每天必须比赛一场，不能轮空。</p><p><strong>发现规律</strong></p><p><img src="C:\Users\hujunyao\AppData\Roaming\Typora\typora-user-images\image-20211206233548105.png" alt=""></p><p><img src="https://s2.loli.net/2021/12/06/U93fnXqQmOthd68.png" alt=""></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>基本思想</strong>  基本思想是在对一个多阶段决策的问题，按照某一顺序，根据每一步所选决策的不同，会引起状态的转移，最后会在变化的状态中获取到一个决策序列。</p><p><strong>基本要素</strong></p><ol><li>最优子结构性质（分析问题是否满足最优性原理（用反证法）：①先假设由问题的最优解导出的子问题的解不是最优的；②再证明在这个假设下可构造出比原问题最优解更好的解，从而导致矛盾）</li><li>子问题重叠性质（子问题不相互独立，重复出现，只在第一次遇到时加以求解，并把答案保存起来，以后再遇到时不必重新求解）</li></ol><p><strong>算法步骤</strong></p><ol><li>分析最优解的性质，并刻画其结构特征；</li><li>递归地定义最优值；</li><li>以自底向上或自顶向下的方式计算出最优值；</li><li>根据递归计算最优值时得到的信息，从子问题的最优解逐步构造出整个问题的最优解。</li></ol><h2 id="矩阵连乘"><a href="#矩阵连乘" class="headerlink" title="矩阵连乘"></a>矩阵连乘</h2><p><strong>问题描述</strong>  每计算出一个元素，需要q次乘法，最终得到的矩阵是p×r矩阵，有p×r个元素，因此，计算C需要的乘法次数为q×p×r。每次要选择较小的q×p×r。给定n个矩阵｛A1,A2,…,An｝，其中Ai与Ai+1是可乘的，且i=1,2⋯,n-1,如何确定计算矩阵连乘积的计算次序，使得计算矩阵连乘的数乘次数最少。</p><script type="math/tex; mode=display">m[i][j]=\left\{\begin{array}{cc}0 & i=j \\\min_{i\leq{k}<j} \{m[i][k]+m[k+1][j]+p_{i-1}p_kp_j\} & i<j\end{array}\right.</script><p><strong>解释</strong>  矩阵连乘积从Ai到Aj定义为A[i:j]，A[i:j]最少的乘法次数定义为m[i,j]，最优断开位置k记为𝑠[i,j]=k，T(n)=O(n^3)</p><blockquote><p><strong>例题</strong></p><p>计算矩阵连乘积A[1:6]的最少数乘次数，其中各矩阵的维数分别为p=[30,35,15,5,10,20,25]</p><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{matrix}𝑚[1][2]=𝑚[1][1]+𝑚[2][2]+p_0p_1p_2=15750\\𝑚[2][3]=𝑚[2][2]+𝑚[3][3]+p_1p_2p_3=2650\\...\\m[1][3]= \min \left\{\begin{matrix}m[1][1]+m[2][3]+p_0p_1p_3=7875▲\\m[1][2]+m[3][3]+p_0p_2p_3=18000\end{matrix}\right.\\s[1][3]=1\\...\\m[2][6]= \min \left\{\begin{matrix}  m[2][2]+m[3][6]+p_1p_2p_6=0+5375+35*15*25=18500\\m[2][3]+m[4][6]+p_1p_3p_6=2625+3500+35*5*25=10500▲\\m[2][4]+m[5][6]+p_1p_4p_6=4375+5000+35*10*25=18125\\m[2][5]+m[6][6]+p_1p_5p_6=7125+0+35*20*25=24625\end{matrix}\right.\\s[2][6]=3\\...\end{matrix}</script><div class="table-container"><table><thead><tr><th style="text-align:center">m</th><th style="text-align:center">A1</th><th style="text-align:center">A2</th><th style="text-align:center">A3</th><th style="text-align:center">A4</th><th style="text-align:center">A5</th><th style="text-align:center">A6</th></tr></thead><tbody><tr><td style="text-align:center">A1</td><td style="text-align:center">0</td><td style="text-align:center">15750</td><td style="text-align:center">7875</td><td style="text-align:center">9375</td><td style="text-align:center">11875</td><td style="text-align:center"><strong>15125</strong></td></tr><tr><td style="text-align:center">A2</td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">2625</td><td style="text-align:center">4375</td><td style="text-align:center">7125</td><td style="text-align:center">10500</td></tr><tr><td style="text-align:center">A3</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">750</td><td style="text-align:center">2500</td><td style="text-align:center">5375</td></tr><tr><td style="text-align:center">A4</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">1000</td><td style="text-align:center">3500</td></tr><tr><td style="text-align:center">A5</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">5000</td></tr><tr><td style="text-align:center">A6</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">s</th><th style="text-align:center">A1</th><th style="text-align:center">A2</th><th style="text-align:center">A3</th><th style="text-align:center">A4</th><th style="text-align:center">A5</th><th style="text-align:center">A6</th></tr></thead><tbody><tr><td style="text-align:center">A1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center"><strong>1</strong></td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center"><strong>3</strong></td></tr><tr><td style="text-align:center">A2</td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">A3</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">A4</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">4</td><td style="text-align:center"><strong>5</strong></td></tr><tr><td style="text-align:center">A5</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">A6</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0</td></tr></tbody></table></div><p>从右上角的元素开始分割，从A3后面分为A[1,3]与A[4,6]，s[1,3]=1，从A1后面拆分，s[4,6]=5，从A5后面拆分，<strong>得到((A1(A2A3)((A4A5)A6)，次数最少是15125</strong></p></blockquote><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LCSLength</span></span><br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> *x, <span class="hljs-keyword">char</span> *y,<span class="hljs-keyword">int</span> c[][], <span class="hljs-keyword">int</span> b[][])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;m;i++) c[i][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;n;i++) c[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-comment">//m,n是X和Y的长度</span><br>            <span class="hljs-keyword">if</span> (x[i]==y[j]) &#123;<br>                c[i][j]=c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>                b[i][j]=<span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c[i<span class="hljs-number">-1</span>][j]&gt;=c[i][j<span class="hljs-number">-1</span>]) &#123;<br>                c[i][j]=c[i<span class="hljs-number">-1</span>][j];<br>                b[i][j]=<span class="hljs-number">2</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                c[i][j]=c[i][j<span class="hljs-number">-1</span>];<br>                b[i][j]=<span class="hljs-number">3</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LCS</span><span class="hljs-params">(i, j, X, b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span> || j==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (b[i,j]==<span class="hljs-string">&quot;1&quot;</span> ) &#123;<br>        <span class="hljs-built_in">LCS</span>(i<span class="hljs-number">-1</span>, j<span class="hljs-number">-1</span>, x, b);<br>        cout &lt;&lt;x[i];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b[i,j]==<span class="hljs-string">&quot;2&quot;</span> ) <br>       <span class="hljs-built_in">LCS</span>(i<span class="hljs-number">-1</span>, j, x, b);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">LCS</span>(i, j<span class="hljs-number">-1</span>, x, b);<br>&#125;   <span class="hljs-comment">//计算复杂性：O(m+n)</span><br><span class="hljs-comment">//LCS(i, j, X, b)实现根据b的内容打印出Xi与Yj的最长公共子序列。</span><br><span class="hljs-comment">//调用LCS(m,n,x,b) 可打印出序列X和Y的最长公共子序列。</span><br></code></pre></td></tr></table></figure><script type="math/tex; mode=display">c[i][j]=\left\{\begin{array}{cc}0 & i=0, j=0 \\c[i-1][j-1]+1 & i, j>0 ; x_{i}=y_{j} \\\max \{c[i-1][j], c[i][j-1]\} & i, j>0 ; x_{i} \neq y_{j}\end{array}\right.</script><p><strong>解释</strong>  c[i,j]记录序列Xi和Yj的最长公共子序列长度，b[i,j]可以记录是哪种类型。在c表中从最右下角的那个元素开始，看b表中对应位置的值，如果为1，则在c表中从当前位置往左上角走；如果为2，则在c表中从当前位置往正上方走；如果为3，则在c表中从当前位置沿水平方向往后退一位；依次类推，直到c表中箭头退到c[0，0]为止。</p><p><strong>补充</strong>  两个序列的最长公共子序列不唯一，不影响最长公共子序列的长度；但是可能会产生不一样的公共子序列，见例题</p><blockquote><p><strong>例题</strong></p><p>给定两个序列为X=ABCBDAB和Y=BDCABA，求最长公共子序列。</p><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{matrix}i=1,X_1=\{A\}\\j=1,Y_1=\{B\},𝑐[1][1]=\max⁡\{ 𝑐[0][1],𝑐[1][0]\}=0, b[1][1]=2 or 3\\j=2,Y_2=\{BD\},𝑐[1][2]=\max⁡\{ 𝑐[0][2],𝑐[1][1]\}=0, b[1][2]=2\\...\\j=4,Y_4=\{BDCA\},𝑐[1][4]=c[0][3]+1=1, b[1][4]=1\\...\\i=7,X_7=\{ABCBDAB\}\\j=6,Y_6=\{BDCABA\},\max⁡\{ 𝑐[6][6],𝑐[7][5]\}=4, b[7][6]=2 or 3\end{matrix}</script><p><img src="https://i.loli.net/2021/11/03/AiVcQH3dqO6XTpa.png" alt="c表与b表" style="zoom:50%;" /></p><p>斜线箭头尾部位置对应的元素为公共子序列元素（下标从1开始），也就是有BCBA（x[2346]与y[1356]）\BCAB（x[2367]与y[1345]）</p><p>PS: 对于C[1,1]=max{c[0,1],c[1,0]}={0,0}=0等情况，此时，b[1,1]=2或3都可以，不影响最终的结果。可能有多个答案。</p></blockquote><h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><p><strong>问题描述</strong> n个整数组成的序列，求该序列连续子段和的最大值（规定当所有<br>整数均为负整数时定义其最大子段和为0）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MaxSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> *a)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>, b=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (b&gt;<span class="hljs-number">0</span>) b+=a[i];<br>        <span class="hljs-keyword">else</span> b=a[i];<br>        <span class="hljs-keyword">if</span> (b&gt;sum) sum=b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><script type="math/tex; mode=display">b[j]= \min\{b[j-1]+a[j],a[j]\}(1\leq j \leq n)</script><p><strong>解释</strong> b[j]为以a[1,j]之间的任一位置开始，以a[j]为结束的最大子段和（必须要到j才行）。从i开始，到j-1结束的子段和的最大值&lt;=0，从i开始到j结束的子段和的最大值应该为a[j]自身。从i开始，到j-1结束的子段和的最大值大于0，此时，将a[j]加上（不是因为如果a[j]小于零就不加了，b[j]的定义就是要到j），所得到的值应该是从i开始到，j结束的子段和的最大值。 O(n)</p><blockquote><p><strong>例题</strong></p><p>a[1:6]=[-2,11,-4,13,-5,-2]</p><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{matrix}j=1,𝑏[1]=\max\{𝑏[0]+𝑎[1],𝑎[1]\}=-2,i=1\\j=2,𝑏[2]=\max\{𝑏[1]+𝑎[2],𝑎[2]\}=11,i=2\\j=3,𝑏[3]=\max\{𝑏[2]+𝑎[3],𝑎[3]\}=11-4=7,i=2(不是11)\\...\\j=6,𝑏[6]=\max\{𝑏[5]+𝑎[6],𝑎[6]\}=15-2=13,i=2(不是15)\end{matrix}</script><p>比较各个b[i]，其中最大的就是最大子段和，也就是b[4]=20,i=2开始，j=4结束</p></blockquote><h2 id="凸多边形最优三角剖分"><a href="#凸多边形最优三角剖分" class="headerlink" title="凸多边形最优三角剖分"></a>凸多边形最优三角剖分</h2><p><strong>问题描述</strong>  给定一个凸多边形 以及定义在由多边形的边和弦组成的三角形上的权函数w。求一个三角剖分，使得剖分中诸三角形上的权之和为最小。 </p><script type="math/tex; mode=display">t[i][j]=\left\{\begin{array}{cc}0 & i=j \\\min_{i\leq{k}<j} \{t[i][k]+t[k+1][j]+w(v_{i-1}v_kv_j)\} & i<j\end{array}\right.</script><p><strong>解释</strong></p><p>定义$t[i][j]$为凸子多边形的最优剖分对应权函数值， $s[i][j]$记录了$v_{i-1}$和$ v_j$一起构成三角形的第3个顶点$k$的位置，据此，用$O(n)$时间就可以构造出<br>最优三角剖分中的所有三角形。</p><p>计算最优值与矩阵连乘积相似。计算凸$n+1$多边形的最优值为$ t[1][n]$</p><blockquote><p><strong>例题</strong></p><p>（好难算啊不会考吧）</p><p><img src="https://s2.loli.net/2021/12/07/isJWTNkCPd4ORfS.png" alt=""></p><p><img src="https://s2.loli.net/2021/12/07/sTxqwMUX5JoyA3g.png" alt=""></p><p><img src="https://s2.loli.net/2021/12/07/ViKmFwAuHB3PQ27.png" alt=""></p><p><img src="https://s2.loli.net/2021/12/07/8d7TXheayMsRpr1.png" alt=""></p><p><img src="https://s2.loli.net/2021/12/07/PUfmEldrnXp9W8B.png" alt=""></p></blockquote><h2 id="图像压缩"><a href="#图像压缩" class="headerlink" title="图像压缩"></a>图像压缩</h2><p><strong>问题描述</strong>  数字化图像是n×n的像素阵列。假定每个像素有一个0~255的灰度值，存储一个像素需8位。为了减少存储空间，采用变长模式，即不同像素用不同位数来存储。</p><ol><li>线性化：图片拉直，转换为1×n^2向量</li><li>分段：分成连续的m段，每段像素存储位数相同，每段最多含256个像素点</li><li>存放信息：第i段长度（8bit），第i段中像素存储位数（3bit）</li></ol><script type="math/tex; mode=display">\begin{matrix}s[i]=\min\limits_{1 \leq k \leq \min \{i,256\}}\{s[i-k]+k*bmax(i-k+1,i)  \}+11\\bmax(i,j)=\max\limits_{i\leq k \leq j}\{a[k]\}\end{matrix}</script><p><strong>解释</strong></p><p>假设s[i]是序列{p1,p2,…,pi}的最优解，a[i]是第i个像素点的位数。</p><ol><li>假设pi自成一段，则s[i]=s[i-1]+保存pi的代价</li><li>取s[i]为min时对应的元素个数为k，s[i]=s[i-k]+保存最后k个像素的代价</li><li>保存最后k个像素的代价=k*max{k个灰度值二进制位数}+11</li></ol><blockquote><p><strong>例题</strong></p><p>求像素序列4，6，5，7，129，138，1的最优分段。</p><p><strong>解答</strong></p><script type="math/tex; mode=display">\begin{matrix}a=[3,3,3,3,8,8,1]\\s[0]=0\\s[1]=s[0]+1*\max \{3\} +11=14\\s[2]= \min \left\{\begin{matrix}s[0]+2* \max \{3,3\} + 11 = 17▲\\s[1] + 1*\max \{3\} +11 =28\end{matrix}\right.\\...\\s[7]= \min \left\{\begin{matrix}s[0]+7* \max \{3,3,3,3,8,8,1\} + 11 = 67\\s[1]+6* \max \{3,3,3,8,8,1\} + 11 = 73\\...\\s[4]+3* \max \{8,8,1\} + 11 = 58▲\\...\\s[6]+1* \max \{1\} + 11 = 62\end{matrix}\right.\end{matrix}</script><p>看s[7]=58，看58那一行是s[4]+3*max，前四个一起，后三个一起</p><p>看s[4]=23，看23那一行是s[0]+4*max，前四个就在一起，不再分</p><p>最后得到（4，6，5，7）（129，138，1）</p></blockquote><h2 id="电路布线"><a href="#电路布线" class="headerlink" title="电路布线"></a>电路布线</h2><p><strong>问题描述</strong> 确定将哪些连线安排在第一层上，使得该层上有尽可能多的连线且不相交</p><script type="math/tex; mode=display">\begin{matrix} i=1, \qquad Size(i,j) = \left\{\begin{matrix}0 && j<\pi(1)\\1 && j \geq \pi (1)\end{matrix}\right.\\\\i>1,\qquad Size(i,j) = \left\{\begin{matrix}Size(i-1,j) && j<\pi(i)\\\max \{ Size(i-1,j),Size(i-1,\pi(i)-1)+1\} && j \geq \pi (i)\end{matrix}\right.\end{matrix}</script><p><strong>解释</strong>  MNS(i,j)表示上面序号小于i，连接到下面的序号都小于j的不相交的集合，最后要求MNS(n,n)。如果j<pi(i)，(i,pi(i)）不在MNS中，将i点删除没有影响。如果j>=pi(i)，如果（i,pi(i)）不在MNS中，将i点删除没有影响，就是size(i,j)=size(i-1,j)，如果（i,pi(i)）在MNS中，就是size(i,j)=size(i-1,pi(i)-1)+1</p><blockquote><p><strong>例题</strong></p><p>已知[(1 8)(2 7)(3 4)(4 2)(5 5)(6 1)(7 9)(8 3)(9 10)(10 6)]，求最大不相交情况</p><p><strong>解答</strong></p><p>i=1，pi(1)=8，j&gt;=<strong>8</strong>的size都为1</p><p>i=2，pi(2)=7，j&lt;<strong>7</strong>的size为size(<strong>1</strong>,j)，j&gt;=<strong>7</strong>的size为size(<strong>1</strong>,j)与size(<strong>1</strong>,<strong>6</strong>)+1=1的最大值</p><p>i=3，pi(3)=4，j&lt;<strong>4</strong>的size为size(<strong>2</strong>,j)，j&gt;=<strong>4</strong>的size为size(<strong>2</strong>,j)与size(<strong>2</strong>,<strong>3</strong>)+1=1的最大值</p><p>…</p><p><img src="https://i.loli.net/2021/11/05/KxYhMGgwmodsyIp.png" alt="size表" style="zoom:50%;" /></p><p>最后size(10,10)=4，最多可以有四条不相交，斜角值改变时可以取得所求的子集，也就是[(3 4)(5 5)(7 9)(9 10)]</p></blockquote><h2 id="流水作业调度"><a href="#流水作业调度" class="headerlink" title="流水作业调度"></a>流水作业调度</h2><p><strong>问题描述</strong>   n个作业要在两台机器M1和M2上进行加工。每个作业加工的顺序都是先在M1上加工，然后在M2加工。M1和M2加工作业i所需的时间分别为ai 和bi。确定n个作业的最优加工顺序，使得加工完成所需的时间最少。</p><p><strong>算法</strong></p><ol><li>N1集合存放ai&lt;bi的作业，N2存放ai≥bi的作业</li><li>N1中作业按照ai升序排序，N2中作业按照bi降序排序</li><li>N1连接N2，计算时间</li></ol><blockquote><p><strong>例题</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">任务</th><th style="text-align:center">J1</th><th style="text-align:center">J2</th><th style="text-align:center">J3</th><th style="text-align:center">J4</th><th style="text-align:center">J5</th><th style="text-align:center">J6</th></tr></thead><tbody><tr><td style="text-align:center">工序1</td><td style="text-align:center">30</td><td style="text-align:center">120</td><td style="text-align:center">50</td><td style="text-align:center">20</td><td style="text-align:center">90</td><td style="text-align:center">110</td></tr><tr><td style="text-align:center">工序2</td><td style="text-align:center">80</td><td style="text-align:center">100</td><td style="text-align:center">90</td><td style="text-align:center">60</td><td style="text-align:center">30</td><td style="text-align:center">10</td></tr></tbody></table></div><p><strong>解答</strong></p><ol><li><p>分集合  {1,3,4}{2,5,6}</p></li><li><p>排序  {4,1,3}{2,5,6}</p></li><li><p>合并与计算时间</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">任务</th><th style="text-align:center">J4</th><th style="text-align:center">J1</th><th style="text-align:center">J3</th><th style="text-align:center">J2</th><th style="text-align:center">J5</th><th style="text-align:center">J6</th></tr></thead><tbody><tr><td style="text-align:center">M1结束</td><td style="text-align:center">20</td><td style="text-align:center">50×</td><td style="text-align:center">100×</td><td style="text-align:center">220×</td><td style="text-align:center">310×</td><td style="text-align:center"><strong>420↓</strong></td></tr><tr><td style="text-align:center">M2开始</td><td style="text-align:center">20</td><td style="text-align:center">60</td><td style="text-align:center">140</td><td style="text-align:center">230</td><td style="text-align:center">330</td><td style="text-align:center">420</td></tr><tr><td style="text-align:center">M2结束</td><td style="text-align:center"><strong>80↗</strong></td><td style="text-align:center"><strong>160↗</strong></td><td style="text-align:center"><strong>250↗</strong></td><td style="text-align:center"><strong>350↗</strong></td><td style="text-align:center">380×</td><td style="text-align:center"><strong>430</strong></td></tr></tbody></table></div><p>ps：第k个任务M2开始的时间要取第k个任务M1结束的时间和第k-1个任务M2结束的时间的较大值。</p></blockquote><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><p><strong>问题描述</strong>  给定n种物品和一个背包。物品i的重量是wi，其价值为vi，背包的容量为c。问如何选择装入背包中的物品使得装入物品的总价值最大？</p><script type="math/tex; mode=display">\begin{matrix} m(i,j) = \left\{\begin{matrix}m(i+1,j) && 0 \leq j<w_i\\ \max \{ m(i+1,j),m(i+1,j-w_i)+v_i\} && j \geq w_i\end{matrix}\right.\\\\m(n,j) = \left\{\begin{matrix}0 && 0 \leq j<w_n\\ v_n && j \geq w_n\end{matrix}\right.\end{matrix}</script><p><strong>解释</strong>  m[i,j]表示可选择物品i, i+1, …, n时，背包容量为j装入的最大价值</p><blockquote><p><strong>例题</strong></p><p>n=5,c=10,W={2,2,6,5,4},V={6,3,5,4,6}</p><p><strong>解答</strong></p><p>i=5时，j<4时，装不进去，为0，j>=4时，能把w5=4装进去，为v5=6</p><p>i=4时，若j<5，则w4=5无法放入，m(4,j)=m(5,j)，j>=5时，比较m(5,j)与m(5,j-5)+4的最大值（可以看作先直接把m(5,j)往上复制一行，j&gt;=5时再比较更新即可，后面同理）</p><p>i=3时，若j<6，则w4=6无法放入，m(3,j)=m(4,j)，j>=6时，比较m(4,j)与m(4,j-6)+5的最大值</p><p>… 最后结果如下图</p><p><img src="https://i.loli.net/2021/11/13/Gn7oYtlkrdaIzhC.png" style="zoom:50%;" />当</p><p>从m(1,10)开始看起，m(1,10)!=m(2,10),说明1肯定被放入了背包中。1的重量为2，剩下的容量为10-2=8；</p><p>从m(2,8)开始看起，m(2,8)!=m(3,8),说明2肯定被放入了背包中。2的重量为2，剩下的容量为8-2=6；</p><p>从m(3,6)开始看起，m(3,6)=m(4,6),说明3肯定没有放入背包中。继续m(4,6)=m(5,6),说明4肯定没有放入背包中。</p><p>当i=5时，看剩余的容量，如果满足5号物品的重量，则5肯定放入。否则，5无法放入。此例，容量为6，5号物品重量为4，5号物品放入。</p><p>最后得到放入的五件物品状态为<strong>(1,1,0,0,1)</strong></p></blockquote><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><strong>思想</strong>  在贪婪算法中采用逐步构造最优解的方法。在每个阶段，都作出一个看上去最优的决策。它并不一定对所有问题都成功，因为不从整体最优加以考虑，贪心解法可能不是全局最优解，但是对某些问题特别简单、有效。</p><p><strong>基本要素</strong></p><ol><li><strong>最优子结构性质</strong>  问题的最优解包含其子问题的最优解</li><li><strong>贪心选择性质</strong>  问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到，当前的选择和子问题的解无关，只和以往做出的选择有关</li></ol><h2 id="活动安排"><a href="#活动安排" class="headerlink" title="活动安排"></a>活动安排</h2><p><strong>问题描述</strong>  在活动集合中选择最大的相容活动子集合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Type&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GreedySelector</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,Type s[],Type f[],<span class="hljs-keyword">bool</span> A[] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">//s存开始时间，f存结束时间，且按结束时间非减续排列；</span></span></span><br><span class="hljs-params"><span class="hljs-function">    A[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>; <span class="hljs-comment">//排在第1个的活动最先结束，直接放入A；</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-comment">//从第2个活动开始检测</span></span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-keyword">if</span> (s[i]&gt;=f[j]) &#123; A[i]=<span class="hljs-literal">true</span>; j=i; &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-comment">//如果相容，放入A</span></span></span><br><span class="hljs-params"><span class="hljs-function">       <span class="hljs-keyword">else</span> A[i]=<span class="hljs-literal">false</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure><p><strong>证明贪心选择性质</strong></p><ol><li>假设问题有一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始，做了贪心选择后，原问题简化为规模更小的类似子问题。</li><li>运用数学归纳法证明，每一步贪心选择→问题的整体最优解</li></ol><blockquote><p><strong>例题</strong></p><div class="table-container"><table><thead><tr><th></th><th style="text-align:center">1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>start</td><td style="text-align:center">5</td><td>0</td><td>3</td><td>5</td><td>3</td><td>1</td><td style="text-align:center">8</td><td style="text-align:center">6</td><td style="text-align:center">8</td><td>12</td><td>2</td></tr><tr><td>stop</td><td style="text-align:center">9</td><td>6</td><td>5</td><td>7</td><td>8</td><td>4</td><td style="text-align:center">11</td><td style="text-align:center">10</td><td style="text-align:center">12</td><td>14</td><td>13</td></tr></tbody></table></div><p><strong>解答</strong></p><p>待安排的11个活动按结束时间的非减序排列</p><div class="table-container"><table><thead><tr><th></th><th style="text-align:center">6</th><th>3</th><th>2</th><th>4</th><th>5</th><th>1</th><th style="text-align:center">8</th><th style="text-align:center">7</th><th style="text-align:center">9</th><th>11</th><th>10</th></tr></thead><tbody><tr><td>start</td><td style="text-align:center"><strong>1</strong></td><td>3</td><td>0</td><td><strong>5</strong></td><td>3</td><td>5</td><td style="text-align:center">6</td><td style="text-align:center"><strong>8</strong></td><td style="text-align:center">8</td><td>2</td><td><strong>12</strong></td></tr><tr><td>stop</td><td style="text-align:center"><strong>4</strong></td><td>5</td><td>6</td><td><strong>7</strong></td><td>8</td><td>9</td><td style="text-align:center">10</td><td style="text-align:center"><strong>11</strong></td><td style="text-align:center">12</td><td>13</td><td><strong>14</strong></td></tr></tbody></table></div><p>最后为(6,4,7,10)</p></blockquote><h2 id="0-1背包-1"><a href="#0-1背包-1" class="headerlink" title="0-1背包"></a>0-1背包</h2><p><strong>几种贪心策略</strong>（但是都不能保证得到最优解）</p><ol><li>选择可以装入背包的价值最大的物品</li><li>选择可装入背包的重量最小的物品</li><li>选择可装入背包的vi/wi最大的物品（一般用来做回溯法或者分支限界的限界函数）</li></ol><h2 id="最优装载"><a href="#最优装载" class="headerlink" title="最优装载"></a>最优装载</h2><p><strong>策略</strong>  重量最轻的先装  T(n)=O(nlogn)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Loading</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x[], Type w[], Type c, <span class="hljs-keyword">int</span> n )</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> *t = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [n+<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">Sort</span>(w, t, n) ; <span class="hljs-comment">//按货箱重量排序/</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; = n; i ++)<br>    x[i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;= n &amp;&amp; w[t[i]] &lt;= c; i++) &#123;<br>        [t[i]] = <span class="hljs-number">1</span>;<br>        c-= w[t[i]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>例题</strong></p><p>(100,200,50,90,150,50,20,80), c=400</p><p><strong>解答</strong></p><p>所考察货箱的次序为73684152，考察到5时装不下了</p><p>(<strong>100</strong>,200,<strong>50</strong>,<strong>90</strong>,150,<strong>50</strong>,<strong>20</strong>,<strong>80</strong>) 装了390</p><p>(1,0,1,1,0,1,1,1)</p></blockquote><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p><strong>前缀码</strong>  对每一个字符规定一个0,1串作为其代码，并要求任一字符的代码都不是其它字符代码的前缀，这种编码称为前缀码。</p><p><strong>问题描述</strong>  找到使平均码长达到最小的前缀码编码方案</p><p><strong>策略</strong>  频率小的字符，深度大。队列Q以f(c)为键值存放二叉树各结点，通过贪心选择，将最小频率的两个二叉树合并，然后将新树（频率为上述两个二叉树频率之和）插入Q中。   T(n)=O(nlogn)</p><p><strong>证明贪心选择性质</strong></p><p>设x和y是字符集C中具有最小频率的两个字符，证明存在C的最优前缀码，使x和y具有最长、相同的码长且仅最后一位编码不同。设二叉树T表示C的任意一个最优前缀码方案。只要证明可以对T做适当修改后，得到一棵新的二叉树T’， 新树中，x和y是最深叶子且为兄弟。同时，新树也是C的最优前缀码方案。</p><p><strong>证明最优子结构性质</strong></p><p>设T表示C的一个最优前缀码方案。x和y是树T中的叶子节点且为兄弟。z是它们的父亲。若将z看做是具有频率f(z)=f(x)+f(y)的字符，则证明树T’=T-{x,y}表示字符集C’=C-{x,y} U {z}的一个最优前缀码即可。</p><blockquote><p><strong>例题</strong></p><p>设在1000个字母的文章中各字母出现的频率为a:83, b:14,  c:28,  d:38,  e:131,  f:29,  g:20,  h:53……，求最优编码。</p><p><strong>解答</strong></p><p><img src="https://i.loli.net/2021/11/14/5kI9jcio2xabpgC.png" style="zoom: 67%;" /></p><p>ps:注意兄弟节点左小右大（按题目规定）</p></blockquote><h2 id="单源最短路径-dijksta"><a href="#单源最短路径-dijksta" class="headerlink" title="单源最短路径(dijksta)"></a>单源最短路径(dijksta)</h2><p><a href="https://www.bilibili.com/video/BV1q4411M7r9">dijksta视频演示</a></p><blockquote><p><strong>例题</strong></p><p><img src="https://i.loli.net/2021/11/14/VuRe1vE9fZ6tKcS.png"  style="zoom: 33%;" /></p><p><strong>解答</strong></p><p><img src="https://i.loli.net/2021/11/16/81LgIlVw5zusOx9.png" style="zoom:25%;" /></p><p><img src="https://i.loli.net/2021/11/14/RuqJGtPOHmzlV6n.png" style="zoom: 25%;" /></p></blockquote><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>特点</strong>  深度优先搜索策略、算法框架是解空间（子集树与排列树）、在搜索的时候要避免遗漏，同时要高效。（具有限界函数的深度优先生成法称为回溯法）</p><p><strong>解空间</strong>  子集树（0-1，装载，子集和）与排列树（旅行商，m着色，n后）</p><p><strong>基本元素</strong>  活结点（自身已生成但其儿子还没有全部生成），拓展结点（正在产生儿子的结点），死结点（不满足约束或者所有儿子已经产生的结点）</p><p><strong>剪枝</strong>  用约束函数在扩展结点处剪去不满足约束的子树（左剪枝），用限界函数剪去得不到最优解的子树（右剪枝）</p><p><strong>终止条件</strong>  找到所有的解，解空间中没有活结点为止</p><h2 id="装载问题"><a href="#装载问题" class="headerlink" title="装载问题"></a>装载问题</h2><p><strong>问题描述</strong>   n个集装箱要装到2艘载重量分别为c1,c2的货轮，其中集装箱 i的重量为wi。要求找到装载方案将这n个货箱装上这2艘轮船</p><p><strong>解释</strong>  若装载问题有解, 采用如下策略可得一个最优装载方案：将第一艘轮船尽可能装满，将剩余的货箱装到第二艘轮船上。将第一艘船尽可能装满类似0-1背包问题</p><blockquote><p><strong>例题</strong></p><p>n=4,c1=12,W={8,6,2,3}</p><p><strong>解答</strong></p><p><img src="https://i.loli.net/2021/11/14/zurCOpm69MXy3Hk.png"  style="zoom: 67%;" /></p></blockquote><h2 id="0-1背包-2"><a href="#0-1背包-2" class="headerlink" title="0-1背包"></a>0-1背包</h2><p><strong>解释</strong>  子集树。只要左儿子节点是一个可行结点，搜索就进入左子树（不超过背包重量）（约束剪枝）。在右子树中有可能包含最优解是才进入右子树搜索，否则将右子树剪去（利用单价贪心求解价值上限）（限界剪枝）。cw是背包当前重量，M-cw是背包剩余的空间，cp是当前总收益，rp是贪心算法剩余的物品收益，bestw记录当前最优价值，也就是判断bp=cp+cp&gt;bestw是右节点的限界函数。（此外，回溯法解0/1背包的前置条件是物品已按pi/wi非增次序排序）</p><blockquote><p><strong>例题</strong></p><p>M=110，w=(1,11,21,23,33,43,45,55)，v=(11,21,31,33,43,53,55,65)</p><p><strong>解答</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th></tr></thead><tbody><tr><td style="text-align:center">w</td><td style="text-align:center">1</td><td style="text-align:center">11</td><td style="text-align:center">21</td><td style="text-align:center">23</td><td style="text-align:center">33</td><td style="text-align:center">43</td><td style="text-align:center">45</td><td style="text-align:center">55</td></tr><tr><td style="text-align:center">v</td><td style="text-align:center">11</td><td style="text-align:center">21</td><td style="text-align:center">31</td><td style="text-align:center">33</td><td style="text-align:center">43</td><td style="text-align:center">53</td><td style="text-align:center">55</td><td style="text-align:center">65</td></tr><tr><td style="text-align:center">v/w</td><td style="text-align:center">11</td><td style="text-align:center">1.9</td><td style="text-align:center">1.48</td><td style="text-align:center">1.43</td><td style="text-align:center">1.3</td><td style="text-align:center">1.23</td><td style="text-align:center">1.22</td><td style="text-align:center">1.18</td></tr></tbody></table></div><p><img src="https://i.loli.net/2021/11/14/7TLS4elkFUYRHOu.png" style="zoom:50%;" /></p><p>最优解为<strong>(1,1,1,0,1,1,0,0)</strong></p></blockquote><h2 id="n后问题"><a href="#n后问题" class="headerlink" title="n后问题"></a>n后问题</h2><p><strong>问题描述</strong>   皇后问题要求在一个n×n的棋盘上放置n个皇后，使得它们彼此不受“攻击”。n皇后问题要求寻找在棋盘上放置这n个皇后的方案，使得它们中任何两个都不在同一行、同一列或同一斜线上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nQueen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    Queen X；<br>    <span class="hljs-comment">//初始化X    </span><br>    X.n=n；<span class="hljs-comment">//皇后个数</span><br>    X.sum=<span class="hljs-number">0</span>；<br>    <span class="hljs-keyword">int</span>*p=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [n+<span class="hljs-number">1</span>]；<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>；i&lt;=n；i++) p[i]= <span class="hljs-number">0</span>；<br>    X.x=p；<br>    X.<span class="hljs-built_in">Backtrack</span>(<span class="hljs-number">1</span>)；<br>    <span class="hljs-keyword">delete</span> [] p；<br>    returnX. sum;<br>&#125;<br><br><span class="hljs-keyword">bool</span> Queen:: <span class="hljs-built_in">Place</span>(<span class="hljs-keyword">int</span> k) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; k; j++)<br>      <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">abs</span>(k-j) == <span class="hljs-built_in">abs</span>(x[j] - x[k])) <br>        ||(x[j] == x[k] ))<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br> <br><span class="hljs-keyword">void</span> Queen:: <span class="hljs-built_in">Backtrack</span>(<span class="hljs-keyword">int</span> t) &#123;<br>    <span class="hljs-keyword">if</span> (t &gt; n) <br>        sum++;<br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) &#123;<br>         x[t] = i;<br>         <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Place</span>(t)) <br>             <span class="hljs-built_in">Backtrack</span>(t+<span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释</strong>  (x1, …, xn) , x[i]表示皇后i放在棋盘的第i行的第x[i]列，解空间是排列树。abs(i-j)≠abs(x[i] – x[j]))是约束函数（不在同一列已经实现）。如下图是4皇后的一个解。</p><p><img src="https://i.loli.net/2021/11/14/8KqMfCEVO9LyBxs.png" style="zoom: 67%;" /></p><h2 id="m着色"><a href="#m着色" class="headerlink" title="m着色"></a>m着色</h2><p><strong>解释</strong>  n元组(x0,x1,…,xn-1)表示图G的m-着色判定问题的解。对所有i和j，若邻接矩阵a[i，j]=1，则xi≠xj（约束条件）</p><blockquote><p><strong>例题</strong></p><p>使用回溯算法来求解图的m(m=3)着色问题的如下图实例。<br>(1) 给出解向量的形式，指出解空间树的类型。<br>(2) 描述搜索过程。<br>(3) 画出找到一个解所生成的部分搜索树，并给出这个解。</p><p><img src="https://i.loli.net/2021/11/14/uSJZqLQAlK3TedO.png" style="zoom: 67%;" /></p><p><strong>解答</strong></p><p>X=(x0,x1,x2,x3,x4)</p><p><img src="https://i.loli.net/2021/11/14/usNAxhWT4jkSvbQ.png" style="zoom: 67%;" /></p><p><strong>X=(1,2,3,2,1)</strong></p></blockquote><h2 id="旅行售货员"><a href="#旅行售货员" class="headerlink" title="旅行售货员"></a>旅行售货员</h2><h2 id="子集和"><a href="#子集和" class="headerlink" title="子集和"></a>子集和</h2><p><strong>问题描述</strong>  给出n个正实数集合与正整数M，找到元素之和为M的子集</p><blockquote><p><strong>例题</strong></p><p>设有n=6个正数的集合{5,10,12,13,15,18}和整数M=30，求W的所有元素之和为M的子集</p><p><strong>解答</strong></p><p><img src="https://i.loli.net/2021/11/14/ioq9NwWbhaYLnpT.png" style="zoom: 50%;" /></p><p>最后一步，5，6两个物品全要为31，所以不要前四个物品的右子树肯定不需要考虑了。</p></blockquote><h1 id="分支限界"><a href="#分支限界" class="headerlink" title="分支限界"></a>分支限界</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p><strong>解空间</strong>  子集树（单源最短路径问题）与排列树（售货商）</p><p><strong>搜索方式</strong>  广度优先或最小耗费优先</p><p><strong>适用问题</strong>  存在性问题（找出满足约束条件的一个解）与最优化问题（在满足约束条件的解中找出在某种意义下的最优解） </p><p><strong>活结点表（其实叫队列更好一点）</strong></p><ul><li>每一个活结点只有一次机会成为扩展结点</li><li>活结点一旦成为扩展结点，一次性产生其所有儿子结点（导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中）</li><li>从活结点表中取出下一结点成为当前扩展结点，并重复结点扩展过程</li><li>直到找到所需的解或活结点表为空时为止</li></ul><p><strong>选择扩展结点的两种常用方法</strong>  队列式（先进先出）、优先队列式（按照耗费/收益优先级选取下一个结点作为当前拓展结点）</p><h2 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h2><p>子集树</p><p>剪枝的原则：在扩展顶点i时，如果从当前扩展结点i到j有边可达，且从源出发途经i再到j的所对应路径长度小于当前最优路径长度，则将该顶点作为活结点插入到活结点优先队列中</p><blockquote><p><strong>例题</strong></p><p><img src="https://i.loli.net/2021/11/16/wrZ41YiqExp6QSc.png" style="zoom: 67%;" /></p><p><strong>解答</strong></p><ol><li><p>队列法</p><p><img src="https://i.loli.net/2021/11/16/bjfoQFy5YwlKaDS.png" style="zoom:50%;" /></p></li><li><p>优先队列法（dist短的优先）</p><p><img src="https://i.loli.net/2021/11/16/uymLatcUjOD2ksX.png" style="zoom:35%;" /></p></li></ol><p>结果</p><p><strong>dist=(10,30,60,16,50)</strong></p><p><strong>prev=(0,0,5,1,2)</strong></p></blockquote><h2 id="装载问题-1"><a href="#装载问题-1" class="headerlink" title="装载问题"></a>装载问题</h2><p>子集树</p><p>约束函数：已装容量与c1容量</p><p>限界函数：un=已经装载的重量ew+剩余重量r</p><blockquote><p><strong>例题</strong></p><p>n=4,c_1=12,W={8,6,3,2}</p><p><strong>解答</strong></p><p>优先队列法（un大的先拓展）</p><p>叶子结点成为扩展结点，得到一个最优解</p><p><img src="https://i.loli.net/2021/11/16/X4e2TVIv6z8GZsO.png" style="zoom:67%;" /></p><p>解为(1,0,1,0)</p></blockquote><h2 id="0-1背包-3"><a href="#0-1背包-3" class="headerlink" title="0-1背包"></a>0-1背包</h2><blockquote><p><strong>例题</strong></p><p>n=3, w=[20,15,15], v=[45,25,25], c= 30</p><p><strong>解答</strong></p><ol><li><p>队列法</p><p><img src="https://i.loli.net/2021/11/14/o8DeUcu1SzGlpP6.png" style="zoom:50%;" /></p></li><li><p>优先队列法（价值大的先拓展）</p><p><img src="https://i.loli.net/2021/11/16/okxtwCMfvdA1SsO.png" style="zoom:50%;" /></p></li></ol><p>取(0,1,1)</p></blockquote><h2 id="最大团"><a href="#最大团" class="headerlink" title="最大团"></a>最大团</h2><p>完全子图（图中所有点任意连线都在原图中）</p><p>团（最大完全子图）</p><p>空子图（图中所有点任意连线不在原图中）</p><p>最大独立集（最大空子图）</p><p>补图（原图的完全图-原图，点不变）</p><p>有：若U是G的一个最大团，则U是G的补图G‘的一个最大独立集</p><p><img src="https://i.loli.net/2021/11/16/PK1ROEXvV3mJlcY.png" style="zoom:50%;" /></p><p>约束条件：是否是团（该顶点与当前团中其它顶点之间是否有边相连）</p><p>限界函数：当前团尺寸cn+剩余顶点数目r≤当前已求出最大尺寸bestn</p><p>优先级：un=cn+r</p><p>终止条件：遇到子集树中的一个叶结点（即n+1层结点）成为当前扩展结点</p><blockquote><p><strong>例题</strong></p><p><img src="https://i.loli.net/2021/11/16/ZKs1IP4xDRMmgbO.png" alt=""></p><p><strong>解答</strong></p><p>优先队列法（un大的先拓展）</p><p><img src="https://i.loli.net/2021/11/16/PMr6sCnxNp7hkGo.png" style="zoom: 67%;" /></p><p>一个可行结果为(1，1，1，0)</p></blockquote><h2 id="回溯与分支限界对比"><a href="#回溯与分支限界对比" class="headerlink" title="回溯与分支限界对比"></a>回溯与分支限界对比</h2><p><img src="https://i.loli.net/2021/11/16/QEZtAoMVafKiuY4.png" alt="回溯与分支限界对比" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>CUMT课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>分治</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心</tag>
      
      <tag>回溯</tag>
      
      <tag>分支限界</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/10/26/hello-world/"/>
    <url>/2021/10/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
